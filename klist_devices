CREDITS:D: EIDE PCI and bus-master DMA support
Documentation/00-INDEX:bus-devices/
Documentation/00-INDEX:bus-virt-phys-mapping.txt
Documentation/ABI/stable/sysfs-bus-usb:		All descriptors read from this file are in bus-endian format
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/version
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/request
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/00:<bus-num>/ppi/response
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/transition_action
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/tcg_operations
Documentation/ABI/testing/sysfs-driver-ppi:What:		/sys/devices/pnp0/<bus-num>/ppi/vs_operations
Documentation/DocBook/device-drivers.tmpl:!Idrivers/message/i2o/bus-osm.c
Documentation/DocBook/drm.tmpl:	    call a bus-specific operation to retrieve the IRQ number. For platform
Documentation/DocBook/media/v4l/compat.xml:	    <xref linkend="v4l2-mbus-vendor-spec-fmts" />.</para>
Documentation/DocBook/media/v4l/media-ioc-device-info.xml:	    bus-specific identifier.</entry>
Documentation/DocBook/media/v4l/subdev-formats.xml:<section id="v4l2-mbus-format">
Documentation/DocBook/media/v4l/subdev-formats.xml:  <table pgwide="1" frame="none" id="v4l2-mbus-framefmt">
Documentation/DocBook/media/v4l/subdev-formats.xml:	  <entry>Format code, from &v4l2-mbus-pixelcode;.</entry>
Documentation/DocBook/media/v4l/subdev-formats.xml:  <section id="v4l2-mbus-pixelcode">
Documentation/DocBook/media/v4l/subdev-formats.xml:      <table pgwide="0" frame="none" id="v4l2-mbus-pixelcode-rgb">
Documentation/DocBook/media/v4l/subdev-formats.xml:      <table pgwide="0" frame="none" id="v4l2-mbus-pixelcode-bayer">
Documentation/DocBook/media/v4l/subdev-formats.xml:	<para><xref linkend="v4l2-mbus-pixelcode-yuv8"/> list existing packet YUV
Documentation/DocBook/media/v4l/subdev-formats.xml:      <table pgwide="0" frame="none" id="v4l2-mbus-pixelcode-yuv8">
Documentation/DocBook/media/v4l/subdev-formats.xml:      <table pgwide="0" frame="none" id="v4l2-mbus-pixelcode-jpeg">
Documentation/DocBook/media/v4l/subdev-formats.xml:    <section id="v4l2-mbus-vendor-spec-fmts">
Documentation/DocBook/media/v4l/subdev-formats.xml:      <table pgwide="0" frame="none" id="v4l2-mbus-pixelcode-vendor-specific">
Documentation/DocBook/media/v4l/v4l2.xml:    &sub-subdev-enum-mbus-code;
Documentation/DocBook/media/v4l/vidioc-subdev-enum-frame-interval.xml:	    <xref linkend="v4l2-mbus-format" />.</entry>
Documentation/DocBook/media/v4l/vidioc-subdev-enum-frame-size.xml:    &v4l2-subdev-mbus-code-enum; and call the
Documentation/DocBook/media/v4l/vidioc-subdev-enum-frame-size.xml:	    <xref linkend="v4l2-mbus-format" />.</entry>
Documentation/DocBook/media/v4l/vidioc-subdev-enum-mbus-code.xml:<refentry id="vidioc-subdev-enum-mbus-code">
Documentation/DocBook/media/v4l/vidioc-subdev-enum-mbus-code.xml:    <structfield>index</structfield> fields of &v4l2-subdev-mbus-code-enum; and
Documentation/DocBook/media/v4l/vidioc-subdev-enum-mbus-code.xml:    <table pgwide="1" frame="none" id="v4l2-subdev-mbus-code-enum">
Documentation/DocBook/media/v4l/vidioc-subdev-enum-mbus-code.xml:	    <xref linkend="v4l2-mbus-format" />.</entry>
Documentation/DocBook/media/v4l/vidioc-subdev-enum-mbus-code.xml:	  <para>The &v4l2-subdev-mbus-code-enum; <structfield>pad</structfield>
Documentation/DocBook/media/v4l/vidioc-subdev-g-fmt.xml:	    <entry>&v4l2-mbus-framefmt;</entry>
Documentation/DocBook/media/v4l/vidioc-subdev-g-fmt.xml:	    linkend="v4l2-mbus-framefmt" /> for details.</entry>
Documentation/DocBook/writing-an-alsa-driver.tmpl:      bus-&gt;clock to the corresponding
Documentation/SM501.txt:need to create a new bus-type and the associated code to go with it.
Documentation/acpi/namespace.txt:   The linking mechanism is generally bus-specific.  The core of its
Documentation/bus-virt-phys-mapping.txt:The AHA-1542 is a bus-master device, and your patch makes the driver give the
Documentation/devicetree/bindings/ata/cavium-compact-flash.txt:- cavium,bus-width: The width of the connection to the CF devices.  Valid
Documentation/devicetree/bindings/ata/cavium-compact-flash.txt:		cavium,bus-width = <16>;
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:- compatible:	Should be set to "marvell,mbus-controller".
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:			mbusc: mbus-controller@20000 {
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:				compatible = "marvell,mbus-controller";
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:			mbusc: mbus-controller@20000 {
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:				compatible = "marvell,mbus-controller";
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:			mbusc: mbus-controller@20000 {
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:				compatible = "marvell,mbus-controller";
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:The mbus-node ranges property defines a set of mbus windows that are expected
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:		devbus-bootcs {
Documentation/devicetree/bindings/bus/mvebu-mbus.txt:			mbusc: mbus-controller@20000 {
Documentation/devicetree/bindings/bus/ti-gpmc.txt: - gpmc,bus-turnaround-ns:	Turn-around time between successive accesses
Documentation/devicetree/bindings/bus/ti-gpmc.txt: - gpmc,wr-data-mux-bus-ns:	In address-data multiplex mode, specifies
Documentation/devicetree/bindings/clock/calxeda.txt:	"calxeda,hb-a9bus-clock" - The A9 bus clock divided from the A9 clock.
Documentation/devicetree/bindings/extcon/extcon-palmas.txt: - ti,enable-vbus-detection: Perform VBUS detection.
Documentation/devicetree/bindings/fb/mxsfb.txt:- bus-width : number of data lines.  Could be <8>, <16>, <18> or <24>.
Documentation/devicetree/bindings/fb/mxsfb.txt:		bus-width = <24>;
Documentation/devicetree/bindings/i2c/i2c-cbus-gpio.txt:Device tree bindings for i2c-cbus-gpio driver
Documentation/devicetree/bindings/i2c/i2c-cbus-gpio.txt:	- compatible = "i2c-cbus-gpio";
Documentation/devicetree/bindings/i2c/i2c-cbus-gpio.txt:	compatible = "i2c-cbus-gpio";
Documentation/devicetree/bindings/i2c/i2c-s3c2410.txt:  - samsung,i2c-max-bus-freq: Desired frequency in Hz of the bus. If not
Documentation/devicetree/bindings/i2c/i2c-s3c2410.txt:		samsung,i2c-max-bus-freq = <100000>;
Documentation/devicetree/bindings/i2c/max6697.txt:- smbus-timeout-disable
Documentation/devicetree/bindings/i2c/max6697.txt:	smbus-timeout-disable;
Documentation/devicetree/bindings/marvell.txt:	     bus-range = <0 255>;
Documentation/devicetree/bindings/media/samsung-fimc.txt:					bus-width = <8>;
Documentation/devicetree/bindings/media/samsung-fimc.txt:					bus-width = <8>;
Documentation/devicetree/bindings/media/samsung-mipi-csis.txt:- bus-width	  : maximum number of data lanes supported (SoC specific);
Documentation/devicetree/bindings/media/video-interfaces.txt:divided into two separate ITU-R BT.656 8-bit busses.  In such case bus-width
Documentation/devicetree/bindings/media/video-interfaces.txt:- bus-width: number of data lines actively used, valid for the parallel busses.
Documentation/devicetree/bindings/media/video-interfaces.txt:- data-shift: on the parallel data busses, if bus-width is used to specify the
Documentation/devicetree/bindings/media/video-interfaces.txt:  used, e.g. "bus-width=<8>; data-shift=<2>;" means, that lines 9:2 are used.
Documentation/devicetree/bindings/media/video-interfaces.txt:				bus-width = <8>;	/* Used data lines */
Documentation/devicetree/bindings/media/video-interfaces.txt:					bus-width = <8>;
Documentation/devicetree/bindings/memory-controllers/mvebu-devbus.txt: - devbus,bus-width:    Defines the bus width (e.g. <16>)
Documentation/devicetree/bindings/memory-controllers/mvebu-devbus.txt:	devbus-bootcs@d0010400 {
Documentation/devicetree/bindings/memory-controllers/mvebu-devbus.txt:		devbus,bus-width    = <8>;
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:- ranges: There must be one one triplet of (child-bus-address,
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:  parent-bus-address, length) for each active chip select.  If the
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:- compatible:  "cavium,octeon-3860-bootbus-config"
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:- cavium,bus-width: A cell specifying the WIDTH parameter (in bits) of
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:			compatible = "cavium,octeon-3860-bootbus-config";
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:			cavium,bus-width = <8>;
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:			compatible = "cavium,octeon-3860-bootbus-config";
Documentation/devicetree/bindings/mips/cavium/bootbus.txt:			cavium,bus-width = <16>;
Documentation/devicetree/bindings/mips/cavium/dma-engine.txt:- compatible: "cavium,octeon-5750-bootbus-dma"
Documentation/devicetree/bindings/mips/cavium/dma-engine.txt:		compatible = "cavium,octeon-5750-bootbus-dma";
Documentation/devicetree/bindings/misc/ifm-csi.txt:- ifm,csi-addr-bus-width: address bus width (valid values are 16, 24, 25)
Documentation/devicetree/bindings/misc/ifm-csi.txt:- ifm,csi-data-bus-width: data bus width (valid values are 8 and 16)
Documentation/devicetree/bindings/misc/ifm-csi.txt:		ifm,csi-addr-bus-width = <24>;
Documentation/devicetree/bindings/misc/ifm-csi.txt:		ifm,csi-data-bus-width = <8>;
Documentation/devicetree/bindings/mmc/atmel-hsmci.txt:- bus-width: number of data lines connected to the controller
Documentation/devicetree/bindings/mmc/atmel-hsmci.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mmc/atmel-hsmci.txt:		bus-width = <4>;
Documentation/devicetree/bindings/mmc/atmel-hsmci.txt:		bus-width = <4>;
Documentation/devicetree/bindings/mmc/brcm,bcm2835-sdhci.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mmc/davinci_mmc.txt:- bus-width: Number of data lines, can be <1>, <4>, or <8>, default <1>
Documentation/devicetree/bindings/mmc/davinci_mmc.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mmc/exynos-dw-mshc.txt:  rest of the gpios (depending on the bus-width property) are the data lines in
Documentation/devicetree/bindings/mmc/exynos-dw-mshc.txt:			bus-width = <8>;
Documentation/devicetree/bindings/mmc/fsl-esdhc.txt:    "bus-width = <1>" property.
Documentation/devicetree/bindings/mmc/fsl-imx-mmc.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mmc/mmc.txt:- bus-width: Number of data lines, can be <1>, <4>, or <8>.  The default
Documentation/devicetree/bindings/mmc/mmc.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mmc/mxs-mmc.txt:	bus-width = <8>;
Documentation/devicetree/bindings/mmc/nvidia,tegra20-sdhci.txt:	bus-width = <8>;
Documentation/devicetree/bindings/mmc/samsung-sdhci.txt:		bus-width = <4>;
Documentation/devicetree/bindings/mmc/sdhci-pxa.txt:	bus-width = <8>;
Documentation/devicetree/bindings/mmc/synopsys-dw-mshc.txt:	* bus-width: as documented in mmc core bindings.
Documentation/devicetree/bindings/mmc/synopsys-dw-mshc.txt:			bus-width = <8>;
Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt:		bus-width = <4>;
Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt:		bus-width = <4>;
Documentation/devicetree/bindings/mmc/vt8500-sdmmc.txt:	bus-width = <4>;
Documentation/devicetree/bindings/mtd/atmel-nand.txt:- nand-bus-width : 8 or 16 bus width if not present 8
Documentation/devicetree/bindings/mtd/flctl-nand.txt:- nand-bus-width : bus width to NAND chip
Documentation/devicetree/bindings/mtd/flctl-nand.txt:		nand-bus-width = <16>;
Documentation/devicetree/bindings/mtd/gpmc-nand.txt: - nand-bus-width: 		Set this numeric value to 16 if the hardware
Documentation/devicetree/bindings/mtd/gpmc-nand.txt:			nand-bus-width = <16>;
Documentation/devicetree/bindings/mtd/gpmc-nand.txt:			gpmc,wr-data-mux-bus-ns = <0>;
Documentation/devicetree/bindings/mtd/gpmc-nor.txt:		gpmc,bus-turnaround-ns = <12>;
Documentation/devicetree/bindings/mtd/gpmc-nor.txt:		gpmc,wr-data-mux-bus-ns = <90>;
Documentation/devicetree/bindings/mtd/mxc-nand.txt:- nand-bus-width: see nand.txt
Documentation/devicetree/bindings/mtd/mxc-nand.txt:		nand-bus-width = <8>;
Documentation/devicetree/bindings/mtd/nand.txt:- nand-bus-width : 8 or 16 bus width if not present 8
Documentation/devicetree/bindings/net/gpmc-eth.txt:		gpmc,bus-turnaround-ns = <12>;
Documentation/devicetree/bindings/net/gpmc-eth.txt:		gpmc,wr-data-mux-bus-ns = <90>;
Documentation/devicetree/bindings/pci/83xx-512x-pci.txt:		bus-range = <0x0 0x0>;
Documentation/devicetree/bindings/pci/mvebu-pci.txt:- bus-range: PCI bus numbers covered
Documentation/devicetree/bindings/pci/mvebu-pci.txt:	bus-range = <0x00 0xff>;
Documentation/devicetree/bindings/pci/nvidia,tegra20-pcie.txt:- bus-range: Range of bus numbers associated with this controller
Documentation/devicetree/bindings/pci/nvidia,tegra20-pcie.txt:		bus-range = <0x00 0xff>;
Documentation/devicetree/bindings/pci/ralink,rt3883-pci.txt:   - bus-range: PCI bus numbers covered
Documentation/devicetree/bindings/pci/ralink,rt3883-pci.txt:			bus-range = <0 255>;
Documentation/devicetree/bindings/pinctrl/img,tz1090-pdc-pinctrl.txt:  - bias-bus-hold
Documentation/devicetree/bindings/pinctrl/img,tz1090-pdc-pinctrl.txt:    bias-bus-hold (which can also be provided to any of the groups below to set
Documentation/devicetree/bindings/pinctrl/img,tz1090-pinctrl.txt:  - bias-bus-hold
Documentation/devicetree/bindings/pinctrl/img,tz1090-pinctrl.txt:    bias-bus-hold (which can also be provided to any of the groups below to set
Documentation/devicetree/bindings/pinctrl/img,tz1090-pinctrl.txt:        bias-bus-hold:         supported.
Documentation/devicetree/bindings/pinctrl/img,tz1090-pinctrl.txt:    bias-pull-up, bias-pull-down, and bias-bus-hold (which can also be provided
Documentation/devicetree/bindings/pinctrl/img,tz1090-pinctrl.txt:        bias-bus-hold:         supported.
Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt:bias-bus-hold		- latch weakly
Documentation/devicetree/bindings/pinctrl/renesas,pfc-pinctrl.txt:		bus-width = <8>;
Documentation/devicetree/bindings/powerpc/fsl/cpm_qe/qe.txt:- bus-frequency : the clock frequency for QUICC Engine.
Documentation/devicetree/bindings/powerpc/fsl/cpm_qe/qe.txt:	bus-frequency = <179A7B00>;
Documentation/devicetree/bindings/powerpc/fsl/mpc5200.txt:bus-frequency		IPB bus frequency in Hz.  Clock rate
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-tx-bus-width - (optional) The bus width(number of data wires) that
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-rx-bus-width - (optional) The bus width(number of data wires) that
Documentation/devicetree/bindings/spi/spi-bus.txt:Now the value that spi-tx-bus-width and spi-rx-bus-width can receive is
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:- bus-num : the slave chip chipselect signal number.
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:	bus-num = <0>;
Documentation/devicetree/bindings/usb/atmel-usb.txt: - atmel,vbus-gpio: If present, specifies a gpio that needs to be
Documentation/devicetree/bindings/usb/atmel-usb.txt: - atmel,vbus-gpio: If present, specifies a gpio that needs to be
Documentation/devicetree/bindings/usb/atmel-usb.txt:	atmel,vbus-gpio = <&pioC 5 0>;
Documentation/devicetree/bindings/usb/atmel-usb.txt: - atmel,vbus-gpio: If present, specifies a gpio that needs to be
Documentation/devicetree/bindings/usb/atmel-usb.txt:	atmel,vbus-gpio = <&pioB 19 0>;
Documentation/devicetree/bindings/usb/ci13xxx-imx.txt:- vbus-supply: regulator for vbus
Documentation/devicetree/bindings/usb/ci13xxx-imx.txt:- external-vbus-divider: enables off-chip resistor divider for Vbus
Documentation/devicetree/bindings/usb/ci13xxx-imx.txt:	external-vbus-divider;
Documentation/devicetree/bindings/usb/exynos-usb.txt: - samsung,vbus-gpio:  if present, specifies the GPIO that
Documentation/devicetree/bindings/usb/exynos-usb.txt:		samsung,vbus-gpio = <&gpx2 6 1 3 3>;
Documentation/devicetree/bindings/usb/nvidia,tegra20-usb-phy.txt:  - vbus-supply: regulator for VBUS
Documentation/devicetree/bindings/usb/omap-usb.txt: - vbus-supply : phandle to the regulator device tree node if needed.
Documentation/devicetree/booting-without-of.txt:    - bus-frequency: Contains the bus frequency for the SoC node.
Documentation/devicetree/booting-without-of.txt:		bus-frequency = <0>;
Documentation/devicetree/booting-without-of.txt:		bus-frequency = <0>;
Documentation/driver-model/binding.txt:because there have been bus-specific structures to represent the
Documentation/driver-model/binding.txt:supports. The format and semantics for comparing IDs is bus-specific. 
Documentation/driver-model/bus.txt:them are inherently bus-specific. Drivers typically declare an array
Documentation/driver-model/bus.txt:of device IDs of devices they support that reside in a bus-specific
Documentation/driver-model/bus.txt:particular device, without sacrificing bus-specific functionality or
Documentation/driver-model/bus.txt:lists as they please, but conversion to the bus-specific type may be
Documentation/driver-model/driver.txt:model because the bus they belong to has a bus-specific structure with
Documentation/driver-model/driver.txt:bus-specific fields that cannot be generalized. 
Documentation/driver-model/driver.txt:completely bus-specific. Defining them as bus-specific entities would
Documentation/driver-model/driver.txt:sacrifice type-safety, so we keep bus-specific structures around. 
Documentation/driver-model/driver.txt:the definition of the bus-specific driver. Like this:
Documentation/driver-model/driver.txt:A definition that included bus-specific fields would look like
Documentation/driver-model/driver.txt:no bus-specific fields (i.e. don't have a bus-specific driver
Documentation/driver-model/driver.txt:Most drivers, however, will have a bus-specific structure and will
Documentation/driver-model/driver.txt:define generic callbacks that forward the call to the bus-specific
Documentation/driver-model/driver.txt:container_of() to convert "dev" to a bus-specific type, both in probe()
Documentation/driver-model/overview.txt:bus-specific drivers for bridges and devices by consolidating a set of data
Documentation/driver-model/platform.txt:bus-level support for dynamic configuration (PCI, USB), or device tables
Documentation/driver-model/porting.txt:be embedded in larger, bus-specific objects. Fields in these generic
Documentation/driver-model/porting.txt:objects can replace fields in the bus-specific objects. 
Documentation/driver-model/porting.txt:- Embed a struct device in the bus-specific device type. 
Documentation/driver-model/porting.txt:  the bus. The format of this string is bus-specific. This is
Documentation/driver-model/porting.txt:  device's release method, then free the bus-specific object. 
Documentation/driver-model/porting.txt:- Embed a struct device_driver in the bus-specific driver. 
Documentation/driver-model/porting.txt:forward call to the bus-specific drivers. For instance: 
Documentation/driver-model/porting.txt:bus-specific, so the generic model does attempt to generalize them. 
Documentation/driver-model/porting.txt:over. bus->match() is called for each one until a match is found. 
Documentation/driver-model/porting.txt:over. bus->match() is called for each device that is not already
Documentation/driver-model/porting.txt:fields in the bus-specific representations of these objects. Feel free
Documentation/driver-model/porting.txt:to remove the bus-specific ones and favor the generic ones. Note
Documentation/driver-model/porting.txt:reference the bus-specific fields (though those should all be 1-line
Documentation/fmc/fmc-chardev.txt:bus-specific address but no associated name, or something like
Documentation/hwmon/zl6100:Documentation/hwmon/pmbus and Documentation.hwmon/pmbus-core for details
Documentation/i2c/dev-interface:You can do SMBus level transactions (see documentation file smbus-protocol 
Documentation/i2c/writing-clients:You can read the file `smbus-protocol' for more information about the
Documentation/kernel-docs.txt:       Keywords: PCI, bus, bus-mastering.
Documentation/leds/leds-blinkm.txt:blinkm-<i2c-bus-nr>-<i2c-device-nr>-<color>
Documentation/networking/bonding.txt:_nm_name='bus-pci-0001:61:01.0'
Documentation/networking/bonding.txt:BONDING_SLAVE1="bus-pci-0000:06:08.1"
Documentation/networking/bonding.txt:(bus-pci-0000:06:08.1 in the example above) specify the physical
Documentation/networking/can.txt:  the mapping to the bus-relevant data length code (DLC), see chapter 6.6.
Documentation/networking/can.txt:      re-started bus-errors arbit-lost error-warn error-pass bus-off
Documentation/networking/can.txt:	in case of a bus-off condition after the specified delay time
Documentation/networking/can.txt:    "re-started bus-errors arbit-lost error-warn error-pass bus-off"
Documentation/networking/can.txt:	bus-off state. RX overrun errors are listed in the "overrun"
Documentation/networking/can.txt:  A device may enter the "bus-off" state if too much errors occurred on
Documentation/networking/can.txt:  bus-off recovery can be enabled by setting the "restart-ms" to a
Documentation/networking/can.txt:  Alternatively, the application may realize the "bus-off" condition
Documentation/networking/can.txt:  CAN frames anyway. The payload length to the bus-relevant DLC mapping is
Documentation/networking/vortex.txt:     Enabling bus-master transmits and whole-frame receives.
Documentation/power/devices.txt:	device is on, it may be necessary to carry out some bus-specific
Documentation/power/devices.txt:on top of bus-specific framework code.
Documentation/power/devices.txt:defined in dev->pm_domain->ops, dev->bus->pm, dev->type->pm, dev->class->pm or
Documentation/power/devices.txt:    4.	Otherwise, if both dev->bus and dev->bus->pm are present, the callback
Documentation/power/devices.txt:	included in dev->bus->pm will be chosen for execution.
Documentation/power/devices.txt:will notice and handle such removals are currently bus-specific, and often
Documentation/power/runtime_pm.txt:  4. Bus type of the device, if both dev->bus and dev->bus->pm are present.
Documentation/powerpc/eeh-pci-error-recovery.txt:                  dev->bus->uevent() which is really just a call to
Documentation/powerpc/eeh-pci-error-recovery.txt:   SCSI device resets, SCSI bus resets, and SCSI host-bus-adapter
Documentation/rapidio/sysfs.txt:RapidIO bus subdirectory /sys/bus/rapidio implements the following bus-specific
Documentation/scsi/ChangeLog.1992-1997:	motherboard does not deal with multiple bus-masters very well).
Documentation/scsi/in2000.txt:   chooses), or as a "SCSI-bus-hog". When several devices
Documentation/sound/alsa/HD-Audio.txt:`hda:hda_bus_reset` traces the bus-reset due to fatal error, etc,
Documentation/sound/alsa/hda_codec.txt:	list_for_each_entry(codec, &bus->codec_list, list) {
Documentation/sysfs-rules.txt:  There is no such thing like class-, bus-, physical devices,
Documentation/sysfs-rules.txt:  just simply a "device". Class-, bus-, physical, ... types are just
Documentation/usb/dma.txt:  or using cache hardware with bus-snooping support.  While x86 hardware
Documentation/usb/dma.txt:  has such bus-snooping, many other systems use software to flush cache
Documentation/usb/proc_usb_info.txt:    rather differently.  For example, a bus-powered configuration
Documentation/video4linux/v4l2-framework.txt:from a v4l2_subdev to the actual low-level bus-specific device data.
Documentation/wimax/README.i2400m:   generic driver and the bus-specific drivers. The bus generic driver
Documentation/wimax/README.i2400m:   glue to connect the bus-generic driver and the device. Currently only
Documentation/wimax/README.i2400m:   bus-specific driver. The reason for this breakup is to be able to
Documentation/wimax/README.i2400m:       bus-specific i2400m-usb or i2400m-sdio controls).
Documentation/zorro.txt:regions. Due to the identity bus-physical address mapping on the Zorro bus,
MAINTAINERS:F:	Documentation/ABI/testing/sysfs-bus-acpi
MAINTAINERS:F:	Documentation/ABI/testing/sysfs-bus-hsi
arch/alpha/include/asm/pci.h:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/core_apecs.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_irongate.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_lca.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_marvel.c:	struct pci_controller *hose = pbus->sysdata;
arch/alpha/kernel/core_marvel.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_marvel.c:	if (!pbus->parent) { /* No parent means peer PCI bus. */
arch/alpha/kernel/core_mcpcia.c: * Code common to all MCbus-PCI Adaptor core logic chipsets
arch/alpha/kernel/core_mcpcia.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_mcpcia.c:	if (!pbus->parent) /* No parent means peer PCI bus. */
arch/alpha/kernel/core_mcpcia.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/core_mcpcia.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/core_polaris.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_t2.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_titan.c:	struct pci_controller *hose = pbus->sysdata;
arch/alpha/kernel/core_titan.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_titan.c:	if (!pbus->parent) /* No parent means peer PCI bus. */
arch/alpha/kernel/core_tsunami.c:	struct pci_controller *hose = pbus->sysdata;
arch/alpha/kernel/core_tsunami.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_tsunami.c:	if (!pbus->parent) /* No parent means peer PCI bus. */
arch/alpha/kernel/core_wildfire.c:	struct pci_controller *hose = pbus->sysdata;
arch/alpha/kernel/core_wildfire.c:	u8 bus = pbus->number;
arch/alpha/kernel/core_wildfire.c:	if (!pbus->parent) /* No parent means peer PCI bus. */
arch/alpha/kernel/pci-noop.c:		return hose->bus->number;
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/pci-sysfs.c:	res_size = (mmap_type == pci_mmap_mem) ? bus->legacy_mem->size :
arch/alpha/kernel/pci-sysfs.c:						 bus->legacy_io->size;
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/pci-sysfs.c:		bus->legacy_mem->attr.name = "legacy_mem_sparse";
arch/alpha/kernel/pci-sysfs.c:		bus->legacy_mem->size <<= 5;
arch/alpha/kernel/pci-sysfs.c:		bus->legacy_io->attr.name = "legacy_io_sparse";
arch/alpha/kernel/pci-sysfs.c:		bus->legacy_io->size <<= 5;
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = bus->sysdata;
arch/alpha/kernel/pci.c:	struct pci_dev *dev = bus->self;
arch/alpha/kernel/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/alpha/kernel/pci.c:		next_busno = bus->busn_res.end + 1;
arch/alpha/kernel/pci.c:		return hose->bus->number;
arch/alpha/kernel/sys_dp264.c:	if (!dev->bus->parent) {
arch/alpha/kernel/sys_dp264.c:	else if (hose->index == 1 && PCI_SLOT(dev->bus->self->devfn) == 8) {
arch/alpha/kernel/sys_dp264.c:			    PCI_SLOT(dev->bus->self->devfn) == 8) {
arch/alpha/kernel/sys_dp264.c:			dev = dev->bus->self;
arch/alpha/kernel/sys_dp264.c:		} while (dev->bus->self);
arch/alpha/kernel/sys_eiger.c:	while (dev->bus->self) {
arch/alpha/kernel/sys_eiger.c:		    && (PCI_SLOT(dev->bus->self->devfn)
arch/alpha/kernel/sys_eiger.c:		dev = dev->bus->self;
arch/alpha/kernel/sys_marvel.c:		       dev->bus->number, 
arch/alpha/kernel/sys_miata.c:	if (dev->bus->number == 0) {
arch/alpha/kernel/sys_miata.c:	else if ((PCI_SLOT(dev->bus->self->devfn) == 8) ||
arch/alpha/kernel/sys_miata.c:		 (PCI_SLOT(dev->bus->self->devfn) == 20)) {
arch/alpha/kernel/sys_miata.c:			if ((PCI_SLOT(dev->bus->self->devfn) == 8) ||
arch/alpha/kernel/sys_miata.c:			    (PCI_SLOT(dev->bus->self->devfn) == 20)) {
arch/alpha/kernel/sys_miata.c:			dev = dev->bus->self;
arch/alpha/kernel/sys_miata.c:		} while (dev->bus->self);
arch/alpha/kernel/sys_nautilus.c:	    dev->bus->self && dev->bus->self->device == 0x700f)
arch/alpha/kernel/sys_nautilus.c:	bus->self = irongate;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[0] = &irongate_io;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[1] = &irongate_mem;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[0]->start = 0;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[0]->end = 0xffff;
arch/alpha/kernel/sys_nautilus.c:	bus_align = bus->resource[1]->start;
arch/alpha/kernel/sys_nautilus.c:	bus_size = bus->resource[1]->end + 1 - bus_align;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[1]->start = pci_mem;
arch/alpha/kernel/sys_nautilus.c:	bus->resource[1]->end = 0xffffffffUL;
arch/alpha/kernel/sys_nautilus.c:	if (request_resource(&iomem_resource, bus->resource[1]) < 0)
arch/alpha/kernel/sys_nautilus.c:	/* pci_common_swizzle() relies on bus->self being NULL
arch/alpha/kernel/sys_nautilus.c:	bus->self = NULL;
arch/alpha/kernel/sys_noritake.c:	if (dev->bus->number == 0) {
arch/alpha/kernel/sys_noritake.c:	else if (PCI_SLOT(dev->bus->self->devfn) == 8) {
arch/alpha/kernel/sys_noritake.c:			if (PCI_SLOT(dev->bus->self->devfn) == 8) {
arch/alpha/kernel/sys_noritake.c:			dev = dev->bus->self;
arch/alpha/kernel/sys_noritake.c:		} while (dev->bus->self);
arch/alpha/kernel/sys_ruffian.c:	if (dev->bus->number == 0) {
arch/alpha/kernel/sys_ruffian.c:	else if (PCI_SLOT(dev->bus->self->devfn) == 13) {
arch/alpha/kernel/sys_ruffian.c:			if (PCI_SLOT(dev->bus->self->devfn) == 13) {
arch/alpha/kernel/sys_ruffian.c:			dev = dev->bus->self;
arch/alpha/kernel/sys_ruffian.c:		} while (dev->bus->self);
arch/alpha/kernel/sys_sable.c:	if (dev->bus->number == 0) {
arch/alpha/kernel/sys_sable.c:	else if (PCI_SLOT(dev->bus->self->devfn) == 3) {
arch/alpha/kernel/sys_sable.c:			if (PCI_SLOT(dev->bus->self->devfn) == 3) {
arch/alpha/kernel/sys_sable.c:			dev = dev->bus->self;
arch/alpha/kernel/sys_sable.c:		} while (dev->bus->self);
arch/alpha/kernel/sys_takara.c:		unsigned int busslot = PCI_SLOT(dev->bus->self->devfn);
arch/alpha/kernel/sys_takara.c:	if (!dev->bus->self)
arch/alpha/kernel/sys_takara.c:	busslot = PCI_SLOT(dev->bus->self->devfn);
arch/alpha/kernel/sys_takara.c:	if (dev->bus->number != 0
arch/arc/boot/dts/abilis_tb100.dtsi:		bus-frequency	= <166666666>;
arch/arc/boot/dts/abilis_tb101.dtsi:		bus-frequency	= <166666666>;
arch/arm/boot/dts/aks-cdu.dts:				atmel,vbus-gpio = <&pioC 15 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/aks-cdu.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/am335x-bone-common.dtsi:	bus-width = <0x4>;
arch/arm/boot/dts/am335x-boneblack.dts:	bus-width = <8>;
arch/arm/boot/dts/am335x-evm.dts:		nand-bus-width = <8>;
arch/arm/boot/dts/am335x-evm.dts:		gpmc,bus-turnaround-ns = <0>;
arch/arm/boot/dts/am335x-evm.dts:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/am335x-evm.dts:	bus-width = <4>;
arch/arm/boot/dts/am335x-evmsk.dts:	bus-width = <4>;
arch/arm/boot/dts/am335x-igep0033.dtsi:		nand-bus-width = <8>;
arch/arm/boot/dts/am335x-igep0033.dtsi:		gpmc,bus-turnaround-ns = <0>;
arch/arm/boot/dts/am335x-igep0033.dtsi:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/am335x-igep0033.dtsi:	bus-width = <4>;
arch/arm/boot/dts/am335x-nano.dts:		gpmc,wr-data-mux-bus-ns = <70>;
arch/arm/boot/dts/am335x-nano.dts:	bus-width = <4>;
arch/arm/boot/dts/am43x-epos-evm.dts:	bus-width = <4>;
arch/arm/boot/dts/animeo_ip.dts:					bus-width = <4>;
arch/arm/boot/dts/animeo_ip.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/animeo_ip.dts:			atmel,vbus-gpio = <&pioB 15 GPIO_ACTIVE_LOW>;
arch/arm/boot/dts/armada-370-xp.dtsi:		devbus-bootcs {
arch/arm/boot/dts/armada-370-xp.dtsi:		devbus-cs0 {
arch/arm/boot/dts/armada-370-xp.dtsi:		devbus-cs1 {
arch/arm/boot/dts/armada-370-xp.dtsi:		devbus-cs2 {
arch/arm/boot/dts/armada-370-xp.dtsi:		devbus-cs3 {
arch/arm/boot/dts/armada-370-xp.dtsi:			mbusc: mbus-controller@20000 {
arch/arm/boot/dts/armada-370-xp.dtsi:				compatible = "marvell,mbus-controller";
arch/arm/boot/dts/armada-370-xp.dtsi:				bus-width = <4>;
arch/arm/boot/dts/armada-370.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/armada-xp-db.dts:		devbus-bootcs {
arch/arm/boot/dts/armada-xp-db.dts:			devbus,bus-width    = <8>;
arch/arm/boot/dts/armada-xp-gp.dts:		devbus-bootcs {
arch/arm/boot/dts/armada-xp-gp.dts:			devbus,bus-width    = <8>;
arch/arm/boot/dts/armada-xp-mv78230.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/armada-xp-mv78260.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/armada-xp-mv78460.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts:		devbus-bootcs {
arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts:			devbus,bus-width    = <8>;
arch/arm/boot/dts/at91-ariag25.dts:					bus-width = <4>;
arch/arm/boot/dts/at91-foxg20.dts:				atmel,vbus-gpio = <&pioC 6 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91-foxg20.dts:					bus-width = <4>;
arch/arm/boot/dts/at91rm9200ek.dts:				atmel,vbus-gpio = <&pioD 4 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91sam9263ek.dts:				atmel,vbus-gpio = <&pioA 25 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91sam9263ek.dts:					bus-width = <4>;
arch/arm/boot/dts/at91sam9263ek.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/at91sam9263ek.dts:			atmel,vbus-gpio = <&pioA 24 GPIO_ACTIVE_HIGH
arch/arm/boot/dts/at91sam9g20ek_2mmc.dts:					bus-width = <4>;
arch/arm/boot/dts/at91sam9g20ek_common.dtsi:				atmel,vbus-gpio = <&pioC 5 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91sam9g20ek_common.dtsi:					bus-width = <4>;
arch/arm/boot/dts/at91sam9g20ek_common.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/at91sam9m10g45ek.dts:					bus-width = <4>;
arch/arm/boot/dts/at91sam9m10g45ek.dts:					bus-width = <4>;
arch/arm/boot/dts/at91sam9m10g45ek.dts:				atmel,vbus-gpio = <&pioB 19 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91sam9m10g45ek.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/at91sam9m10g45ek.dts:			atmel,vbus-gpio = <&pioD 1 GPIO_ACTIVE_LOW
arch/arm/boot/dts/at91sam9n12ek.dts:					bus-width = <4>;
arch/arm/boot/dts/at91sam9n12ek.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/at91sam9x5cm.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/at91sam9x5ek.dtsi:					bus-width = <4>;
arch/arm/boot/dts/at91sam9x5ek.dtsi:					bus-width = <4>;
arch/arm/boot/dts/at91sam9x5ek.dtsi:				atmel,vbus-gpio = <&pioB 16 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/at91sam9x5ek.dtsi:			atmel,vbus-gpio = <0 /* &pioD 18 GPIO_ACTIVE_LOW *//* Activate to have access to port A */
arch/arm/boot/dts/atlas6.dtsi:			bus-frequency = <0>;
arch/arm/boot/dts/atlas6.dtsi:					bus-width = <8>;
arch/arm/boot/dts/bcm2835-rpi-b.dts:	bus-width = <4>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <378000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <378000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/cros5250-common.dtsi:		samsung,i2c-max-bus-freq = <378000>;
arch/arm/boot/dts/cros5250-common.dtsi:			bus-width = <8>;
arch/arm/boot/dts/cros5250-common.dtsi:			bus-width = <4>;
arch/arm/boot/dts/cros5250-common.dtsi:			bus-width = <4>;
arch/arm/boot/dts/da850-evm.dts:			bus-width = <4>;
arch/arm/boot/dts/dove-d2plug.dts:	bus-width = <4>;
arch/arm/boot/dts/dove-d2plug.dts:	bus-width = <4>;
arch/arm/boot/dts/dove-d3plug.dts:	bus-width = <4>;
arch/arm/boot/dts/dove.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/dove.dtsi:			mbusc: mbus-ctrl@20000 {
arch/arm/boot/dts/dove.dtsi:				compatible = "marvell,mbus-controller";
arch/arm/boot/dts/dra7-evm.dts:	bus-width = <4>;
arch/arm/boot/dts/dra7-evm.dts:	bus-width = <8>;
arch/arm/boot/dts/ea3250.dts:				bus-width = <4>;
arch/arm/boot/dts/ecx-common.dtsi:					compatible = "calxeda,hb-a9bus-clock";
arch/arm/boot/dts/ethernut5.dts:				atmel,vbus-gpio = <&pioC 5 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/ethernut5.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/evk-pro3.dts:				atmel,vbus-gpio = <&pioC 5 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/exynos4.dtsi:			bus-width = <4>;
arch/arm/boot/dts/exynos4.dtsi:			bus-width = <2>;
arch/arm/boot/dts/exynos4210-origen.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4210-origen.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4210-origen.dts:		samsung,i2c-max-bus-freq = <20000>;
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd0_bus8: sd0-bus-width8 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd4_bus1: sd4-bus-width1 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd4_bus4: sd4-bus-width4 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd4_bus8: sd4-bus-width8 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd2_bus1: sd2-bus-width1 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd2_bus4: sd2-bus-width4 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd2_bus8: sd2-bus-width8 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd3_bus1: sd3-bus-width1 {
arch/arm/boot/dts/exynos4210-pinctrl.dtsi:		sd3_bus4: sd3-bus-width4 {
arch/arm/boot/dts/exynos4210-smdkv310.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4210-smdkv310.dts:		samsung,i2c-max-bus-freq = <100000>;
arch/arm/boot/dts/exynos4210-trats.dts:		bus-width = <8>;
arch/arm/boot/dts/exynos4210-trats.dts:		samsung,i2c-max-bus-freq = <400000>;
arch/arm/boot/dts/exynos4210-trats.dts:		samsung,i2c-max-bus-freq = <100000>;
arch/arm/boot/dts/exynos4210-universal_c210.dts:		bus-width = <8>;
arch/arm/boot/dts/exynos4210-universal_c210.dts:		samsung,i2c-max-bus-freq = <100000>;
arch/arm/boot/dts/exynos4210-universal_c210.dts:		samsung,i2c-max-bus-freq = <100000>;
arch/arm/boot/dts/exynos4412-odroidx.dts:			bus-width = <8>;
arch/arm/boot/dts/exynos4412-odroidx.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4412-origen.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4412-origen.dts:			bus-width = <8>;
arch/arm/boot/dts/exynos4412-origen.dts:		samsung,i2c-max-bus-freq = <20000>;
arch/arm/boot/dts/exynos4412-smdk4412.dts:		bus-width = <4>;
arch/arm/boot/dts/exynos4412-trats2.dts:		samsung,i2c-max-bus-freq = <400000>;
arch/arm/boot/dts/exynos4412-trats2.dts:		samsung,i2c-max-bus-freq = <100000>;
arch/arm/boot/dts/exynos4412-trats2.dts:		bus-width = <8>;
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd0_bus8: sd0-bus-width8 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd4_bus1: sd4-bus-width1 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd4_bus4: sd4-bus-width4 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd4_bus8: sd4-bus-width8 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd2_bus1: sd2-bus-width1 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd2_bus4: sd2-bus-width4 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd2_bus8: sd2-bus-width8 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd3_bus1: sd3-bus-width1 {
arch/arm/boot/dts/exynos4x12-pinctrl.dtsi:		sd3_bus4: sd3-bus-width4 {
arch/arm/boot/dts/exynos5250-arndale.dts:		samsung,i2c-max-bus-freq = <20000>;
arch/arm/boot/dts/exynos5250-arndale.dts:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/exynos5250-arndale.dts:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/exynos5250-arndale.dts:			bus-width = <8>;
arch/arm/boot/dts/exynos5250-arndale.dts:			bus-width = <4>;
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd0_bus8: sd0-bus-width8 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd2_bus1: sd2-bus-width1 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd2_bus4: sd2-bus-width4 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd2_bus8: sd2-bus-width8 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd3_bus1: sd3-bus-width1 {
arch/arm/boot/dts/exynos5250-pinctrl.dtsi:		sd3_bus4: sd3-bus-width4 {
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,i2c-max-bus-freq = <20000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,i2c-max-bus-freq = <20000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,i2c-max-bus-freq = <40000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:			bus-width = <8>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:			bus-width = <4>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		samsung,vbus-gpio = <&gpx2 6 0>;
arch/arm/boot/dts/exynos5250-snow.dts:		sd3_bus4: sd3-bus-width4 {
arch/arm/boot/dts/exynos5250-snow.dts:		samsung,vbus-gpio = <&gpx1 1 0>;
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd0_bus8: sd0-bus-width8 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd1_bus8: sd1-bus-width8 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd2_bus1: sd2-bus-width1 {
arch/arm/boot/dts/exynos5420-pinctrl.dtsi:		sd2_bus4: sd2-bus-width4 {
arch/arm/boot/dts/exynos5420-smdk5420.dts:		samsung,i2c-max-bus-freq = <66000>;
arch/arm/boot/dts/ge863-pro3.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/imx23-evk.dts:				bus-width = <4>;
arch/arm/boot/dts/imx23-evk.dts:					bus-width = <24>;
arch/arm/boot/dts/imx23-olinuxino.dts:				bus-width = <4>;
arch/arm/boot/dts/imx23-olinuxino.dts:			vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx23-stmp378x_devb.dts:				bus-width = <4>;
arch/arm/boot/dts/imx27-apf27.dts:	nand-bus-width = <16>;
arch/arm/boot/dts/imx27-phytec-phycore-rdk.dts:	bus-width = <4>;
arch/arm/boot/dts/imx27-phytec-phycore-som.dts:	nand-bus-width = <8>;
arch/arm/boot/dts/imx28-apf28dev.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-apf28dev.dts:					bus-width = <16>;
arch/arm/boot/dts/imx28-apf28dev.dts:			vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx28-apx4devkit.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-apx4devkit.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-apx4devkit.dts:					bus-width = <24>;
arch/arm/boot/dts/imx28-cfa10036.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-cfa10037.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-cfa10049.dts:					bus-width = <18>;
arch/arm/boot/dts/imx28-cfa10049.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-cfa10055.dts:					bus-width = <18>;
arch/arm/boot/dts/imx28-cfa10056.dts:					bus-width = <24>;
arch/arm/boot/dts/imx28-cfa10057.dts:					bus-width = <18>;
arch/arm/boot/dts/imx28-cfa10057.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-cfa10058.dts:					bus-width = <24>;
arch/arm/boot/dts/imx28-cfa10058.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-evk.dts:				bus-width = <8>;
arch/arm/boot/dts/imx28-evk.dts:				bus-width = <8>;
arch/arm/boot/dts/imx28-evk.dts:					bus-width = <24>;
arch/arm/boot/dts/imx28-evk.dts:			vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx28-evk.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-m28cu3.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-m28cu3.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-m28cu3.dts:					bus-width = <24>;
arch/arm/boot/dts/imx28-m28cu3.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-m28evk.dts:				bus-width = <8>;
arch/arm/boot/dts/imx28-m28evk.dts:					bus-width = <18>;
arch/arm/boot/dts/imx28-m28evk.dts:			vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx28-m28evk.dts:			vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx28-sps1.dts:				bus-width = <4>;
arch/arm/boot/dts/imx28-sps1.dts:			vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx28-tx28.dts:		bus-width = <24>;
arch/arm/boot/dts/imx28-tx28.dts:	bus-width = <4>;
arch/arm/boot/dts/imx28-tx28.dts:	vbus-supply = <&reg_usb0_vbus>;
arch/arm/boot/dts/imx28-tx28.dts:	vbus-supply = <&reg_usb1_vbus>;
arch/arm/boot/dts/imx51-apf51.dts:	nand-bus-width = <8>;
arch/arm/boot/dts/imx51-apf51dev.dts:	bus-width = <4>;
arch/arm/boot/dts/imx51-apf51dev.dts:	bus-width = <4>;
arch/arm/boot/dts/imx51.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx51.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx51.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx53-m53evk.dts:	nand-bus-width = <8>;
arch/arm/boot/dts/imx53-qsb.dts:	bus-width = <8>;
arch/arm/boot/dts/imx53-qsb.dts:	vbus-supply = <&reg_usb_vbus>;
arch/arm/boot/dts/imx53-tqma53.dtsi:	bus-width = <8>;
arch/arm/boot/dts/imx53.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx53.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx53.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx53.dtsi:					bus-width = <4>;
arch/arm/boot/dts/imx6q-sabrelite.dts:	vbus-supply = <&reg_usb_otg_vbus>;
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:	vbus-supply = <&reg_usb_h1_vbus>;
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:	vbus-supply = <&reg_usb_otg_vbus>;
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:	bus-width = <8>;
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:	bus-width = <8>;
arch/arm/boot/dts/imx6qdl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6qdl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6qdl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6qdl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6sl-evk.dts:	vbus-supply = <&reg_usb_otg1_vbus>;
arch/arm/boot/dts/imx6sl-evk.dts:	vbus-supply = <&reg_usb_otg2_vbus>;
arch/arm/boot/dts/imx6sl-evk.dts:	bus-width = <8>;
arch/arm/boot/dts/imx6sl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6sl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6sl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/imx6sl.dtsi:				bus-width = <4>;
arch/arm/boot/dts/kirkwood-6281.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/kirkwood-6281.dtsi:			bus-width = <4>;
arch/arm/boot/dts/kirkwood-6282.dtsi:			bus-range = <0x00 0xff>;
arch/arm/boot/dts/kirkwood-6282.dtsi:			bus-width = <4>;
arch/arm/boot/dts/kirkwood.dtsi:		mbusc: mbus-controller@20000 {
arch/arm/boot/dts/kirkwood.dtsi:			compatible = "marvell,mbus-controller";
arch/arm/boot/dts/kizbox.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/marco-evb.dts:					bus-width = <8>;
arch/arm/boot/dts/omap-gpmc-smsc911x.dtsi:		gpmc,bus-turnaround-ns = <12>;
arch/arm/boot/dts/omap-gpmc-smsc911x.dtsi:		gpmc,wr-data-mux-bus-ns = <90>;
arch/arm/boot/dts/omap3-beagle-xm.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3-beagle.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3-devkit8000.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3-devkit8000.dts:		nand-bus-width = <16>;
arch/arm/boot/dts/omap3-devkit8000.dts:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/omap3-evm-37xx.dts:		nand-bus-width = <16>;
arch/arm/boot/dts/omap3-evm-37xx.dts:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/omap3-evm-common.dtsi:	bus-width = <8>;
arch/arm/boot/dts/omap3-evm-common.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap3-gta04.dts:	bus-width = <4>;
arch/arm/boot/dts/omap3-igep.dtsi:      bus-width = <4>;
arch/arm/boot/dts/omap3-igep.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap3-igep0020.dts:		nand-bus-width = <16>;
arch/arm/boot/dts/omap3-igep0020.dts:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/omap3-igep0030.dts:		nand-bus-width = <16>;
arch/arm/boot/dts/omap3-igep0030.dts:		gpmc,wr-data-mux-bus-ns = <0>;
arch/arm/boot/dts/omap3-n900.dts:	bus-width = <4>;
arch/arm/boot/dts/omap3-n900.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3-n900.dts:		gpmc,bus-turnaround-ns = <0>;
arch/arm/boot/dts/omap3-n900.dts:		gpmc,wr-data-mux-bus-ns = <30>;
arch/arm/boot/dts/omap3-n950-n9.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap3-n950-n9.dtsi:		gpmc,bus-turnaround-ns = <0>;
arch/arm/boot/dts/omap3-n950-n9.dtsi:		gpmc,wr-data-mux-bus-ns = <30>;
arch/arm/boot/dts/omap3-overo.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap3-overo.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap3-tobi.dts:		gpmc,bus-turnaround-ns = <0>;
arch/arm/boot/dts/omap3-tobi.dts:		gpmc,wr-data-mux-bus-ns = <18>;
arch/arm/boot/dts/omap3-zoom3.dts:	bus-width = <4>;
arch/arm/boot/dts/omap3-zoom3.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3-zoom3.dts:	bus-width = <4>;
arch/arm/boot/dts/omap3430-sdp.dts:	bus-width = <8>;
arch/arm/boot/dts/omap3430-sdp.dts:		gpmc,bus-turnaround-ns = <12>;
arch/arm/boot/dts/omap3430-sdp.dts:		gpmc,wr-data-mux-bus-ns = <90>;
arch/arm/boot/dts/omap3430-sdp.dts:		nand-bus-width = <8>;
arch/arm/boot/dts/omap3430-sdp.dts:		gpmc,wr-data-mux-bus-ns = <30>;
arch/arm/boot/dts/omap4-panda-common.dtsi:	bus-width = <8>;
arch/arm/boot/dts/omap4-panda-common.dtsi:	bus-width = <4>;
arch/arm/boot/dts/omap4-sdp.dts:	bus-width = <8>;
arch/arm/boot/dts/omap4-sdp.dts:	bus-width = <8>;
arch/arm/boot/dts/omap4-sdp.dts:	bus-width = <4>;
arch/arm/boot/dts/omap4-var-som.dts:	ti,bus-width = <8>;
arch/arm/boot/dts/omap4-var-som.dts:	ti,bus-width = <4>;
arch/arm/boot/dts/omap5-uevm.dts:	bus-width = <4>;
arch/arm/boot/dts/omap5-uevm.dts:	bus-width = <8>;
arch/arm/boot/dts/omap5-uevm.dts:	bus-width = <4>;
arch/arm/boot/dts/omap5-uevm.dts:			ti,enable-vbus-detection;
arch/arm/boot/dts/omap5-uevm.dts:	vbus-supply = <&smps10_out1_reg>;
arch/arm/boot/dts/phy3250.dts:				bus-width = <4>;
arch/arm/boot/dts/picoxcell-pc3x2.dtsi:				bus-clock = <&pclk>, "bus";
arch/arm/boot/dts/picoxcell-pc3x3.dtsi:				bus-clock = <&pclk>, "bus";
arch/arm/boot/dts/picoxcell-pc7302-pc3x2.dts:				bus-clock = <&pclk>, "bus";
arch/arm/boot/dts/picoxcell-pc7302-pc3x3.dts:				bus-clock = <&ebi_clk>, "bus";
arch/arm/boot/dts/pm9g45.dts:					bus-width = <4>;
arch/arm/boot/dts/pm9g45.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/prima2.dtsi:			bus-frequency = <0>;
arch/arm/boot/dts/r8a73a4-ape6evm-reference.dts:	bus-width = <8>;
arch/arm/boot/dts/r8a73a4-ape6evm-reference.dts:	bus-width = <4>;
arch/arm/boot/dts/r8a73a4-ape6evm-reference.dts:	bus-width = <4>;
arch/arm/boot/dts/r8a7740-armadillo800eva-reference.dts:	bus-width = <8>;
arch/arm/boot/dts/r8a7740-armadillo800eva-reference.dts:	bus-width = <4>;
arch/arm/boot/dts/rk3066a-bqcurie2.dts:				bus-width = <4>;
arch/arm/boot/dts/rk3066a-bqcurie2.dts:				bus-width = <4>;
arch/arm/boot/dts/rk3066a.dtsi:				sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/rk3066a.dtsi:				sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/rk3066a.dtsi:				sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/rk3066a.dtsi:				sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/rk3188.dtsi:				sd0_bus1: sd0-bus-width1 {
arch/arm/boot/dts/rk3188.dtsi:				sd0_bus4: sd0-bus-width4 {
arch/arm/boot/dts/rk3188.dtsi:				sd1_bus1: sd1-bus-width1 {
arch/arm/boot/dts/rk3188.dtsi:				sd1_bus4: sd1-bus-width4 {
arch/arm/boot/dts/s3c2416-smdk2416.dts:		bus-width = <4>;
arch/arm/boot/dts/s3c2416-smdk2416.dts:		bus-width = <4>;
arch/arm/boot/dts/s3c6410-mini6410.dts:	bus-width = <4>;
arch/arm/boot/dts/s3c6410-smdk6410.dts:	bus-width = <4>;
arch/arm/boot/dts/s3c64xx-pinctrl.dtsi:	ac97_bus_0: ac97-bus-0 {
arch/arm/boot/dts/s3c64xx-pinctrl.dtsi:	ac97_bus_1: ac97-bus-1 {
arch/arm/boot/dts/sama5d3xcm.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/sama5d3xmb.dtsi:					bus-width = <4>;
arch/arm/boot/dts/sama5d3xmb.dtsi:					bus-width = <4>;
arch/arm/boot/dts/sama5d3xmb.dtsi:			atmel,vbus-gpio = <&pioD 29 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/sama5d3xmb.dtsi:			atmel,vbus-gpio = <&pioD 25 GPIO_ACTIVE_HIGH
arch/arm/boot/dts/sh73a0-kzm9g-reference.dts:	bus-width = <8>;
arch/arm/boot/dts/sh73a0-kzm9g-reference.dts:	bus-width = <4>;
arch/arm/boot/dts/sh73a0-kzm9g-reference.dts:	bus-width = <4>;
arch/arm/boot/dts/ste-ccu9540.dts:			bus-width = <4>;
arch/arm/boot/dts/ste-ccu9540.dts:			bus-width = <4>;
arch/arm/boot/dts/ste-ccu9540.dts:			bus-width = <8>;
arch/arm/boot/dts/ste-href.dtsi:			bus-width = <4>;
arch/arm/boot/dts/ste-href.dtsi:			bus-width = <4>;
arch/arm/boot/dts/ste-href.dtsi:			bus-width = <8>;
arch/arm/boot/dts/ste-href.dtsi:			bus-width = <8>;
arch/arm/boot/dts/ste-hrefv60plus.dtsi:			bus-width = <4>;
arch/arm/boot/dts/ste-hrefv60plus.dtsi:			bus-width = <4>;
arch/arm/boot/dts/ste-hrefv60plus.dtsi:			bus-width = <8>;
arch/arm/boot/dts/ste-hrefv60plus.dtsi:			bus-width = <8>;
arch/arm/boot/dts/ste-nomadik-stn8815.dtsi:			bus-width = <4>;
arch/arm/boot/dts/ste-snowball.dts:			bus-width = <4>;
arch/arm/boot/dts/ste-snowball.dts:			bus-width = <8>;
arch/arm/boot/dts/ste-u300.dts:			bus-width = <4>; // SD-card slot
arch/arm/boot/dts/tegra114-dalmore.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra114-dalmore.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra114-dalmore.dts:		vbus-supply = <&usb3_vbus_reg>;
arch/arm/boot/dts/tegra20-harmony.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-harmony.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20-iris-512.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-paz00.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-paz00.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20-seaboard.dts:		vbus-supply = <&vbus_reg>;
arch/arm/boot/dts/tegra20-seaboard.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-seaboard.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-seaboard.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20-tamonten.dtsi:		bus-width = <4>;
arch/arm/boot/dts/tegra20-trimslice.dts:		vbus-supply = <&vbus_reg>;
arch/arm/boot/dts/tegra20-trimslice.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-trimslice.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-ventana.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-ventana.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra20-ventana.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20-whistler.dts:		vbus-supply = <&vbus1_reg>;
arch/arm/boot/dts/tegra20-whistler.dts:		vbus-supply = <&vbus3_reg>;
arch/arm/boot/dts/tegra20-whistler.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20-whistler.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra20.dtsi:		bus-range = <0x00 0xff>;
arch/arm/boot/dts/tegra30-beaver.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra30-beaver.dts:		bus-width = <8>;
arch/arm/boot/dts/tegra30-beaver.dts:		vbus-supply = <&usb3_vbus_reg>;
arch/arm/boot/dts/tegra30-cardhu-a02.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra30-cardhu-a04.dts:		bus-width = <4>;
arch/arm/boot/dts/tegra30-cardhu.dtsi:		bus-width = <4>;
arch/arm/boot/dts/tegra30-cardhu.dtsi:		bus-width = <8>;
arch/arm/boot/dts/tegra30-cardhu.dtsi:		vbus-supply = <&usb3_vbus_reg>;
arch/arm/boot/dts/tegra30.dtsi:		bus-range = <0x00 0xff>;
arch/arm/boot/dts/tny_a9260_common.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/tny_a9263.dts:				atmel,vbus-gpio = <&pioB 11 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/tny_a9263.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/usb_a9260_common.dtsi:				atmel,vbus-gpio = <&pioC 5 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/usb_a9260_common.dtsi:			nand-bus-width = <8>;
arch/arm/boot/dts/usb_a9263.dts:				atmel,vbus-gpio = <&pioB 11 GPIO_ACTIVE_HIGH>;
arch/arm/boot/dts/usb_a9263.dts:			nand-bus-width = <8>;
arch/arm/boot/dts/vf610-twr.dts:	bus-num = <0>;
arch/arm/boot/dts/wm8505.dtsi:			bus-width = <4>;
arch/arm/boot/dts/wm8750.dtsi:			bus-width = <4>;
arch/arm/boot/dts/wm8850.dtsi:			bus-width = <4>;
arch/arm/common/it8152.c:	if (bus->number == 0) {
arch/arm/common/it8152.c:		addr = (bus->number << 16) | (devfn << 8);
arch/arm/include/asm/dma-mapping.h: * @handle: bus-specific DMA address
arch/arm/include/asm/mach/pci.h:	u64		mem_offset;	/* bus->cpu memory mapping offset	*/
arch/arm/include/asm/mach/pci.h:	unsigned long	io_offset;	/* bus->cpu IO mapping offset		*/
arch/arm/include/asm/pci.h:	struct pci_sys_data *root = bus->sysdata;
arch/arm/kernel/bios32.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/arm/kernel/bios32.c:		if (dev->bus->number == 0 && dev->devfn == 0)
arch/arm/kernel/bios32.c:	list_for_each_entry(dev, &bus->devices, bus_list)
arch/arm/kernel/bios32.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/arm/kernel/bios32.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/arm/kernel/bios32.c:	if (bus->self && bus->self->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
arch/arm/kernel/bios32.c:			bus->bridge_ctl |= PCI_BRIDGE_CTL_FAST_BACK;
arch/arm/kernel/bios32.c:			bus->bridge_ctl |= PCI_BRIDGE_CTL_PARITY;
arch/arm/kernel/bios32.c:		bus->number, (features & PCI_COMMAND_FAST_BACK) ? "en" : "dis");
arch/arm/kernel/bios32.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/kernel/bios32.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/kernel/bios32.c:			busnr = sys->bus->busn_res.end + 1;
arch/arm/mach-at91/board-sam9260ek.c:	/* setup bus-width (8 or 16) */
arch/arm/mach-at91/board-sam9261ek.c:	/* setup bus-width (8 or 16) */
arch/arm/mach-at91/board-sam9263ek.c:	/* setup bus-width (8 or 16) */
arch/arm/mach-at91/board-sam9g20ek.c:	/* setup bus-width (8 or 16) */
arch/arm/mach-at91/board-sam9m10g45ek.c:	/* setup bus-width (8 or 16) */
arch/arm/mach-cns3xxx/pcie.c:	return sysdata_to_cnspci(bus->sysdata);
arch/arm/mach-cns3xxx/pcie.c:	int busno = bus->number;
arch/arm/mach-cns3xxx/pcie.c:	if (bus->number == 0 && devfn == 0 &&
arch/arm/mach-cns3xxx/pcie.c:		pci_domain_nr(dev->bus), dev->bus->number, PCI_SLOT(dev->devfn),
arch/arm/mach-dove/include/mach/bridge-regs.h: * Mbus-L to Mbus Bridge Registers
arch/arm/mach-dove/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-dove/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
arch/arm/mach-dove/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-dove/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
arch/arm/mach-dove/pcie.c:	if (dev->bus->parent == NULL && dev->devfn == 0) {
arch/arm/mach-footbridge/cats-pci.c:		       dev->bus->number, dev->devfn, dev->irq);
arch/arm/mach-footbridge/dc21285.c:	if (bus->number == 0) {
arch/arm/mach-footbridge/dc21285.c:		addr = PCICFG1_BASE | (bus->number << 16) | (devfn << 8);
arch/arm/mach-imx/mach-mx31_3ds.c:	{ MX31_3DS_GPIO_SDHC1_BE, GPIOF_OUT_INIT_LOW, "sdhc1-bus-en" },
arch/arm/mach-integrator/pci_v3.c:	busnr = bus->number;
arch/arm/mach-iop13xx/include/mach/memory.h:	(dev && strncmp(dev->bus->name, "platform", 8) == 0)
arch/arm/mach-iop13xx/pci.c:			list_for_each_entry(dev, &bus->devices, bus_list) {
arch/arm/mach-iop13xx/pci.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-iop13xx/pci.c:	if (sys->busnr == bus->number)
arch/arm/mach-iop13xx/pci.c:		addr = bus->number << 16 | PCI_SLOT(devfn) << 11 | 1;
arch/arm/mach-iop13xx/pci.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-iop13xx/pci.c:		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));
arch/arm/mach-iop13xx/pci.c:	addr = ((u32) bus->number)     << IOP13XX_ATUE_OCCAR_BUS_NUM |
arch/arm/mach-iop13xx/pci.c:	if (sys->busnr != bus->number)
arch/arm/mach-iop32x/iq31244.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-iop32x/iq31244.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-iop32x/iq80321.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-iop32x/n2100.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-iop32x/n2100.c:	if (dev->bus->number == 0 &&
arch/arm/mach-iop33x/iq80331.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-iop33x/iq80332.c:			"device PCI:%d:%d:%d\n", dev->bus->number,
arch/arm/mach-ixp4xx/common-pci.c:	u8 bus_num = bus->number;
arch/arm/mach-ixp4xx/common-pci.c:	u8 bus_num = bus->number;
arch/arm/mach-kirkwood/include/mach/bridge-regs.h: * Mbus-L to Mbus Bridge Registers
arch/arm/mach-kirkwood/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-kirkwood/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
arch/arm/mach-kirkwood/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-kirkwood/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
arch/arm/mach-kirkwood/pcie.c:	if (dev->bus->parent == NULL && dev->devfn == 0) {
arch/arm/mach-ks8695/pci.c:	ks8695_pci_setupconfig(bus->number, devfn, where);
arch/arm/mach-ks8695/pci.c:			bus->number, devfn, where, size, *value,
arch/arm/mach-ks8695/pci.c:			bus->number, devfn, where, size, value);
arch/arm/mach-ks8695/pci.c:	ks8695_pci_setupconfig(bus->number, devfn, where);
arch/arm/mach-ks8695/pci.c:	/* Enable bus-master & Memory Space access */
arch/arm/mach-mv78xx0/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-mv78xx0/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
arch/arm/mach-mv78xx0/pcie.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/mach-mv78xx0/pcie.c:	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
arch/arm/mach-mv78xx0/pcie.c:	if (dev->bus->parent == NULL && dev->devfn == 0) {
arch/arm/mach-mv78xx0/pcie.c:	struct pci_sys_data *sys = dev->bus->sysdata;
arch/arm/mach-omap1/board-nokia770.c:#include <linux/platform_data/i2c-cbus-gpio.h>
arch/arm/mach-omap1/board-nokia770.c:	.name   = "i2c-cbus-gpio",
arch/arm/mach-omap2/board-n8x0.c:#include <linux/platform_data/i2c-cbus-gpio.h>
arch/arm/mach-omap2/board-n8x0.c:	.name	= "i2c-cbus-gpio",
arch/arm/mach-omap2/gpmc.c: * bus-width, burst configuration, etc. Function should be called once
arch/arm/mach-omap2/gpmc.c:	of_property_read_u32(np, "gpmc,bus-turnaround-ns",
arch/arm/mach-omap2/gpmc.c:	of_property_read_u32(np, "gpmc,wr-data-mux-bus-ns",
arch/arm/mach-omap2/omap_hwmod.c: * drivers should not call this function - the appropriate bus-related
arch/arm/mach-orion5x/pci.c:	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0) {
arch/arm/mach-orion5x/pci.c:	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0) {
arch/arm/mach-orion5x/pci.c:	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0)
arch/arm/mach-orion5x/pci.c:	if (!orion5x_pci_valid_config(bus->number, devfn)) {
arch/arm/mach-orion5x/pci.c:	return orion5x_pci_hw_rd_conf(bus->number, PCI_SLOT(devfn),
arch/arm/mach-orion5x/pci.c:	if (!orion5x_pci_valid_config(bus->number, devfn))
arch/arm/mach-orion5x/pci.c:	return orion5x_pci_hw_wr_conf(bus->number, PCI_SLOT(devfn),
arch/arm/mach-orion5x/pci.c:	if (dev->bus->parent == NULL && dev->devfn == 0) {
arch/arm/mach-orion5x/pci.c:	int bus = dev->bus->number;
arch/arm/mach-s3c24xx/clock-s3c2410.c:	.name		= "usb-bus-host",
arch/arm/mach-s3c24xx/clock-s3c2410.c:	.name		= "usb-bus-gadget",
arch/arm/mach-s3c24xx/clock-s3c2412.c:		.name		= "usb-bus-gadget",
arch/arm/mach-s3c24xx/clock-s3c2412.c:		.name		= "usb-bus-host",
arch/arm/mach-s3c24xx/common-s3c2443.c: * usb host bus-clock, usually 48MHz to provide USB bus clock timing
arch/arm/mach-s3c24xx/common-s3c2443.c:		.name		= "usb-bus-host-parent",
arch/arm/mach-s3c24xx/common-s3c2443.c:		/* camera interface bus-clock, divided down from esysclk */
arch/arm/mach-s3c24xx/common-s3c2443.c:		.name		= "usb-bus-host",
arch/arm/mach-sa1100/pci-nanoengine.c:	unsigned int busnr = bus->number;
arch/arm/mach-sa1100/pci-nanoengine.c:		((bus->number << 16) | (devfn << 8) | (where & ~3));
arch/arm/mach-sa1100/pci-nanoengine.c:	if (bus->number != 0 || (devfn >> 3) != 0) {
arch/arm/mach-versatile/pci.c:	unsigned int busnr = bus->number;
arch/arm/plat-iop/pci.c:	struct pci_sys_data *sys = bus->sysdata;
arch/arm/plat-iop/pci.c:	if (sys->busnr == bus->number)
arch/arm/plat-iop/pci.c:		addr = bus->number << 16 | PCI_SLOT(devfn) << 11 | 1;
arch/arm/plat-iop/pci.c:/* for platforms that might be host-bus-adapters */
arch/arm/plat-orion/pcie.c:	writel(PCIE_CONF_BUS(bus->number) |
arch/arm/plat-orion/pcie.c:	writel(PCIE_CONF_BUS(bus->number) |
arch/arm/plat-orion/pcie.c:	if (bus->number != orion_pcie_get_local_bus_nr(base) ||
arch/arm/plat-orion/pcie.c:	*val = readl(wa_base + (PCIE_CONF_BUS(bus->number) |
arch/arm/plat-orion/pcie.c:	writel(PCIE_CONF_BUS(bus->number) |
arch/avr32/include/asm/dma-mapping.h: * @handle: bus-specific DMA address
arch/avr32/include/asm/dma-mapping.h: * @handle: bus-specific DMA address
arch/cris/arch-v10/kernel/head.S:	move.d	$r0, [$r1]; assert ATA bus-reset
arch/cris/arch-v10/lib/usercopy.c:   Note that the PC saved at a bus-fault is the address *after* the
arch/cris/arch-v10/lib/usercopy.c:   the instruction is performed regardless of bus-fault; the register is
arch/cris/arch-v32/lib/usercopy.c:   Note that for CRISv32, the PC saved at a bus-fault is the address
arch/cris/arch-v32/lib/usercopy.c:   performed at a bus-fault; the register is seen having the original
arch/frv/mb93090-mb00/pci-frv.c:		if ((dev = bus->self)) {
arch/frv/mb93090-mb00/pci-frv.c:		pcibios_allocate_bus_resources(&bus->children);
arch/frv/mb93090-mb00/pci-vdk.c:	(0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
arch/frv/mb93090-mb00/pci-vdk.c://	return dev->bus->number==0 && (dev->devfn==PCI_DEVFN(0,0));
arch/frv/mb93090-mb00/pci-vdk.c://	return dev->bus->number==1;
arch/frv/mb93090-mb00/pci-vdk.c://	return dev->bus->number==0 &&
arch/frv/mb93090-mb00/pci-vdk.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/frv/mb93090-mb00/pci-vdk.c:		if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/frv/mb93090-mb00/pci-vdk.c:		if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/frv/mb93090-mb00/pci-vdk.c:		if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/frv/mb93090-mb00/pci-vdk.c:	printk("### PCIBIOS_FIXUP_BUS(%d)\n",bus->number);
arch/frv/mb93090-mb00/pci-vdk.c:	if (bus->number == 0) {
arch/frv/mb93090-mb00/pci-vdk.c:		list_for_each_entry(dev, &bus->devices, bus_list) {
arch/ia64/hp/common/sba_iommu.c:		panic(PFX "no sysdata on bus %d!\n", bus->number);
arch/ia64/hp/common/sba_iommu.c:	printk(KERN_WARNING "No IOC for PCI Bus %04x:%02x in ACPI\n", pci_domain_nr(bus), bus->number);
arch/ia64/include/asm/sn/tioca_provider.h:	struct list_head	*ca_devices;	/* bus->devices */
arch/ia64/kernel/iosapic.c: *     INTD).  The device is uniquely identified by its bus-, and slot-number
arch/ia64/pci/fixup.c:		bridge = bus->self;
arch/ia64/pci/fixup.c:		bus = bus->parent;
arch/ia64/pci/pci.c:	return raw_pci_read(pci_domain_nr(bus), bus->number,
arch/ia64/pci/pci.c:	return raw_pci_write(pci_domain_nr(bus), bus->number,
arch/ia64/pci/pci.c:	pci_set_host_bridge_release(to_pci_host_bridge(pbus->bridge),
arch/ia64/pci/pci.c:	struct pci_controller *controller = bridge->bus->sysdata;
arch/ia64/sn/kernel/io_acpi_init.c:	pcidev_match.bus = dev->bus->number;
arch/ia64/sn/kernel/io_acpi_init.c:	if (!bus->parent) {	/* If root bus */
arch/ia64/sn/kernel/io_acpi_init.c:			       __func__, pci_domain_nr(bus), bus->number);
arch/ia64/sn/kernel/io_acpi_init.c:	list_for_each_entry(pci_dev, &bus->devices, bus_list) {
arch/ia64/sn/kernel/io_init.c:		(u64) dev->bus->number,
arch/ia64/sn/kernel/io_init.c:	if (!bus->parent) {  /* If root bus */
arch/ia64/sn/kernel/io_init.c:			       pci_domain_nr(bus), bus->number);
arch/ia64/sn/kernel/io_init.c:        list_for_each_entry(pci_dev, &bus->devices, bus_list) {
arch/ia64/sn/pci/pci_dma.c:		 pci_domain_nr(bus), bus->number,
arch/ia64/sn/pci/pci_dma.c:		 pci_domain_nr(bus), bus->number,
arch/ia64/sn/pci/tioca_provider.c:	tioca_kern->ca_devices = &bus->devices;
arch/ia64/sn/pci/tioce_provider.c:		    (pdev->bus->number < ce_kernel->ce_port1_secondary) ? 0 : 1;
arch/m68k/include/asm/sun3mmu.h:/* Bits within bus-error register. */
arch/m68k/kernel/pcibios.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/m68k/platform/coldfire/pci.c:	if (bus->number == 0) {
arch/m68k/platform/coldfire/pci.c:	addr = mcf_mk_pcicar(bus->number, devfn, where);
arch/m68k/platform/coldfire/pci.c:	if (bus->number == 0) {
arch/m68k/platform/coldfire/pci.c:	addr = mcf_mk_pcicar(bus->number, devfn, where);
arch/m68k/platform/coldfire/pci.c:	rootbus->resource[0] = &mcf_pci_io;
arch/m68k/platform/coldfire/pci.c:	rootbus->resource[1] = &mcf_pci_mem;
arch/microblaze/include/asm/pci-bridge.h:	return bus->sysdata;
arch/microblaze/kernel/cpu/cpuinfo-static.c:		(fcpu(cpu, "xlnx,iopb-bus-exception") ?
arch/microblaze/kernel/cpu/cpuinfo-static.c:		(fcpu(cpu, "xlnx,dopb-bus-exception") ?
arch/microblaze/pci/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/microblaze/pci/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/microblaze/pci/indirect_pci.c:	bus_no = (bus->number == hose->first_busno) ?
arch/microblaze/pci/indirect_pci.c:			hose->self_busno : bus->number;
arch/microblaze/pci/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/microblaze/pci/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/microblaze/pci/indirect_pci.c:	bus_no = (bus->number == hose->first_busno) ?
arch/microblaze/pci/indirect_pci.c:			hose->self_busno : bus->number;
arch/microblaze/pci/indirect_pci.c:			(bus->number == hose->first_busno))
arch/microblaze/pci/pci-common.c:		 pci_domain_nr(bus), bus->number,
arch/microblaze/pci/pci-common.c:				pci_domain_nr(bus), bus->number);
arch/microblaze/pci/pci-common.c:	struct pci_dev *dev = bus->self;
arch/microblaze/pci/pci-common.c:	struct pci_dev *dev = bus->self;
arch/microblaze/pci/pci-common.c:		if (i >= 3 && bus->self->transparent)
arch/microblaze/pci/pci-common.c:	if (bus->self != NULL)
arch/microblaze/pci/pci-common.c:		 bus->number, bus->self ? pci_name(bus->self) : "PHB");
arch/microblaze/pci/pci-common.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/microblaze/pci/pci-common.c:	if (bus->self != NULL)
arch/microblaze/pci/pci-common.c:		 pci_domain_nr(bus), bus->number);
arch/microblaze/pci/pci-common.c:		if (bus->parent == NULL)
arch/microblaze/pci/pci-common.c:			pr = pci_find_parent_resource(bus->self, res);
arch/microblaze/pci/pci-common.c:			 bus->self ? pci_name(bus->self) : "PHB",
arch/microblaze/pci/pci-common.c:			 bus->number, i,
arch/microblaze/pci/pci-common.c:		pr_cont("%d of PCI bridge %d, will remap\n", i, bus->number);
arch/microblaze/pci/pci-common.c:	list_for_each_entry(b, &bus->children, node)
arch/microblaze/pci/pci-common.c:		       pci_domain_nr(bus), bus->number, res);
arch/microblaze/pci/pci-common.c:		       pci_domain_nr(bus), bus->number, res);
arch/microblaze/pci/pci-common.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/microblaze/pci/pci-common.c:	list_for_each_entry(child_bus, &bus->children, node)
arch/microblaze/pci/pci-common.c:		 pci_domain_nr(bus), bus->number);
arch/microblaze/pci/pci-common.c:	struct pci_controller *hose = bus->sysdata;
arch/microblaze/pci/pci-common.c:	bus->busn_res.start = hose->first_busno;
arch/microblaze/pci/pci-common.c:	hose->last_busno = bus->busn_res.end;
arch/microblaze/pci/xilinx_pci.c:	if (dev->devfn || dev->bus->self)
arch/microblaze/platform/generic/system.dts:			xlnx,dopb-bus-exception = <0x0>;
arch/microblaze/platform/generic/system.dts:			xlnx,dynamic-bus-sizing = <0x1>;
arch/microblaze/platform/generic/system.dts:			xlnx,iopb-bus-exception = <0x0>;
arch/mips/ath79/mach-ap136.c:	if (dev->bus->number == 1 && (PCI_SLOT(dev->devfn)) == 0)
arch/mips/ath79/pci.c:		if (entry->bus == dev->bus->number &&
arch/mips/bcm47xx/setup.c:	if (bus->bustype == SSB_BUSTYPE_PCI) {
arch/mips/bcm47xx/setup.c:			 bus->host_pci->bus->number + 1,
arch/mips/bcm47xx/setup.c:			 PCI_SLOT(bus->host_pci->devfn));
arch/mips/bcm47xx/setup.c:	switch (bus->hosttype) {
arch/mips/bcm47xx/setup.c:			 bus->host_pci->bus->number + 1,
arch/mips/bcm47xx/setup.c:			 PCI_SLOT(bus->host_pci->devfn));
arch/mips/bcm63xx/boards/board_bcm963xx.c:	if (bus->bustype == SSB_BUSTYPE_PCI) {
arch/mips/cavium-octeon/octeon-platform.c:						"cavium,bus-width", &width, sizeof(width));
arch/mips/cavium-octeon/octeon_3xxx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_3xxx.dts:				cavium,bus-width = <8>;
arch/mips/cavium-octeon/octeon_3xxx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_3xxx.dts:				cavium,bus-width = <8>;
arch/mips/cavium-octeon/octeon_3xxx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_3xxx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_3xxx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_3xxx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_3xxx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_3xxx.dts:			compatible = "cavium,octeon-5750-bootbus-dma";
arch/mips/cavium-octeon/octeon_3xxx.dts:			compatible = "cavium,octeon-5750-bootbus-dma";
arch/mips/cavium-octeon/octeon_68xx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_68xx.dts:				cavium,bus-width = <8>;
arch/mips/cavium-octeon/octeon_68xx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_68xx.dts:				cavium,bus-width = <8>;
arch/mips/cavium-octeon/octeon_68xx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_68xx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_68xx.dts:				compatible = "cavium,octeon-3860-bootbus-config";
arch/mips/cavium-octeon/octeon_68xx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_68xx.dts:				cavium,bus-width = <16>;
arch/mips/cavium-octeon/octeon_68xx.dts:			compatible = "cavium,octeon-5750-bootbus-dma";
arch/mips/cavium-octeon/octeon_68xx.dts:			compatible = "cavium,octeon-5750-bootbus-dma";
arch/mips/dec/tc.c:	memcpy(&tbus->info, rex_gettcinfo(), sizeof(tbus->info));
arch/mips/dec/tc.c:	tbus->slot_base = CPHYSADDR((long)rex_slot_address(0));
arch/mips/dec/tc.c:		tbus->num_tcslots = 7;
arch/mips/dec/tc.c:		tbus->ext_slot_base = 0x20000000;
arch/mips/dec/tc.c:		tbus->ext_slot_size = 0x20000000;
arch/mips/dec/tc.c:		tbus->num_tcslots = 3;
arch/mips/dec/tc.c:		tbus->num_tcslots = 2;
arch/mips/include/asm/pci.h:	struct pci_controller *hose = bus->sysdata;
arch/mips/kernel/csrc-bcm1480.c:	.name	= "zbbus-cycles",
arch/mips/lantiq/dts/danube.dtsi:			bus-range = <0x0 0x0>;
arch/mips/lantiq/dts/easy50712.dts:			lantiq,bus-clock = <33333333>;
arch/mips/lasat/sysctl.c:		.procname	= "bus-hz",
arch/mips/lib/iomap-pci.c:	struct pci_controller *ctrl = dev->bus->sysdata;
arch/mips/lib/iomap-pci.c:		while (bus->parent)
arch/mips/lib/iomap-pci.c:			bus = bus->parent;
arch/mips/lib/iomap-pci.c:		sprintf(name, "%04x:%02x", pci_domain_nr(bus), bus->number);
arch/mips/pci/fixup-jmr3927.c:	if (dev->bus->parent == NULL &&
arch/mips/pci/fixup-rc32434.c:	if (dev->bus->number < 2 && PCI_SLOT(dev->devfn) < 12)
arch/mips/pci/fixup-rc32434.c:		irq = irq_map[dev->bus->number][PCI_SLOT(dev->devfn)];
arch/mips/pci/fixup-rc32434.c:	if (PCI_SLOT(dev->devfn) == 6 && dev->bus->number == 0) {
arch/mips/pci/fixup-sni.c:			while (dev && dev->bus->number != 1)
arch/mips/pci/fixup-sni.c:				dev = dev->bus->self;
arch/mips/pci/fixup-tb0287.c:	bus = dev->bus->number;
arch/mips/pci/ops-bcm63xx.c:	type = bus->parent ? 1 : 0;
arch/mips/pci/ops-bcm63xx.c:	return bcm63xx_do_cfg_read(type, bus->number, devfn,
arch/mips/pci/ops-bcm63xx.c:	type = bus->parent ? 1 : 0;
arch/mips/pci/ops-bcm63xx.c:	return bcm63xx_do_cfg_write(type, bus->number, devfn,
arch/mips/pci/ops-bcm63xx.c:	if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
arch/mips/pci/ops-bcm63xx.c:		fake_cb_bridge_bus_number = bus->number;
arch/mips/pci/ops-bcm63xx.c:	    bus->number == fake_cb_bridge_regs.cardbus_busn &&
arch/mips/pci/ops-bcm63xx.c:	if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
arch/mips/pci/ops-bcm63xx.c:		fake_cb_bridge_bus_number = bus->number;
arch/mips/pci/ops-bcm63xx.c:	    bus->number == fake_cb_bridge_regs.cardbus_busn &&
arch/mips/pci/ops-bcm63xx.c:	if (dev->bus->number == fake_cb_bridge_bus_number)
arch/mips/pci/ops-bcm63xx.c:	    dev->bus->number == fake_cb_bridge_regs.cardbus_busn &&
arch/mips/pci/ops-bcm63xx.c:	switch (bus->number) {
arch/mips/pci/ops-bcm63xx.c:	if (bus->number == PCIE_BUS_DEVICE)
arch/mips/pci/ops-bcm63xx.c:	if (bus->number == PCIE_BUS_DEVICE)
arch/mips/pci/ops-bonito64.c:	u32 busnum = bus->number;
arch/mips/pci/ops-bridge.c:	int busno = bus->number;
arch/mips/pci/ops-bridge.c:	if (bus->number > 0)
arch/mips/pci/ops-bridge.c:	int busno = bus->number;
arch/mips/pci/ops-bridge.c:	if (bus->number > 0)
arch/mips/pci/ops-emma2rh.c:	if (bus->parent != NULL) {
arch/mips/pci/ops-emma2rh.c:		*bus_num = bus->number;
arch/mips/pci/ops-gt64xxx_pci0.c:	unsigned char busnum = bus->number;
arch/mips/pci/ops-lantiq.c:	if ((bus->number != 0) || ((devfn & 0xf8) > 0x78)
arch/mips/pci/ops-lantiq.c:	cfg_base |= (bus->number << LTQ_PCI_CFG_BUSNUM_SHF) | (devfn <<
arch/mips/pci/ops-loongson2.c:	u32 busnum = bus->number;
arch/mips/pci/ops-mace.c:	return ((bus->number & 0xff) << 16) |
arch/mips/pci/ops-mace.c:	if (bus->number == 0 && reg == 0x40 && size == 4 &&
arch/mips/pci/ops-msc.c:	unsigned char busnum = bus->number;
arch/mips/pci/ops-nile4.c:	unsigned char busnum = bus->number;
arch/mips/pci/ops-pmcmsp.c: *				used is bus->number. This argument determines
arch/mips/pci/ops-pmcmsp.c: *				PCI Host, any non-zero bus->number generates
arch/mips/pci/ops-pmcmsp.c:	unsigned char bus_num = bus->number;
arch/mips/pci/ops-rc32434.c:	PCI_CFG_SET(bus->number, slot, func, where);
arch/mips/pci/ops-rc32434.c:	if (bus->number == 0 && PCI_SLOT(devfn) > 21)
arch/mips/pci/ops-sni.c:	if ((res = set_config_address(bus->number, devfn, reg)))
arch/mips/pci/ops-sni.c:	if ((res = set_config_address(bus->number, devfn, reg)))
arch/mips/pci/ops-sni.c:	if (bus->number == 0) {
arch/mips/pci/ops-sni.c:	if ((res = pcit_set_config_address(bus->number, devfn, reg)))
arch/mips/pci/ops-sni.c:	if ((res = pcit_set_config_address(bus->number, devfn, reg)))
arch/mips/pci/ops-tx3927.c:	if (bus->parent == NULL &&
arch/mips/pci/ops-tx3927.c:		((bus->number & 0xff) << 0x10) |
arch/mips/pci/ops-tx3927.c:		(where & 0xfc) | (bus->parent ? 1 : 0);
arch/mips/pci/ops-tx4927.c:	if (bus->parent == NULL &&
arch/mips/pci/ops-tx4927.c:	__raw_writel(((bus->number & 0xff) << 0x10)
arch/mips/pci/ops-tx4927.c:		     | (bus->parent ? 1 : 0),
arch/mips/pci/ops-tx4927.c:	struct pci_controller *channel = bus->sysdata;
arch/mips/pci/ops-vr41xx.c:	if (set_pci_configuration_address(bus->number, devfn, where) < 0)
arch/mips/pci/ops-vr41xx.c:	if (set_pci_configuration_address(bus->number, devfn, where) < 0)
arch/mips/pci/pci-alchemy.c:	struct alchemy_pci_context *ctx = bus->sysdata;
arch/mips/pci/pci-alchemy.c:	if (bus->number == 0)
arch/mips/pci/pci-alchemy.c:		cfg_base = 0x80000000 | (bus->number << 16) | (device << 11);
arch/mips/pci/pci-alchemy.c:	    access_type, bus->number, device, where, *data, offset);
arch/mips/pci/pci-alchemy.c:		    access_type, bus->number, device);
arch/mips/pci/pci-ar71xx.c:	if (!bus->number) {
arch/mips/pci/pci-ar71xx.c:		ret = (bus->number << 16) | (PCI_SLOT(devfn) << 11) |
arch/mips/pci/pci-ar71xx.c:	hose = (struct pci_controller *) bus->sysdata;
arch/mips/pci/pci-ar724x.c:	hose = (struct pci_controller *) bus->sysdata;
arch/mips/pci/pci-bcm1480.c:	if (bus->number == 0) {
arch/mips/pci/pci-bcm1480ht.c:	if (bus->number == 0) {
arch/mips/pci/pci-ip27.c:	while (dev->bus->parent) {
arch/mips/pci/pci-ip27.c:		dev = dev->bus->self;
arch/mips/pci/pci-lantiq.c:	bus_clk = of_get_property(node, "lantiq,bus-clock", NULL);
arch/mips/pci/pci-octeon.c:	pci_addr.s.bus = bus->number;
arch/mips/pci/pci-octeon.c:	pci_addr.s.bus = bus->number;
arch/mips/pci/pci-rt3883.c:	hose = (struct pci_controller *) bus->sysdata;
arch/mips/pci/pci-rt3883.c:	if (!rpc->pcie_ready && bus->number == 1)
arch/mips/pci/pci-rt3883.c:	address = rt3883_pci_get_cfgaddr(bus->number, PCI_SLOT(devfn),
arch/mips/pci/pci-rt3883.c:	if (!rpc->pcie_ready && bus->number == 1)
arch/mips/pci/pci-rt3883.c:	address = rt3883_pci_get_cfgaddr(bus->number, PCI_SLOT(devfn),
arch/mips/pci/pci-sb1250.c:	if (bus->number == 0) {
arch/mips/pci/pci-tx4938.c:	if (get_tx4927_pcicptr(dev->bus->sysdata) == tx4938_pcic1ptr) {
arch/mips/pci/pci-tx4939.c:	if (get_tx4927_pcicptr(dev->bus->sysdata) == tx4939_pcic1ptr) {
arch/mips/pci/pci-xlp.c:	if (bus->number == 0 && PCI_SLOT(devfn) == 1 && where == 0x954)
arch/mips/pci/pci-xlp.c:			pci_cfg_addr(bus->number, devfn, where));
arch/mips/pci/pci-xlp.c:			pci_cfg_addr(bus->number, devfn, where & ~3));
arch/mips/pci/pci-xlp.c:	for (p = bus->parent; p && p->number != 0; p = p->parent)
arch/mips/pci/pci-xlp.c:	return p ? bus->self : NULL;
arch/mips/pci/pci-xlr.c:			pci_cfg_addr(bus->number, devfn, where & ~3));
arch/mips/pci/pci-xlr.c:			pci_cfg_addr(bus->number, devfn, where & ~3));
arch/mips/pci/pci-xlr.c:	for (p = bus->parent; p && p->number != 0; p = p->parent)
arch/mips/pci/pci-xlr.c:	return p ? bus->self : NULL;
arch/mips/pci/pci.c:		next_busno = bus->busn_res.end + 1;
arch/mips/pci/pci.c:	struct pci_controller *hose = bus->sysdata;
arch/mips/pci/pci.c:	struct pci_dev *dev = bus->self;
arch/mips/pci/pcie-octeon.c:	    dev->bus && dev->bus->parent) {
arch/mips/pci/pcie-octeon.c:		while (dev->bus && dev->bus->parent)
arch/mips/pci/pcie-octeon.c:			dev = to_pci_dev(dev->bus->bridge);
arch/mips/pci/pcie-octeon.c:		if ((dev->bus->number == 1) &&
arch/mips/pci/pcie-octeon.c:	int bus_number = bus->number;
arch/mips/pci/pcie-octeon.c:	if (bus->parent == NULL) {
arch/mips/pci/pcie-octeon.c:	if ((bus->parent == NULL) && (devfn >> 3 != 0))
arch/mips/pci/pcie-octeon.c:		if ((bus->parent == NULL) && (devfn >= 2))
arch/mips/pci/pcie-octeon.c:	int bus_number = bus->number;
arch/mips/pci/pcie-octeon.c:	if ((bus->parent == NULL) && (enable_pcie_bus_num_war[pcie_port]))
arch/mips/sgi-ip22/ip28-berr.c:	 * Starting with a bus-address, save secondary cache (indexed by
arch/mips/sgi-ip22/ip28-berr.c:	 * might fit to this bus-address, knowing that VA[11:0] == PA[11:0].
arch/mn10300/unit-asb2305/pci-asb2305.c:		dev = bus->self;
arch/mn10300/unit-asb2305/pci-asb2305.c:		pcibios_allocate_bus_resources(&bus->children);
arch/mn10300/unit-asb2305/pci.c:	(0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
arch/mn10300/unit-asb2305/pci.c:	return bus->number == 0 && (devfn == PCI_DEVFN(0, 0));
arch/mn10300/unit-asb2305/pci.c:	return bus->number == 1;
arch/mn10300/unit-asb2305/pci.c:	return bus->number == 0 &&
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:		if (bus->number == 0 &&
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:	if (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {
arch/mn10300/unit-asb2305/pci.c:	if (dev->bus->number != 0)
arch/mn10300/unit-asb2305/pci.c:	if (bus->self) {
arch/mn10300/unit-asb2305/pci.c:		pcibios_fixup_device_resources(bus->self);
arch/mn10300/unit-asb2305/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list)
arch/mn10300/unit-asb2305/pci.c:	bus->number = 0;
arch/parisc/kernel/pci.c:	struct pci_dev *dev = bus->self;
arch/parisc/kernel/pci.c:	if (dev->bus->bridge_ctl & PCI_BRIDGE_CTL_FAST_BACK)
arch/powerpc/boot/cuboot-52xx.c:		setprop(soc, "bus-frequency", &bd.bi_ipbfreq,
arch/powerpc/boot/cuboot-824x.c:		setprop(soc, "bus-frequency", &bd.bi_busfreq,
arch/powerpc/boot/cuboot-83xx.c:		setprop(soc, "bus-frequency", &bd.bi_busfreq,
arch/powerpc/boot/cuboot-85xx-cpm2.c:		setprop(devp, "bus-frequency", &bd.bi_busfreq,
arch/powerpc/boot/cuboot-85xx.c:		setprop(soc, "bus-frequency", &bd.bi_busfreq,
arch/powerpc/boot/cuboot-mpc7448hpc2.c:		setprop(tsi, "bus-frequency", &bd.bi_busfreq,
arch/powerpc/boot/devtree.c:		printf("CPU bus-frequency <- 0x%x (%dMHz)\n\r", bus, MHZ(bus));
arch/powerpc/boot/devtree.c:			setprop_val(devp, "bus-frequency", bus);
arch/powerpc/boot/dts/a3m071.dts:		bus-frequency = <0>; /* From boot loader */
arch/powerpc/boot/dts/a4m072.dts:		bus-frequency = <0>; /* From boot loader */
arch/powerpc/boot/dts/a4m072.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/ac14xx.dts:			bus-frequency = <160000000>;		/* 160 MHz csb bus */
arch/powerpc/boot/dts/adder875-redboot.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/adder875-uboot.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/amigaone.dts:			bus-frequency = <0>;		// From U-boot
arch/powerpc/boot/dts/amigaone.dts:		bus-frequency = <33333333>;
arch/powerpc/boot/dts/amigaone.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/asp834x-redboot.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/asp834x-redboot.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/bluestone.dts:			bus-range = <0x40 0x7f>;
arch/powerpc/boot/dts/c2k.dts:			bus-frequency = <166666667>;	/* 166.6666 MHz */
arch/powerpc/boot/dts/c2k.dts:			bus-range = <0 255>;
arch/powerpc/boot/dts/c2k.dts:			bus-range = <0 255>;
arch/powerpc/boot/dts/canyonlands.dts:			bus-range = <0x0 0x3f>;
arch/powerpc/boot/dts/canyonlands.dts:			bus-range = <0x40 0x7f>;
arch/powerpc/boot/dts/canyonlands.dts:			bus-range = <0x80 0xbf>;
arch/powerpc/boot/dts/charon.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/charon.dts:		bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/charon.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/currituck.dts:			bus-range = <0x0 0xf>;
arch/powerpc/boot/dts/currituck.dts:			bus-range = <0x0 0xf>;
arch/powerpc/boot/dts/currituck.dts:			bus-range = <0x0 0xf>;
arch/powerpc/boot/dts/digsy_mtc.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/ep88xc.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/ep88xc.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/fsl/b4si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/bsc9131si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/c293si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/c293si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8544si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/mpc8544si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8544si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8544si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8544si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8548si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/mpc8548si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/mpc8548si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8548si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8568si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/mpc8568si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8568si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8568si-post.dtsi:	bus-frequency = <396000000>;
arch/powerpc/boot/dts/fsl/mpc8569si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8569si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/mpc8569si-post.dtsi:	bus-frequency = <0>;
arch/powerpc/boot/dts/fsl/mpc8572si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8572si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8572si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/mpc8572si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p1010si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1010si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1010si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p1020si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1020si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1020si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p1021si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1021si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1021si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:	bus-range = <0 255>;
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:	bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/fsl/p2041si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p2041si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p2041si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p4080si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p4080si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p4080si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p5040si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/p5040si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/p5040si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:	bus-range = <0 0xff>;
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:	bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/gamecube.dts:			bus-frequency = <162000000>; /* 162MHz core-to-bus 3x */
arch/powerpc/boot/dts/gef_ppc9a.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_ppc9a.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_ppc9a.dts:		bus-frequency = <33333333>;
arch/powerpc/boot/dts/gef_ppc9a.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/gef_sbc310.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_sbc310.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_sbc310.dts:		bus-frequency = <33333333>;
arch/powerpc/boot/dts/gef_sbc310.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/gef_sbc310.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/gef_sbc610.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_sbc610.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/gef_sbc610.dts:		bus-frequency = <33333333>;
arch/powerpc/boot/dts/gef_sbc610.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/glacier.dts:			bus-range = <0x0 0x3f>;
arch/powerpc/boot/dts/glacier.dts:			bus-range = <0x40 0x7f>;
arch/powerpc/boot/dts/glacier.dts:			bus-range = <0x80 0xbf>;
arch/powerpc/boot/dts/haleakala.dts:			bus-range = <0x0 0x3f>;
arch/powerpc/boot/dts/holly.dts:			bus-frequency = <200000000>;
arch/powerpc/boot/dts/holly.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/icon.dts:			bus-range = <0x0 0xf>;
arch/powerpc/boot/dts/icon.dts:			bus-range = <0x10 0x1f>;
arch/powerpc/boot/dts/icon.dts:			bus-range = <0x20 0x2f>;
arch/powerpc/boot/dts/katmai.dts:			bus-range = <0x0 0xf>;
arch/powerpc/boot/dts/katmai.dts:			bus-range = <0x10 0x1f>;
arch/powerpc/boot/dts/katmai.dts:			bus-range = <0x20 0x2f>;
arch/powerpc/boot/dts/katmai.dts:			bus-range = <0x30 0x3f>;
arch/powerpc/boot/dts/kilauea.dts:			bus-range = <0x0 0x3f>;
arch/powerpc/boot/dts/kilauea.dts:			bus-range = <0x40 0x7f>;
arch/powerpc/boot/dts/kmeter1.dts:			bus-frequency = <0>;	/* Filled in by U-Boot */
arch/powerpc/boot/dts/kmeter1.dts:		bus-frequency = <0>;	/* Filled in by U-Boot */
arch/powerpc/boot/dts/kmeter1.dts:			bus-frequency = <0>;	/* Filled in by U-Boot */
arch/powerpc/boot/dts/ksi8560.dts:			bus-frequency = <0>;			/* From U-boot */
arch/powerpc/boot/dts/ksi8560.dts:		bus-frequency = <0>;				/* Fixed by bootwrapper */
arch/powerpc/boot/dts/kuroboxHD.dts:			bus-frequency = <0>;		/* Fixed by bootloader */
arch/powerpc/boot/dts/kuroboxHD.dts:			bus-range = <0 255>;
arch/powerpc/boot/dts/kuroboxHG.dts:			bus-frequency = <0>;		/* Fixed by bootloader */
arch/powerpc/boot/dts/kuroboxHG.dts:			bus-range = <0 255>;
arch/powerpc/boot/dts/lite5200.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/lite5200.dts:		bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/lite5200.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/lite5200b.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/makalu.dts:			bus-range = <0x0 0x3f>;
arch/powerpc/boot/dts/makalu.dts:			bus-range = <0x40 0x7f>;
arch/powerpc/boot/dts/media5200.dts:			bus-frequency = <132000000>;		// 132 MHz
arch/powerpc/boot/dts/media5200.dts:		bus-frequency = <132000000>;// 132 MHz
arch/powerpc/boot/dts/mgcoge.dts:			bus-frequency = <0>; /* Filled in by U-Boot */
arch/powerpc/boot/dts/mpc5121.dtsi:			bus-frequency = <198000000>;	/* 198 MHz csb bus */
arch/powerpc/boot/dts/mpc5121.dtsi:		bus-frequency = <66000000>;	/* 66 MHz ips bus */
arch/powerpc/boot/dts/mpc5121.dtsi:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc5125twr.dts:			bus-frequency = <198000000>;	// 198 MHz csb bus
arch/powerpc/boot/dts/mpc5125twr.dts:		bus-frequency = <66000000>;	// 66 MHz ips bus
arch/powerpc/boot/dts/mpc5200b.dtsi:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc5200b.dtsi:		bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc5200b.dtsi:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc7448hpc2.dts:			bus-frequency = <0>;		// From U-Boot
arch/powerpc/boot/dts/mpc7448hpc2.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc7448hpc2.dts:			bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8272ads.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8308_p1m.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8308_p1m.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8308_p1m.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8308rdb.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8308rdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8308rdb.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8313erdb.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8313erdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8313erdb.dts:			bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8315erdb.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8315erdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8315erdb.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8315erdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8315erdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc832x_mds.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc832x_mds.dts:		bus-frequency = <132000000>;
arch/powerpc/boot/dts/mpc832x_mds.dts:		bus-frequency = <198000000>;
arch/powerpc/boot/dts/mpc832x_mds.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc832x_rdb.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc832x_rdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc832x_rdb.dts:		bus-frequency = <198000000>;
arch/powerpc/boot/dts/mpc832x_rdb.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8349emitx.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8349emitx.dts:		bus-frequency = <0>;                    // from bootloader
arch/powerpc/boot/dts/mpc8349emitx.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8349emitx.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8349emitxgp.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc8349emitxgp.dts:		bus-frequency = <0>;                    // from bootloader
arch/powerpc/boot/dts/mpc8349emitxgp.dts:		bus-range = <0x1 0x1>;
arch/powerpc/boot/dts/mpc834x_mds.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/mpc834x_mds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc834x_mds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc834x_mds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc836x_mds.dts:			bus-frequency = <264000000>;
arch/powerpc/boot/dts/mpc836x_mds.dts:		bus-frequency = <264000000>;
arch/powerpc/boot/dts/mpc836x_mds.dts:		bus-frequency = <396000000>;
arch/powerpc/boot/dts/mpc836x_mds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc836x_rdk.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc836x_rdk.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc836x_rdk.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc836x_rdk.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8377_mds.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_mds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_mds.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8377_mds.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8377_mds.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8377_rdb.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_rdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_rdb.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8377_rdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8377_rdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8377_wlan.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_wlan.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8377_wlan.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8377_wlan.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8377_wlan.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8378_mds.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8378_mds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8378_mds.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8378_mds.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8378_mds.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8378_rdb.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8378_rdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8378_rdb.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8378_rdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8378_rdb.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8379_mds.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8379_mds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8379_mds.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8379_rdb.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8379_rdb.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8379_rdb.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/mpc8540ads.dts:			bus-frequency = <0>;	// 166 MHz
arch/powerpc/boot/dts/mpc8540ads.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8540ads.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8541cds.dts:			bus-frequency = <0>;	// 166 MHz
arch/powerpc/boot/dts/mpc8541cds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8541cds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8541cds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8555cds.dts:			bus-frequency = <0>;	// 166 MHz
arch/powerpc/boot/dts/mpc8555cds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8555cds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8555cds.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8560ads.dts:			bus-frequency = <330000000>;
arch/powerpc/boot/dts/mpc8560ads.dts:		bus-frequency = <330000000>;
arch/powerpc/boot/dts/mpc8560ads.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8569mds.dts:			bus-width = <1>;
arch/powerpc/boot/dts/mpc8610_hpcd.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/mpc8610_hpcd.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8610_hpcd.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/mpc8610_hpcd.dts:		bus-range = <1 3>;
arch/powerpc/boot/dts/mpc8610_hpcd.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/mpc8641_hpcn.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/mpc8641_hpcn.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/mpc8641_hpcn.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8641_hpcn.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/mpc8641_hpcn.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/mpc8641_hpcn_36b.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/mpc8641_hpcn_36b.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/mpc8641_hpcn_36b.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc8641_hpcn_36b.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/mpc8641_hpcn_36b.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/mpc866ads.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc866ads.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/mpc885ads.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/mpc885ads.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/o2d.dtsi:			ifm,csi-addr-bus-width = <24>;
arch/powerpc/boot/dts/o2d.dtsi:			ifm,csi-data-bus-width = <8>;
arch/powerpc/boot/dts/p1021mds.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/p1021rdb-pc_32b.dts:                bus-frequency = <0>;
arch/powerpc/boot/dts/p1021rdb-pc_36b.dts:                bus-frequency = <0>;
arch/powerpc/boot/dts/p1025rdb_32b.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/prpmc2800.dts:			bus-frequency = <133333333>;
arch/powerpc/boot/dts/prpmc2800.dts:			bus-range = <0 255>;
arch/powerpc/boot/dts/redwood.dts:			bus-range = <0x10 0x1f>;
arch/powerpc/boot/dts/redwood.dts:			bus-range = <0x20 0x2f>;
arch/powerpc/boot/dts/redwood.dts:			bus-range = <0x30 0x3f>;
arch/powerpc/boot/dts/sbc8349.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/sbc8349.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/sbc8349.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/sbc8548-post.dtsi:		bus-frequency = <0>;
arch/powerpc/boot/dts/sbc8548-post.dtsi:		bus-range = <0 0>;
arch/powerpc/boot/dts/sbc8548-post.dtsi:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/sbc8548-pre.dtsi:			bus-frequency = <0>;
arch/powerpc/boot/dts/sbc8641d.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/sbc8641d.dts:			bus-frequency = <0>;		// From uboot
arch/powerpc/boot/dts/sbc8641d.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/sbc8641d.dts:		bus-range = <0x0 0xff>;
arch/powerpc/boot/dts/sbc8641d.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/socrates.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/socrates.dts:		bus-frequency = <0>;		// Filled in by U-Boot
arch/powerpc/boot/dts/socrates.dts:		bus-range = <0x0 0x0>;
arch/powerpc/boot/dts/storcenter.dts:			bus-frequency = <0>;	/* from bootwrapper */
arch/powerpc/boot/dts/storcenter.dts:		bus-frequency = <0>;		/* fixed by loader */
arch/powerpc/boot/dts/storcenter.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/stx_gp3_8560.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/stx_gp3_8560.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/stx_gp3_8560.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/stxssa8555.dts:			bus-frequency = <0>;	// 166 MHz
arch/powerpc/boot/dts/stxssa8555.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/stxssa8555.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/stxssa8555.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm5200.dts:			bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/tqm5200.dts:		bus-frequency = <0>;		// from bootloader
arch/powerpc/boot/dts/tqm5200.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8540.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8540.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8540.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8541.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8541.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8541.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8548-bigflash.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8548-bigflash.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8548-bigflash.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/tqm8548.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8548.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8548.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/tqm8555.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8555.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8555.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8560.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8560.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/tqm8560.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/tqm8xx.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/wii.dts:			bus-frequency = <243000000>; /* 243MHz core-to-bus 3x */
arch/powerpc/boot/dts/xcalibur1501.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xcalibur1501.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xcalibur1501.dts:			bus-width = <32>;
arch/powerpc/boot/dts/xcalibur1501.dts:		bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/xcalibur1501.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5200.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5200.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/xpedite5200_xmon.dts:		bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5200_xmon.dts:		bus-range = <0 0>;
arch/powerpc/boot/dts/xpedite5200_xmon.dts:		bus-range = <0 0xff>;
arch/powerpc/boot/dts/xpedite5301.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5301.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5301.dts:		bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/xpedite5301.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5301.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5330.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5330.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5330.dts:		bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/xpedite5330.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5330.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5330.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5370.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5370.dts:			bus-frequency = <0>;
arch/powerpc/boot/dts/xpedite5370.dts:		bus-frequency = <0>;		// Filled out by uboot.
arch/powerpc/boot/dts/xpedite5370.dts:		bus-range = <0 255>;
arch/powerpc/boot/dts/xpedite5370.dts:		bus-range = <0 255>;
arch/powerpc/include/asm/macio.h:	return mdev->bus->pdev;
arch/powerpc/include/asm/pci-bridge.h:	return bus->sysdata;
arch/powerpc/kernel/eeh.c: *  device to bus-master data to a memory address that is not
arch/powerpc/kernel/eeh.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/eeh.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/io-workarounds.c:		struct pci_controller *phb = bus->phb;
arch/powerpc/kernel/io-workarounds.c:	if (bus && bus->ops && bus->ops->name)			\
arch/powerpc/kernel/io-workarounds.c:		return bus->ops->name al;			\
arch/powerpc/kernel/io-workarounds.c:	if (bus && bus->ops && bus->ops->name) {		\
arch/powerpc/kernel/io-workarounds.c:		bus->ops->name al;				\
arch/powerpc/kernel/io-workarounds.c:	bus->phb = phb;
arch/powerpc/kernel/io-workarounds.c:	bus->ops = ops;
arch/powerpc/kernel/io-workarounds.c:	bus->private = data;
arch/powerpc/kernel/iommu.c: * Dynamic DMA mapping support, bus-independent parts.
arch/powerpc/kernel/pci-common.c:		 pci_domain_nr(bus), bus->number,
arch/powerpc/kernel/pci-common.c:			       current->comm, current->pid, pci_domain_nr(bus), bus->number);
arch/powerpc/kernel/pci-common.c:	struct pci_dev *dev = bus->self;
arch/powerpc/kernel/pci-common.c:	struct pci_dev *dev = bus->self;
arch/powerpc/kernel/pci-common.c:		if (i >= 3 && bus->self->transparent)
arch/powerpc/kernel/pci-common.c:	if (bus->self != NULL)
arch/powerpc/kernel/pci-common.c:	if (dev->bus->is_added)
arch/powerpc/kernel/pci-common.c:		 bus->number, bus->self ? pci_name(bus->self) : "PHB");
arch/powerpc/kernel/pci-common.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/pci-common.c:	    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))
arch/powerpc/kernel/pci-common.c:		 pci_domain_nr(bus), bus->number);
arch/powerpc/kernel/pci-common.c:		if (bus->parent == NULL)
arch/powerpc/kernel/pci-common.c:			pr = pci_find_parent_resource(bus->self, res);
arch/powerpc/kernel/pci-common.c:			 bus->self ? pci_name(bus->self) : "PHB",
arch/powerpc/kernel/pci-common.c:			 bus->number, i,
arch/powerpc/kernel/pci-common.c:			   "%d of PCI bridge %d, will remap\n", i, bus->number);
arch/powerpc/kernel/pci-common.c:	list_for_each_entry(b, &bus->children, node)
arch/powerpc/kernel/pci-common.c:		       pci_domain_nr(bus), bus->number, res);
arch/powerpc/kernel/pci-common.c:		       pci_domain_nr(bus), bus->number, res);
arch/powerpc/kernel/pci-common.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/pci-common.c:	list_for_each_entry(child_bus, &bus->children, node)
arch/powerpc/kernel/pci-common.c:		 pci_domain_nr(bus), bus->number);
arch/powerpc/kernel/pci-common.c:	struct pci_controller *hose = bus->sysdata;
arch/powerpc/kernel/pci-common.c:		list_for_each_entry(child, &bus->children, node)
arch/powerpc/kernel/pci-common.c:		(dev->bus->parent == NULL)) {
arch/powerpc/kernel/pci-hotplug.c:	list_for_each_entry(child_bus, &bus->children, node)
arch/powerpc/kernel/pci-hotplug.c:		 pci_domain_nr(bus),  bus->number);
arch/powerpc/kernel/pci-hotplug.c:	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
arch/powerpc/kernel/pci-hotplug.c:		max = bus->busn_res.start;
arch/powerpc/kernel/pci-hotplug.c:			list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/pci_32.c:	bus_range = of_get_property(node, "bus-range", &len);
arch/powerpc/kernel/pci_32.c:		printk(KERN_WARNING "Can't get bus-range for %s, "
arch/powerpc/kernel/pci_32.c:	map_prop = of_find_property(dn, "pci-OF-bus-map", NULL);
arch/powerpc/kernel/pci_32.c:		if (pci_to_OF_bus_map[dev->bus->number] == *bus &&
arch/powerpc/kernel/pci_32.c:			*bus = dev->bus->number;
arch/powerpc/kernel/pci_32.c:/* We create the "pci-OF-bus-map" property now so it appears in the
arch/powerpc/kernel/pci_32.c:		of_prop->name = "pci-OF-bus-map";
arch/powerpc/kernel/pci_64.c:	if (bus->self) {
arch/powerpc/kernel/pci_64.c:		struct resource *res = bus->resource[0];
arch/powerpc/kernel/pci_64.c:			 pci_name(bus->self));
arch/powerpc/kernel/pci_64.c:	if (bus->self) {
arch/powerpc/kernel/pci_64.c:			 pci_name(bus->self));
arch/powerpc/kernel/pci_64.c:			 bus->resource[0]->start + _IO_BASE,
arch/powerpc/kernel/pci_64.c:			 bus->resource[0]->end + _IO_BASE);
arch/powerpc/kernel/pci_64.c:		if (in_bus >= bus->number && in_bus <= bus->busn_res.end)
arch/powerpc/kernel/pci_64.c:	if (bus == NULL || bus->dev.of_node == NULL)
arch/powerpc/kernel/pci_64.c:	hose_node = bus->dev.of_node;
arch/powerpc/kernel/pci_of_scan.c:	dev->dev.parent = bus->bridge;
arch/powerpc/kernel/pci_of_scan.c:	list_for_each_entry(slot, &dev->bus->slots, list)
arch/powerpc/kernel/pci_of_scan.c:		dev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));
arch/powerpc/kernel/pci_of_scan.c:	/* parse bus-range property */
arch/powerpc/kernel/pci_of_scan.c:	busrange = of_get_property(node, "bus-range", &len);
arch/powerpc/kernel/pci_of_scan.c:		printk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %s\n",
arch/powerpc/kernel/pci_of_scan.c:	bus->primary = dev->bus->number;
arch/powerpc/kernel/pci_of_scan.c:	bus->bridge_ctl = 0;
arch/powerpc/kernel/pci_of_scan.c:		bus->resource[i] = res;
arch/powerpc/kernel/pci_of_scan.c:			res = bus->resource[0];
arch/powerpc/kernel/pci_of_scan.c:			res = bus->resource[i];
arch/powerpc/kernel/pci_of_scan.c:	sprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),
arch/powerpc/kernel/pci_of_scan.c:		bus->number);
arch/powerpc/kernel/pci_of_scan.c:	pr_debug("    bus name: %s\n", bus->name);
arch/powerpc/kernel/pci_of_scan.c:		 node->full_name, bus->number);
arch/powerpc/kernel/pci_of_scan.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/kernel/rtas_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/512x/clock.c:	rate = devtree_getfreq("bus-frequency");
arch/powerpc/platforms/512x/clock.c:		printk(KERN_ERR "No bus-frequency in dev tree\n");
arch/powerpc/platforms/512x/mpc512x_shared.c:			of_get_property(np, "bus-frequency", NULL);
arch/powerpc/platforms/512x/mpc512x_shared.c:			pr_err("Can't get bus-frequency property\n");
arch/powerpc/platforms/52xx/efika.c:	    | (((bus->number - hose->first_busno) & 0xff) << 16)
arch/powerpc/platforms/52xx/efika.c:	    | (((bus->number - hose->first_busno) & 0xff) << 16)
arch/powerpc/platforms/52xx/efika.c:	bus_range = of_get_property(pcictrl, "bus-range", &len);
arch/powerpc/platforms/52xx/efika.c:		       ": Can't get bus-range for %s\n", pcictrl->full_name);
arch/powerpc/platforms/52xx/mpc52xx_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/platforms/52xx/mpc52xx_pci.c:		(bus->number << 16) |
arch/powerpc/platforms/52xx/mpc52xx_pci.c:	if (bus->number) {
arch/powerpc/platforms/52xx/mpc52xx_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/platforms/52xx/mpc52xx_pci.c:		(bus->number << 16) |
arch/powerpc/platforms/52xx/mpc52xx_pci.c:	if (bus->number) {
arch/powerpc/platforms/52xx/mpc52xx_pci.c:	bus_range = of_get_property(node, "bus-range", &len);
arch/powerpc/platforms/52xx/mpc52xx_pci.c:		printk(KERN_WARNING "Can't get %s bus-range, assume bus 0\n",
arch/powerpc/platforms/82xx/ep8248e.c:	bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
arch/powerpc/platforms/82xx/ep8248e.c:	if (bus->irq == NULL) {
arch/powerpc/platforms/82xx/ep8248e.c:	bus->name = "ep8248e-mdio-bitbang";
arch/powerpc/platforms/82xx/ep8248e.c:	bus->parent = &ofdev->dev;
arch/powerpc/platforms/82xx/ep8248e.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%x", res.start);
arch/powerpc/platforms/82xx/ep8248e.c:	kfree(bus->irq);
arch/powerpc/platforms/85xx/mpc85xx_cds.c:	struct pci_dev *dev = bus->self;
arch/powerpc/platforms/85xx/mpc85xx_cds.c:	struct resource *res = bus->resource[0];
arch/powerpc/platforms/amigaone/setup.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/amigaone/setup.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/platforms/cell/celleb_pci.c:	pr_debug("    fake read: bus=0x%x, ", bus->number);
arch/powerpc/platforms/cell/celleb_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/cell/celleb_scc_epci.c:		       (((bus->number & 0xff) << 16)
arch/powerpc/platforms/cell/celleb_scc_epci.c:	if (bus->number == hose->first_busno && devfn == 0) {
arch/powerpc/platforms/cell/celleb_scc_epci.c:	if (bus->number == hose->first_busno && devfn == 0) {
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	(void)PEX_IN(bus->phb->cfg_addr, PEXDMRDEN0);
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	u##size data = __scc_pciex_in##name(bus->phb, port);		\
arch/powerpc/platforms/cell/celleb_scc_pciex.c:		*dst = cpu_to_le##size(__scc_pciex_in##name(bus->phb, p)); \
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	__scc_pciex_out##name(bus->phb, val, port);			\
arch/powerpc/platforms/cell/celleb_scc_pciex.c:		__scc_pciex_out##name(bus->phb, le##size##_to_cpu(*src), p); \
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	dummy_page_da = dma_map_single(bus->phb->parent, dummy_page_va,
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	if (dma_mapping_error(bus->phb->parent, dummy_page_da)) {
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	PEX_OUT(bus->phb->cfg_addr, PEXDMRDADR0, dummy_page_da);
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	if (bus->number == phb->first_busno && PCI_SLOT(devfn) != 1) {
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	if (bus->number == 0 && PCI_SLOT(devfn) == 0)
arch/powerpc/platforms/cell/celleb_scc_pciex.c:		*val = config_read_pciex_dev(phb->cfg_addr, bus->number,
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	if (bus->number == phb->first_busno && PCI_SLOT(devfn) != 1)
arch/powerpc/platforms/cell/celleb_scc_pciex.c:	if (bus->number == 0 && PCI_SLOT(devfn) == 0)
arch/powerpc/platforms/cell/celleb_scc_pciex.c:		config_write_pciex_dev(phb->cfg_addr, bus->number,
arch/powerpc/platforms/cell/setup.c:	if (dev->bus->self != NULL || dev->devfn != 0)
arch/powerpc/platforms/cell/spider-pci.c:	priv = bus->private;
arch/powerpc/platforms/cell/spider-pci.c:	struct device_node *np = bus->phb->dn;
arch/powerpc/platforms/cell/spider-pci.c:	bus->private = priv;
arch/powerpc/platforms/cell/spider-pci.c:	if (spiderpci_pci_setup_chip(bus->phb, regs))
arch/powerpc/platforms/cell/spider-pci.c:	bus->private = NULL;
arch/powerpc/platforms/chrp/pci.c:	if (bus->number > 7)
arch/powerpc/platforms/chrp/pci.c:	cfg_data = hose->cfg_data + ((bus->number<<16) | (devfn<<8) | off);
arch/powerpc/platforms/chrp/pci.c:	if (bus->number > 7)
arch/powerpc/platforms/chrp/pci.c:	cfg_data = hose->cfg_data + ((bus->number<<16) | (devfn<<8) | off);
arch/powerpc/platforms/chrp/pci.c:		| (((bus->number - hose->first_busno) & 0xff) << 16)
arch/powerpc/platforms/chrp/pci.c:		| (((bus->number - hose->first_busno) & 0xff) << 16)
arch/powerpc/platforms/chrp/pci.c:		bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/chrp/pci.c:			printk(KERN_WARNING "Can't get bus-range for %s\n",
arch/powerpc/platforms/embedded6xx/linkstation.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/embedded6xx/linkstation.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/platforms/embedded6xx/storcenter.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/maple/pci.c:		bus_range = of_get_property(node, "bus-range", &len);
arch/powerpc/platforms/maple/pci.c:/* This routine fixes the "bus-range" property of all bridges in the
arch/powerpc/platforms/maple/pci.c:	/* Lookup the "bus-range" property for the hose */
arch/powerpc/platforms/maple/pci.c:	prop = of_find_property(bridge, "bus-range", &len);
arch/powerpc/platforms/maple/pci.c:		printk(KERN_WARNING "Can't get bus-range for %s\n",
arch/powerpc/platforms/maple/pci.c:	addr = u3_agp_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:	addr = u3_agp_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:	if (bus->number == hose->first_busno && devfn == PCI_DEVFN(0, 0))
arch/powerpc/platforms/maple/pci.c:	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:	if (bus->number == hose->first_busno && devfn == PCI_DEVFN(0, 0))
arch/powerpc/platforms/maple/pci.c:	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:        addr = u4_pcie_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:        addr = u4_pcie_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/maple/pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/maple/pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume bus 0\n",
arch/powerpc/platforms/maple/pci.c:	/* Fixup "bus-range" OF property */
arch/powerpc/platforms/maple/pci.c:	if (u4_pcie != NULL && dev->bus->number == 0 &&
arch/powerpc/platforms/pasemi/gpio_mdio.c:#define MDC_PIN(bus)	(((struct gpio_priv *)bus->priv)->mdc_pin)
arch/powerpc/platforms/pasemi/gpio_mdio.c:#define MDIO_PIN(bus)	(((struct gpio_priv *)bus->priv)->mdio_pin)
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->name = "pasemi gpio mdio bus";
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->read = &gpio_mdio_read;
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->write = &gpio_mdio_write;
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->reset = &gpio_mdio_reset;
arch/powerpc/platforms/pasemi/gpio_mdio.c:	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%x", *prop);
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->priv = priv;
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->irq = priv->mdio_irqs;
arch/powerpc/platforms/pasemi/gpio_mdio.c:	new_bus->parent = dev;
arch/powerpc/platforms/pasemi/gpio_mdio.c:				new_bus->name, err);
arch/powerpc/platforms/pasemi/gpio_mdio.c:	kfree(bus->priv);
arch/powerpc/platforms/pasemi/gpio_mdio.c:	bus->priv = NULL;
arch/powerpc/platforms/pasemi/iommu.c:	pr_debug("pci_dma_bus_setup, bus %p, bus->self %p\n", bus, bus->self);
arch/powerpc/platforms/pasemi/pci.c:	if (!is_root_port(bus->number, devfn) || !is_5945_reg(offset))
arch/powerpc/platforms/pasemi/pci.c:	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset & ~0x3);
arch/powerpc/platforms/pasemi/pci.c:	dummy = pa_pxp_cfg_addr(hose, bus->number, devfn, 0x10);
arch/powerpc/platforms/pasemi/pci.c:	if (!pa_pxp_offset_valid(bus->number, devfn, offset))
arch/powerpc/platforms/pasemi/pci.c:	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
arch/powerpc/platforms/pasemi/pci.c:	if (!pa_pxp_offset_valid(bus->number, devfn, offset))
arch/powerpc/platforms/pasemi/pci.c:	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
arch/powerpc/platforms/pasemi/pci.c:	return (void __iomem *)pa_pxp_cfg_addr(hose, dev->bus->number, dev->devfn, offset);
arch/powerpc/platforms/powermac/low_i2c.c:	struct pmac_i2c_host_kw *host = bus->hostdata;
arch/powerpc/platforms/powermac/low_i2c.c:	struct pmac_i2c_host_kw *host = bus->hostdata;
arch/powerpc/platforms/powermac/low_i2c.c:	struct pmac_i2c_host_kw *host = bus->hostdata;
arch/powerpc/platforms/powermac/low_i2c.c:	int use_irq = host->irq != NO_IRQ && !bus->polled;
arch/powerpc/platforms/powermac/low_i2c.c:	switch(bus->mode) {
arch/powerpc/platforms/powermac/low_i2c.c:	kw_write_reg(reg_mode, mode_reg | (bus->channel << 4));
arch/powerpc/platforms/powermac/low_i2c.c:	host->polled = bus->polled;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->controller = of_node_get(controller);
arch/powerpc/platforms/powermac/low_i2c.c:	bus->busnode = of_node_get(busnode);
arch/powerpc/platforms/powermac/low_i2c.c:	bus->type = pmac_i2c_bus_keywest;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->hostdata = host;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->channel = channel;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->mode = pmac_i2c_mode_std;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->open = kw_i2c_open;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->close = kw_i2c_close;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->xfer = kw_i2c_xfer;
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_init(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:		bus->flags = pmac_i2c_multibus;
arch/powerpc/platforms/powermac/low_i2c.c:	list_add(&bus->link, &pmac_i2c_busses);
arch/powerpc/platforms/powermac/low_i2c.c:	struct adb_request *req = bus->hostdata;
arch/powerpc/platforms/powermac/low_i2c.c:		hdr->bus = bus->channel;
arch/powerpc/platforms/powermac/low_i2c.c:		switch(bus->mode) {
arch/powerpc/platforms/powermac/low_i2c.c:			if (bus->mode == pmac_i2c_mode_stdsub)
arch/powerpc/platforms/powermac/low_i2c.c:		bus->controller = busnode;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->busnode = busnode;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->type = pmac_i2c_bus_pmu;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->channel = channel;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->mode = pmac_i2c_mode_std;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->hostdata = bus + 1;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->xfer = pmu_i2c_xfer;
arch/powerpc/platforms/powermac/low_i2c.c:		mutex_init(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:		bus->flags = pmac_i2c_multibus;
arch/powerpc/platforms/powermac/low_i2c.c:		list_add(&bus->link, &pmac_i2c_busses);
arch/powerpc/platforms/powermac/low_i2c.c:	struct smu_i2c_cmd *cmd = bus->hostdata;
arch/powerpc/platforms/powermac/low_i2c.c:	cmd->info.bus = bus->channel;
arch/powerpc/platforms/powermac/low_i2c.c:	switch(bus->mode) {
arch/powerpc/platforms/powermac/low_i2c.c:		if (bus->mode == pmac_i2c_mode_stdsub)
arch/powerpc/platforms/powermac/low_i2c.c:		bus->controller = controller;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->busnode = of_node_get(busnode);
arch/powerpc/platforms/powermac/low_i2c.c:		bus->type = pmac_i2c_bus_smu;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->channel = *reg;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->mode = pmac_i2c_mode_std;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->hostdata = bus + 1;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->xfer = smu_i2c_xfer;
arch/powerpc/platforms/powermac/low_i2c.c:		mutex_init(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:		bus->flags = 0;
arch/powerpc/platforms/powermac/low_i2c.c:		list_add(&bus->link, &pmac_i2c_busses);
arch/powerpc/platforms/powermac/low_i2c.c:		       bus->channel, busnode->full_name);
arch/powerpc/platforms/powermac/low_i2c.c:			if (p == bus->busnode) {
arch/powerpc/platforms/powermac/low_i2c.c:				if (prev && bus->flags & pmac_i2c_multibus) {
arch/powerpc/platforms/powermac/low_i2c.c:					if (((*reg) >> 8) != bus->channel)
arch/powerpc/platforms/powermac/low_i2c.c:	return bus->controller;
arch/powerpc/platforms/powermac/low_i2c.c:	return bus->busnode;
arch/powerpc/platforms/powermac/low_i2c.c:	return bus->type;
arch/powerpc/platforms/powermac/low_i2c.c:	return bus->flags;
arch/powerpc/platforms/powermac/low_i2c.c:	return bus->channel;
arch/powerpc/platforms/powermac/low_i2c.c:	return &bus->adapter;
arch/powerpc/platforms/powermac/low_i2c.c:		if (&bus->adapter == adapter)
arch/powerpc/platforms/powermac/low_i2c.c:	return (&bus->adapter == adapter);
arch/powerpc/platforms/powermac/low_i2c.c:		if (np == bus->controller) {
arch/powerpc/platforms/powermac/low_i2c.c:		if (np == bus->controller) {
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_lock(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	bus->polled = polled || pmac_i2c_force_poll;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->opened = 1;
arch/powerpc/platforms/powermac/low_i2c.c:	bus->mode = pmac_i2c_mode_std;
arch/powerpc/platforms/powermac/low_i2c.c:	if (bus->open && (rc = bus->open(bus)) != 0) {
arch/powerpc/platforms/powermac/low_i2c.c:		bus->opened = 0;
arch/powerpc/platforms/powermac/low_i2c.c:		mutex_unlock(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	WARN_ON(!bus->opened);
arch/powerpc/platforms/powermac/low_i2c.c:	if (bus->close)
arch/powerpc/platforms/powermac/low_i2c.c:		bus->close(bus);
arch/powerpc/platforms/powermac/low_i2c.c:	bus->opened = 0;
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_unlock(&bus->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	WARN_ON(!bus->opened);
arch/powerpc/platforms/powermac/low_i2c.c:		       " bus %s !\n", mode, bus->busnode->full_name);
arch/powerpc/platforms/powermac/low_i2c.c:	bus->mode = mode;
arch/powerpc/platforms/powermac/low_i2c.c:	WARN_ON(!bus->opened);
arch/powerpc/platforms/powermac/low_i2c.c:	    " %d bytes, bus %s\n", bus->channel, addrdir, bus->mode, subsize,
arch/powerpc/platforms/powermac/low_i2c.c:	    subaddr, len, bus->busnode->full_name);
arch/powerpc/platforms/powermac/low_i2c.c:	rc = bus->xfer(bus, addrdir, subsize, subaddr, data, len);
arch/powerpc/platforms/powermac/low_i2c.c:		     (np = of_get_next_child(bus->busnode, np)) != NULL;) {
arch/powerpc/platforms/powermac/low_i2c.c:			if (bus->flags & pmac_i2c_multibus)
arch/powerpc/platforms/powermac/low_i2c.c:		bus->platform_dev =
arch/powerpc/platforms/powermac/low_i2c.c:		if (bus->platform_dev == NULL)
arch/powerpc/platforms/powermac/low_i2c.c:		bus->platform_dev->dev.platform_data = bus;
arch/powerpc/platforms/powermac/low_i2c.c:		bus->platform_dev->dev.of_node = bus->busnode;
arch/powerpc/platforms/powermac/low_i2c.c:		platform_device_add(bus->platform_dev);
arch/powerpc/platforms/powermac/pci.c:		bus_range = of_get_property(node, "bus-range", &len);
arch/powerpc/platforms/powermac/pci.c:/* This routine fixes the "bus-range" property of all bridges in the
arch/powerpc/platforms/powermac/pci.c:	/* Lookup the "bus-range" property for the hose */
arch/powerpc/platforms/powermac/pci.c:	prop = of_find_property(bridge, "bus-range", &len);
arch/powerpc/platforms/powermac/pci.c:	addr = macrisc_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/powermac/pci.c:	addr = macrisc_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/powermac/pci.c:	np = of_pci_find_child_device(bus->dev.of_node, devfn);
arch/powerpc/platforms/powermac/pci.c:	if (bus->self)
arch/powerpc/platforms/powermac/pci.c:		busdn = pci_device_to_OF_node(bus->self);
arch/powerpc/platforms/powermac/pci.c:	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset, &swap);
arch/powerpc/platforms/powermac/pci.c:	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset, &swap);
arch/powerpc/platforms/powermac/pci.c:	addr = u4_pcie_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/powermac/pci.c:	addr = u4_pcie_cfg_access(hose, bus->number, devfn, offset);
arch/powerpc/platforms/powermac/pci.c:	 * config cycles to be type 1. So we override the "bus-range"
arch/powerpc/platforms/powermac/pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/platforms/powermac/pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/platforms/powermac/pci.c:	/* Fixup "bus-range" OF property */
arch/powerpc/platforms/powermac/setup.c:	if (bus->self == NULL && (of_device_is_compatible(node, "u3-agp") ||
arch/powerpc/platforms/powernv/eeh-ioda.c:		 __func__, hose->global_number, dev->bus->number,
arch/powerpc/platforms/powernv/eeh-ioda.c:			dev = dev->bus->self;
arch/powerpc/platforms/powernv/eeh-ioda.c:			dev = pe->bus->self;
arch/powerpc/platforms/powernv/eeh-ioda.c:		if (dev->bus->number == 0)
arch/powerpc/platforms/powernv/eeh-powernv.c:	edev->config_addr	= ((dev->bus->number << 8) | dev->devfn);
arch/powerpc/platforms/powernv/pci-ioda.c:			pe->pbus->number);			\
arch/powerpc/platforms/powernv/pci-ioda.c:		parent = pe->pbus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:			count = pe->pbus->busn_res.end - pe->pbus->busn_res.start + 1;
arch/powerpc/platforms/powernv/pci-ioda.c:			       pci_name(pe->pbus->self), count);
arch/powerpc/platforms/powernv/pci-ioda.c:		parent = pe->pdev->bus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:		parent = parent->bus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:	if (dev->bus->number == 0)
arch/powerpc/platforms/powernv/pci-ioda.c:	pe->rid = dev->bus->number << 8 | pdn->devfn;
arch/powerpc/platforms/powernv/pci-ioda.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/platforms/powernv/pci-ioda.c:			__func__, pci_domain_nr(bus), bus->number);
arch/powerpc/platforms/powernv/pci-ioda.c:	pe->rid = bus->busn_res.start << 8;
arch/powerpc/platforms/powernv/pci-ioda.c:			bus->busn_res.start, bus->busn_res.end, pe_num);
arch/powerpc/platforms/powernv/pci-ioda.c:			bus->busn_res.start, pe_num);
arch/powerpc/platforms/powernv/pci-ioda.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/platforms/powernv/pci-ioda.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/powerpc/platforms/powernv/pci-ioda.c:	bridge = bus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:		bridge = bridge->bus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:	return phb->ioda.pe_rmap[(bus->number << 8) | devfn];
arch/powerpc/platforms/powernv/pci-ioda.c:	prop32 = of_get_property(np, "bus-range", &len);
arch/powerpc/platforms/powernv/pci-ioda.c:		pr_warn("  Broken <bus-range> on %s\n", np->full_name);
arch/powerpc/platforms/pseries/iommu.c:	tbl->it_busno = phb->bus->number;
arch/powerpc/platforms/pseries/iommu.c:	tbl->it_busno = phb->bus->number;
arch/powerpc/platforms/pseries/iommu.c:	if (bus->self) {
arch/powerpc/platforms/pseries/iommu.c:	if (!dev->bus->self) {
arch/powerpc/platforms/pseries/msi.c:				if (pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT)
arch/powerpc/platforms/pseries/pci.c:		    && dev->bus->number == 0 && dev->devfn == 0x81)
arch/powerpc/platforms/pseries/pci.c:		bus->max_bus_speed = PCIE_SPEED_2_5GT;
arch/powerpc/platforms/pseries/pci.c:		bus->max_bus_speed = PCIE_SPEED_5_0GT;
arch/powerpc/platforms/pseries/pci.c:		bus->max_bus_speed = PCI_SPEED_UNKNOWN;
arch/powerpc/platforms/pseries/pci.c:		bus->cur_bus_speed = PCIE_SPEED_2_5GT;
arch/powerpc/platforms/pseries/pci.c:		bus->cur_bus_speed = PCIE_SPEED_5_0GT;
arch/powerpc/platforms/pseries/pci.c:		bus->cur_bus_speed = PCI_SPEED_UNKNOWN;
arch/powerpc/platforms/pseries/pci_dlpar.c:	list_for_each(tmp, &bus->children) {
arch/powerpc/platforms/wsp/wsp_pci.c:		((u64)bus->number) << PCIE_REG_CA_BUS_SHIFT |
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:		((u64)bus->number) << PCIE_REG_CA_BUS_SHIFT |
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:			  bus->number, devfn >> 3, devfn & 7,
arch/powerpc/platforms/wsp/wsp_pci.c:			tvt_data0 |= validate->bus->number;
arch/powerpc/platforms/wsp/wsp_pci.c:	phb = bus->private;					\
arch/powerpc/platforms/wsp/wsp_pci.c:	phb = bus->private;					\
arch/powerpc/platforms/wsp/wsp_pci.c:	/* XXX Use bus-range property ? */
arch/powerpc/sysdev/fsl_pci.c:	 * has bus->resource[0..4] set, so things are a bit more
arch/powerpc/sysdev/fsl_pci.c:	if (bus->parent == hose->bus && (is_pcie || no_link)) {
arch/powerpc/sysdev/fsl_pci.c:			struct resource *res = bus->resource[i];
arch/powerpc/sysdev/fsl_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/sysdev/fsl_pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/sysdev/fsl_pci.c:	if (bus->number == hose->first_busno ||
arch/powerpc/sysdev/fsl_pci.c:			bus->primary == hose->first_busno) {
arch/powerpc/sysdev/fsl_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/sysdev/fsl_pci.c:	u32 dev_base = bus->number << 24 | devfn << 16;
arch/powerpc/sysdev/fsl_pci.c:	if (bus->number == hose->first_busno)
arch/powerpc/sysdev/fsl_pci.c:	if (offset == PCI_PRIMARY_BUS && bus->number == hose->first_busno)
arch/powerpc/sysdev/fsl_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/sysdev/fsl_pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/sysdev/fsl_soc.c:		prop = of_get_property(soc, "bus-frequency", &size);
arch/powerpc/sysdev/fsl_soc.c:			prop = of_get_property(node, "bus-frequency", &size);
arch/powerpc/sysdev/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/powerpc/sysdev/indirect_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/sysdev/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/powerpc/sysdev/indirect_pci.c:	bus_no = (bus->number == hose->first_busno) ?
arch/powerpc/sysdev/indirect_pci.c:			hose->self_busno : bus->number;
arch/powerpc/sysdev/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/powerpc/sysdev/indirect_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/sysdev/indirect_pci.c:		if (bus->number != hose->first_busno)
arch/powerpc/sysdev/indirect_pci.c:	bus_no = (bus->number == hose->first_busno) ?
arch/powerpc/sysdev/indirect_pci.c:			hose->self_busno : bus->number;
arch/powerpc/sysdev/indirect_pci.c:			(bus->number == hose->first_busno))
arch/powerpc/sysdev/mpc5xxx_clocks.c:		p_bus_freq = of_get_property(node, "bus-frequency", NULL);
arch/powerpc/sysdev/mpic_u3msi.c:	for (bus = pdev->bus; bus && bus->self; bus = bus->parent) {
arch/powerpc/sysdev/mpic_u3msi.c:		pos = pci_find_ht_capability(bus->self, HT_CAPTYPE_MSI_MAPPING);
arch/powerpc/sysdev/mpic_u3msi.c:			return read_ht_magic_addr(bus->self, pos);
arch/powerpc/sysdev/mv64x60_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/sysdev/mv64x60_pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/sysdev/ppc4xx_pci.c:	if (dev->devfn != 0 || dev->bus->self != NULL)
arch/powerpc/sysdev/ppc4xx_pci.c:	bus_range = of_get_property(np, "bus-range", NULL);
arch/powerpc/sysdev/ppc4xx_pci.c:	bus_range = of_get_property(np, "bus-range", NULL);
arch/powerpc/sysdev/ppc4xx_pci.c:	if (port->endpoint && bus->number != port->hose->first_busno)
arch/powerpc/sysdev/ppc4xx_pci.c:	if (bus->number > port->hose->last_busno) {
arch/powerpc/sysdev/ppc4xx_pci.c:			       " out of range !\n", bus->number);
arch/powerpc/sysdev/ppc4xx_pci.c:	if (bus->number == port->hose->first_busno && devfn != 0)
arch/powerpc/sysdev/ppc4xx_pci.c:	if (bus->number == (port->hose->first_busno + 1) &&
arch/powerpc/sysdev/ppc4xx_pci.c:	if ((bus->number != port->hose->first_busno) && !port->link)
arch/powerpc/sysdev/ppc4xx_pci.c:	if (bus->number == port->hose->first_busno)
arch/powerpc/sysdev/ppc4xx_pci.c:	relbus = bus->number - (port->hose->first_busno + 1);
arch/powerpc/sysdev/ppc4xx_pci.c:		 bus->number, hose->first_busno, hose->last_busno,
arch/powerpc/sysdev/ppc4xx_pci.c:		 bus->number, hose->first_busno, hose->last_busno,
arch/powerpc/sysdev/ppc4xx_pci.c:	bus_range = of_get_property(port->node, "bus-range", NULL);
arch/powerpc/sysdev/tsi108_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfunc))
arch/powerpc/sysdev/tsi108_pci.c:	cfg_addr = (unsigned char *)(tsi_mk_config_addr(bus->number,
arch/powerpc/sysdev/tsi108_pci.c:	printk("%d:0x%x:0x%x ", bus->number, devfunc, offset);
arch/powerpc/sysdev/tsi108_pci.c:		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
arch/powerpc/sysdev/tsi108_pci.c:	cfg_addr = (unsigned char *)(tsi_mk_config_addr(bus->number,
arch/powerpc/sysdev/tsi108_pci.c:		printk("%d:0x%x:0x%x ", bus->number, devfn, offset);
arch/powerpc/sysdev/tsi108_pci.c:	bus_range = of_get_property(dev, "bus-range", &len);
arch/powerpc/sysdev/tsi108_pci.c:		printk(KERN_WARNING "Can't get bus-range for %s, assume"
arch/powerpc/sysdev/xilinx_pci.c:	if (dev->devfn || dev->bus->self)
arch/s390/pci/pci.c:	return (bus && bus->sysdata) ? (struct zpci_dev *) bus->sysdata : NULL;
arch/s390/pci/pci.c:	return ((struct zpci_dev *) bus->sysdata)->domain;
arch/s390/pci/pci.c:	zdev->bus->max_bus_speed = zdev->max_bus_speed;
arch/sh/drivers/pci/fixups-cayman.c:	while (dev->bus->number > 0) {
arch/sh/drivers/pci/fixups-cayman.c:		dev = dev->bus->self;
arch/sh/drivers/pci/fixups-sh03.c:	if (dev->bus->number == 0) {
arch/sh/drivers/pci/ops-dreamcast.c:	if (!gapspci_config_access(bus->number, devfn))
arch/sh/drivers/pci/ops-dreamcast.c:	if (!gapspci_config_access(bus->number, devfn))
arch/sh/drivers/pci/ops-sh4.c:	(0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
arch/sh/drivers/pci/ops-sh4.c:	struct pci_channel *chan = bus->sysdata;
arch/sh/drivers/pci/ops-sh4.c:	struct pci_channel *chan = bus->sysdata;
arch/sh/drivers/pci/ops-sh7786.c:	struct pci_channel *chan = bus->sysdata;
arch/sh/drivers/pci/ops-sh7786.c:	type = !!bus->parent;
arch/sh/drivers/pci/ops-sh7786.c:	if (bus->number > 255 || dev > 31 || func > 7)
arch/sh/drivers/pci/ops-sh7786.c:	pci_write_reg(chan, (bus->number << 24) | (dev << 19) |
arch/sh/drivers/pci/ops-sh7786.c:	dev_dbg(&bus->dev, "pcie-config-read: bus=%3d devfn=0x%04x "
arch/sh/drivers/pci/ops-sh7786.c:		"where=0x%04x size=%d val=0x%08lx\n", bus->number,
arch/sh/drivers/pci/ops-sh7786.c:	dev_dbg(&bus->dev, "pcie-config-write: bus=%3d devfn=0x%04x "
arch/sh/drivers/pci/ops-sh7786.c:		"where=0x%04x size=%d val=%08lx\n", bus->number,
arch/sh/drivers/pci/pci-sh5.h:#define CONFIG_CMD(bus, devfn, where)            SET_CONFIG_BITS(bus->number,devfn,where)
arch/sh/drivers/pci/pci.c:		next_busno = bus->busn_res.end + 1;
arch/sh/drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/sh/drivers/pci/pci.c:		if (dev->bus->number == 0 && dev->devfn == 0)
arch/sh/drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list)
arch/sh/drivers/pci/pcie-sh7786.h:/* PCIe bus-0(x4) on SH7786 */			// Rev1.171
arch/sh/include/asm/pci.h:	struct pci_channel *hose = bus->sysdata;
arch/sparc/include/asm/auxio_64.h: * sbus-based NCR89C105 "Slavio"
arch/sparc/include/asm/auxio_64.h: * ebus-based auxio on PCIO
arch/sparc/kernel/leon_pci.c:	list_for_each_entry(dev, &pbus->devices, bus_list) {
arch/sparc/kernel/leon_pci_grpci1.c:	struct grpci1_priv *priv = dev->bus->sysdata;
arch/sparc/kernel/leon_pci_grpci1.c:	unsigned int busno = bus->number;
arch/sparc/kernel/leon_pci_grpci1.c:	unsigned int busno = bus->number;
arch/sparc/kernel/leon_pci_grpci2.c:	struct grpci2_priv *priv = dev->bus->sysdata;
arch/sparc/kernel/leon_pci_grpci2.c:	unsigned int busno = bus->number;
arch/sparc/kernel/leon_pci_grpci2.c:	unsigned int busno = bus->number;
arch/sparc/kernel/of_device_32.c:		if (!bus->map(addr, ranges, na, ns, pna))
arch/sparc/kernel/of_device_32.c:	bus->count_cells(op->dev.of_node, &na, &ns);
arch/sparc/kernel/of_device_32.c:	preg = of_get_property(op->dev.of_node, bus->addr_prop_name, &num_reg);
arch/sparc/kernel/of_device_32.c:		flags = bus->get_flags(reg, 0);
arch/sparc/kernel/of_device_32.c:			pbus->count_cells(dp, &pna, &pns);
arch/sparc/kernel/of_device_32.c:			flags = pbus->get_flags(addr, flags);
arch/sparc/kernel/of_device_64.c:		if (!bus->map(addr, ranges, na, ns, pna))
arch/sparc/kernel/of_device_64.c:	if (!strcmp(bus->name, "pci") &&
arch/sparc/kernel/of_device_64.c:	bus->count_cells(op->dev.of_node, &na, &ns);
arch/sparc/kernel/of_device_64.c:	preg = of_get_property(op->dev.of_node, bus->addr_prop_name, &num_reg);
arch/sparc/kernel/of_device_64.c:		flags = bus->get_flags(addr, 0);
arch/sparc/kernel/of_device_64.c:			pbus->count_cells(dp, &pna, &pns);
arch/sparc/kernel/of_device_64.c:			flags = pbus->get_flags(addr, flags);
arch/sparc/kernel/of_device_64.c:	bus->count_cells(dp, &na, NULL);
arch/sparc/kernel/of_device_common.c:	struct dev_archdata *bus_sd = &bus->dev.archdata;
arch/sparc/kernel/of_device_common.c:	struct device_node *bus_dp = bus->dev.of_node;
arch/sparc/kernel/pci.c:	dev->dev.parent = bus->bridge;
arch/sparc/kernel/pci.c:	list_for_each_entry(slot, &dev->bus->slots, list)
arch/sparc/kernel/pci.c:		dev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));
arch/sparc/kernel/pci.c:	res = bus->resource[0];
arch/sparc/kernel/pci.c:	res = bus->resource[1];
arch/sparc/kernel/pci.c:	/* parse bus-range property */
arch/sparc/kernel/pci.c:	busrange = of_get_property(node, "bus-range", &len);
arch/sparc/kernel/pci.c:		printk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %s\n",
arch/sparc/kernel/pci.c:	bus->primary = dev->bus->number;
arch/sparc/kernel/pci.c:	bus->bridge_ctl = 0;
arch/sparc/kernel/pci.c:		bus->resource[i] = res;
arch/sparc/kernel/pci.c:			res = bus->resource[0];
arch/sparc/kernel/pci.c:			res = bus->resource[i];
arch/sparc/kernel/pci.c:	sprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),
arch/sparc/kernel/pci.c:		bus->number);
arch/sparc/kernel/pci.c:		printk("    bus name: %s\n", bus->name);
arch/sparc/kernel/pci.c:		       node->full_name, bus->number);
arch/sparc/kernel/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/sparc/kernel/pci.c:	list_for_each_entry(child_bus, &bus->children, node)
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pbus->sysdata;
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pbus->sysdata;
arch/sparc/kernel/pci.c:		if (pbus->self) {
arch/sparc/kernel/pci.c:			node = pbus->self->dev.of_node;
arch/sparc/kernel/pci.c:			struct pci_pbm_info *pbm = pbus->sysdata;
arch/sparc/kernel/pci_common.c:	const u32 *val = of_get_property(pbm->op->dev.of_node, "bus-range", NULL);
arch/sparc/kernel/pci_common.c:	list_for_each_entry(pdev, &pbus->devices, bus_list) {
arch/sparc/kernel/pci_common.c:	list_for_each_entry(bus, &pbus->children, node)
arch/sparc/kernel/pci_common.c:	list_for_each_entry(pdev, &pbus->devices, bus_list) {
arch/sparc/kernel/pci_common.c:	list_for_each_entry(bus, &pbus->children, node)
arch/sparc/kernel/pci_common.c:	list_for_each_entry(pdev, &pbus->devices, bus_list) {
arch/sparc/kernel/pci_common.c:	list_for_each_entry(bus, &pbus->children, node)
arch/sparc/kernel/pci_sabre.c:#define  SABRE_PCICTRL_ARBPARK	 0x0000000000200000UL	/* Bus Parking 0=Ultra-IIi 1=prev-bus-owner */
arch/sparc/kernel/pci_sabre.c:	list_for_each_entry(pdev, &sabre_bus->devices, bus_list) {
arch/sparc/kernel/pci_schizo.c:	pci_read_config_word(pbm->pci_bus->self, PCI_STATUS, &stat);
arch/sparc/kernel/pci_schizo.c:		pci_write_config_word(pbm->pci_bus->self, PCI_STATUS, 0xffff);
arch/sparc/kernel/pci_schizo.c:	if (!of_find_property(pbm->op->dev.of_node, "no-bus-parking", NULL))
arch/sparc/kernel/pcic.c:	if (bus->number != 0) return -EINVAL;
arch/sparc/kernel/pcic.c:		pcic_read_config_dword(bus->number, devfn, where&~3, &v);
arch/sparc/kernel/pcic.c:		pcic_read_config_dword(bus->number, devfn, where&~3, &v);
arch/sparc/kernel/pcic.c:		pcic_read_config_dword(bus->number, devfn, where&~3, val);
arch/sparc/kernel/pcic.c:	if (bus->number != 0) return -EINVAL;
arch/sparc/kernel/pcic.c:		pcic_read_config_dword(bus->number, devfn, where&~3, &v);
arch/sparc/kernel/pcic.c:		return pcic_write_config_dword(bus->number, devfn, where&~3, v);
arch/sparc/kernel/pcic.c:		pcic_read_config_dword(bus->number, devfn, where&~3, &v);
arch/sparc/kernel/pcic.c:		return pcic_write_config_dword(bus->number, devfn, where&~3, v);
arch/sparc/kernel/pcic.c:		return pcic_write_config_dword(bus->number, devfn, where, val);
arch/sparc/kernel/pcic.c:				    namebuf, dev->bus->number, dev->devfn);
arch/sparc/kernel/pcic.c:		if (p->busno == dev->bus->number && p->devfn == dev->devfn)
arch/sparc/kernel/pcic.c:		    namebuf, dev->bus->number, dev->devfn, pcic->pcic_imdim);
arch/sparc/kernel/pcic.c:		    p->irq, p->pin, dev->bus->number, dev->devfn);
arch/sparc/kernel/pcic.c:	if (bus->number != 0) {
arch/sparc/kernel/pcic.c:		printk("pcibios_fixup_bus: nonzero bus 0x%x\n", bus->number);
arch/sparc/kernel/pcic.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/sparc/kernel/pcic.c:				dev->bus->number, dev->devfn);
arch/sparc/kernel/pcic.c:				dev->bus->number, dev->devfn);
arch/sparc/kernel/prom_irqtrans.c:	busrange = of_get_property(dp, "bus-range", NULL);
arch/sparc/kernel/sun4d_irq.c:		if (!strcmp(bus->name, "sbi")) {
arch/sparc/kernel/sun4d_irq.c:		if (!strcmp(bus->name, "bootbus")) {
arch/sparc/kernel/sun4d_irq.c:		bus = bus->parent;
arch/sparc/kernel/sun4d_irq.c:	if (!bus->parent || strcmp(bus->parent->name, bus_connection)) {
arch/sparc/kernel/sun4d_irq.c:			bus->full_name, bus_connection);
arch/sparc/kernel/sun4d_irq.c:	board_parent = bus->parent;
arch/tile/include/gxio/trio.h: * tile-side buffer VAs to be mapped to that region, and a bus-mapped
arch/tile/kernel/pci.c:			controller->last_busno = bus->busn_res.end;
arch/tile/kernel/pci.c:			list_for_each_entry(dev, &root_bus->devices, bus_list) {
arch/tile/kernel/pci.c:						*next_bus->resource[0];
arch/tile/kernel/pci.c:						 *next_bus->resource[1];
arch/tile/kernel/pci.c:						 *next_bus->resource[2];
arch/tile/kernel/pci.c:	struct pci_controller *controller = bus->sysdata;
arch/tile/kernel/pci.c:	int busnum = bus->number & 0xff;
arch/tile/kernel/pci.c:	struct pci_controller *controller = bus->sysdata;
arch/tile/kernel/pci.c:	int busnum = bus->number & 0xff;
arch/tile/kernel/pci_gx.c:	list_for_each_entry(child, &root_bus->children, node)
arch/tile/kernel/pci_gx.c:		next_busno = bus->busn_res.end + 1;
arch/tile/kernel/pci_gx.c:	struct pci_controller *controller = bus->sysdata;
arch/tile/kernel/pci_gx.c:	int busnum = bus->number & 0xff;
arch/tile/kernel/pci_gx.c:	struct pci_controller *controller = bus->sysdata;
arch/tile/kernel/pci_gx.c:	int busnum = bus->number & 0xff;
arch/unicore32/include/mach/memory.h:				(strncmp(dev->bus->name, "pci", 3) == 0))
arch/unicore32/kernel/pci.c:	(0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
arch/unicore32/kernel/pci.c:	if (dev->bus->number == 0) {
arch/unicore32/kernel/pci.c:	bus->resource[0] = &ioport_resource;
arch/unicore32/kernel/pci.c:	bus->resource[1] = &iomem_resource;
arch/unicore32/kernel/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/unicore32/kernel/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/unicore32/kernel/pci.c:	if (bus->self && bus->self->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
arch/unicore32/kernel/pci.c:			bus->bridge_ctl |= PCI_BRIDGE_CTL_FAST_BACK;
arch/unicore32/kernel/pci.c:			bus->bridge_ctl |= PCI_BRIDGE_CTL_PARITY;
arch/unicore32/kernel/pci.c:		bus->number, (features & PCI_COMMAND_FAST_BACK) ? "en" : "dis");
arch/x86/include/asm/pci.h:	struct pci_sysdata *sd = bus->sysdata;
arch/x86/include/asm/pci.h:	const struct pci_sysdata *sd = bus->sysdata;
arch/x86/include/asm/pci_64.h:	struct pci_sysdata *sd = bus->sysdata;
arch/x86/include/asm/pci_64.h:	struct pci_sysdata *sd = bus->sysdata;
arch/x86/kernel/acpi/boot.c:	number = pdev->bus->number;
arch/x86/kernel/apic/io_apic.c:		case 0: /* conforms, ie. bus-type dependent polarity */
arch/x86/kernel/apic/io_apic.c:		case 0: /* conforms, ie. bus-type dependent */
arch/x86/kernel/apic/x2apic_uv_x.c:	bus = pdev->bus->number;
arch/x86/kernel/cpu/perf_event.c:EVENT_ATTR(bus-cycles,			BUS_CYCLES		);
arch/x86/kernel/cpu/perf_event_intel_uncore.c:		bus = ubox_dev->bus->number;
arch/x86/kernel/cpu/perf_event_intel_uncore.c:		for (bus = 255; bus >= 0; bus--) {
arch/x86/kernel/cpu/perf_event_intel_uncore.c:	phys_id = pcibus_to_physid[pdev->bus->number];
arch/x86/kernel/cpu/perf_event_intel_uncore.c:	int i, cpu, phys_id = pcibus_to_physid[pdev->bus->number];
arch/x86/kernel/devicetree.c:		prop = of_get_property(np, "bus-range", NULL);
arch/x86/kernel/devicetree.c:		if (bus->number == bus_min)
arch/x86/kernel/io_delay.c:		 * note that udelay doesn't have the bus-level
arch/x86/kernel/pci-calgary_64.c:		if (tbl && tbl->it_busno == pbus->number)
arch/x86/kernel/pci-calgary_64.c:		pbus = pbus->parent;
arch/x86/kernel/pci-calgary_64.c:	BUG_ON(tbl && (tbl->it_busno != pbus->number));
arch/x86/kernel/pci-calgary_64.c:	unsigned char busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	unsigned char busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	tbl->it_base = (unsigned long)bus_info[dev->bus->number].tce_space;
arch/x86/kernel/pci-calgary_64.c:	target = calgary_reg(bbar, tar_offset(dev->bus->number));
arch/x86/kernel/pci-calgary_64.c:	target = calgary_reg(tbl->bbar, tar_offset(dev->bus->number));
arch/x86/kernel/pci-calgary_64.c:	bus_info[dev->bus->number].tce_space = NULL;
arch/x86/kernel/pci-calgary_64.c:	unsigned char busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	unsigned char busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	busnum = dev->bus->number;
arch/x86/kernel/pci-calgary_64.c:	if (dev->bus->parent)
arch/x86/kernel/pci-calgary_64.c:		dev->bus->parent->self = dev;
arch/x86/kernel/pci-calgary_64.c:		dev->bus->self = dev;
arch/x86/kernel/pci-calgary_64.c:	bbar = busno_to_bbar(dev->bus->number);
arch/x86/kernel/pci-calgary_64.c:	if (dev->bus->parent) {
arch/x86/kernel/pci-calgary_64.c:		if (dev->bus->parent->self)
arch/x86/kernel/pci-calgary_64.c:			       "bus->parent->self!\n", dev);
arch/x86/kernel/pci-calgary_64.c:		dev->bus->parent->self = dev;
arch/x86/kernel/pci-calgary_64.c:		dev->bus->self = dev;
arch/x86/kernel/pci-calgary_64.c:		info = &bus_info[dev->bus->number];
arch/x86/kernel/pci-calgary_64.c:		info = &bus_info[dev->bus->number];
arch/x86/kernel/pci-calgary_64.c:		info = &bus_info[dev->bus->number];
arch/x86/kernel/tce_64.c:	tbl->it_busno = dev->bus->number;
arch/x86/pci/acpi.c:		 * If the desired bus exits, the content of bus->sysdata will
arch/x86/pci/acpi.c:		memcpy(bus->sysdata, sd, sizeof(*sd));
arch/x86/pci/acpi.c:				to_pci_host_bridge(bus->bridge),
arch/x86/pci/acpi.c:		list_for_each_entry(child, &bus->children, node)
arch/x86/pci/acpi.c:			dev_printk(KERN_DEBUG, &bus->dev,
arch/x86/pci/acpi.c:		dev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);
arch/x86/pci/acpi.c:	struct pci_sysdata *sd = bridge->bus->sysdata;
arch/x86/pci/common.c:	return raw_pci_read(pci_domain_nr(bus), bus->number,
arch/x86/pci/common.c:	return raw_pci_write(pci_domain_nr(bus), bus->number,
arch/x86/pci/common.c:		if (bus->number == busnum) {
arch/x86/pci/common.c:			    (dev->bus->number == rom->bus) &&
arch/x86/pci/fixup.c:	return raw_pci_read(pci_domain_nr(bus), bus->number,
arch/x86/pci/fixup.c:	offset = quirk_aspm_offset[GET_INDEX(bus->self->device, devfn)];
arch/x86/pci/fixup.c:	return raw_pci_write(pci_domain_nr(bus), bus->number,
arch/x86/pci/fixup.c:	if (list_empty(&pbus->devices)) {
arch/x86/pci/fixup.c:		 * after hot-remove, the pbus->devices is empty and this code
arch/x86/pci/fixup.c:		pci_bus_set_ops(pbus, pbus->parent->ops);
arch/x86/pci/fixup.c:		list_for_each_entry(dev, &pbus->devices, bus_list)
arch/x86/pci/fixup.c:		dev_info(&pbus->dev, "writes to ASPM control bits will be ignored\n");
arch/x86/pci/fixup.c:		bridge = bus->self;
arch/x86/pci/fixup.c:		bus = bus->parent;
arch/x86/pci/i386.c:	    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))
arch/x86/pci/i386.c:	if (bus->self)
arch/x86/pci/i386.c:		pcibios_allocate_bridge_resources(bus->self);
arch/x86/pci/i386.c:	list_for_each_entry(child, &bus->children, node)
arch/x86/pci/i386.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/x86/pci/i386.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
arch/x86/pci/i386.c:	dev_printk(KERN_DEBUG, &bus->dev, "Allocating resources\n");
arch/x86/pci/intel_mid_pci.c:		if (raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,
arch/x86/pci/intel_mid_pci.c:			raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,
arch/x86/pci/intel_mid_pci.c:	busnum = bus->number;
arch/x86/pci/intel_mid_pci.c:	if (type1_access_ok(bus->number, devfn, where))
arch/x86/pci/intel_mid_pci.c:		return pci_direct_conf1.read(pci_domain_nr(bus), bus->number,
arch/x86/pci/intel_mid_pci.c:	return raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,
arch/x86/pci/intel_mid_pci.c:	if (type1_access_ok(bus->number, devfn, where))
arch/x86/pci/intel_mid_pci.c:		return pci_direct_conf1.write(pci_domain_nr(bus), bus->number,
arch/x86/pci/intel_mid_pci.c:	return raw_pci_ext_ops->write(pci_domain_nr(bus), bus->number, devfn,
arch/x86/pci/intel_mid_pci.c:	if (type1_access_ok(dev->bus->number, dev->devfn, PCI_DEVICE_ID))
arch/x86/pci/irq.c:		if (info->bus == dev->bus->number &&
arch/x86/pci/irq.c:			irq = IO_APIC_get_PCI_irq_vector(dev->bus->number,
arch/x86/pci/irq.c:			while (irq < 0 && dev->bus->parent) { /* go back to the bridge */
arch/x86/pci/irq.c:				struct pci_dev *bridge = dev->bus->self;
arch/x86/pci/irq.c:				irq = IO_APIC_get_PCI_irq_vector(bridge->bus->number,
arch/x86/pci/numaq_32.c:	int quad = BUS2QUAD(d->bus->number);
arch/x86/pci/pcbios.c:		  "b" ((dev->bus->number << 8) | dev->devfn),
arch/x86/pci/sta2x11-fixup.c:		ep = pdev->bus->number - instance->bus0;
arch/x86/pci/sta2x11-fixup.c:	return pdev->bus->number - instance->bus0;
arch/x86/pci/visws.c:	int irq, bus = dev->bus->number;
arch/x86/pci/xen.c:		map_irq.bus = dev->bus->number |
arch/x86/pci/xen.c:			map_irq.bus = dev->bus->number;
arch/x86/pci/xen.c:		restore_ext.bus = dev->bus->number;
arch/x86/pci/xen.c:		restore.bus = dev->bus->number;
arch/x86/platform/ce4100/falconfalls.dts:			bus-range = <0 0>;
arch/x86/platform/ce4100/falconfalls.dts:				bus-range = <1 1>;
arch/xtensa/kernel/pci.c:		pci_ctrl->last_busno = bus->busn_res.end;
arch/xtensa/kernel/pci.c:	if (bus->parent) {
drivers/acpi/pci_irq.c:	int bus = dev->bus->number;
drivers/acpi/pci_irq.c:	if (dev->bus->bridge)
drivers/acpi/pci_irq.c:		handle = ACPI_HANDLE(dev->bus->bridge);
drivers/acpi/pci_irq.c:	bridge = dev->bus->self;
drivers/acpi/pci_irq.c:		bridge = dev->bus->self;
drivers/acpi/pci_root.c:		device_set_run_wake(root->bus->bridge, true);
drivers/acpi/pci_root.c:	device_set_run_wake(root->bus->bridge, false);
drivers/acpi/pci_slot.c:	get_device(&pci_bus->dev);
drivers/acpi/pci_slot.c:		pci_slot, pci_bus->number, device, name);
drivers/acpi/pci_slot.c:	acpi_handle handle = ACPI_HANDLE(bus->bridge);
drivers/acpi/pci_slot.c:			put_device(&bus->dev);
drivers/acpi/proc.c:					ldev->bus ? ldev->bus->name :
drivers/acpi/video.c:	input = bus->input;
drivers/ata/Kconfig:	  capability.  BMDMA stands for bus-master DMA and is the
drivers/ata/ahci.c:	if (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&
drivers/ata/ahci.c:	if (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||
drivers/ata/ahci.c:	if (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))
drivers/ata/ahci.c:	return pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);
drivers/ata/ahci.h:	void __iomem *		mmio;		/* bus-independent mem map */
drivers/ata/pata_cmd64x.c:	struct pci_dev *bridge = pdev->bus->self;
drivers/ata/pata_macio.c:	bidp = of_get_property(priv->node, "AAPL,bus-id", NULL);
drivers/ata/pata_octeon_cf.c:	prop = of_get_property(node, "cavium,bus-width", NULL);
drivers/ata/pata_pdc202xx_old.c:		struct pci_dev *bridge = dev->bus->self;
drivers/atm/fore200e.c:    chunk->dma_addr = fore200e->bus->dma_map(fore200e, chunk->align_addr, chunk->align_size, direction);
drivers/atm/fore200e.c:    fore200e->bus->dma_unmap(fore200e, chunk->dma_addr, chunk->dma_size, chunk->direction);
drivers/atm/fore200e.c:	if ((ok = (fore200e->bus->read(addr) == val)))
drivers/atm/fore200e.c:	       fore200e->bus->read(addr), val);
drivers/atm/fore200e.c:		fore200e->bus->dma_chunk_free(fore200e, status);
drivers/atm/fore200e.c:		fore200e->bus->dma_chunk_free(fore200e, rbd_block);
drivers/atm/fore200e.c:    fore200e->bus->write(BSTAT_COLD_START, &fore200e->cp_monitor->bstat);
drivers/atm/fore200e.c:    fore200e->bus->reset(fore200e);
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.status);
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.rpd);
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.status);
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.tpd);
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_cmdq.status);
drivers/atm/fore200e.c:	fore200e->bus->unmap(fore200e);
drivers/atm/fore200e.c:    prom_dma = fore200e->bus->dma_map(fore200e, prom, sizeof(struct prom_data), DMA_FROM_DEVICE);
drivers/atm/fore200e.c:    fore200e->bus->write(prom_dma, &entry->cp_entry->cmd.prom_block.prom_haddr);
drivers/atm/fore200e.c:    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.prom_block.opcode);
drivers/atm/fore200e.c:    fore200e->bus->dma_unmap(fore200e, prom_dma, sizeof(struct prom_data), DMA_FROM_DEVICE);
drivers/atm/fore200e.c:		   pci_dev->bus->number, PCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn));
drivers/atm/fore200e.c:	u32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;
drivers/atm/fore200e.c:	fore200e->bus->write(hcr | SBA200E_HCR_INTR_ENA, fore200e->regs.sba.hcr);
drivers/atm/fore200e.c:	return fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_INTR_REQ;
drivers/atm/fore200e.c:	u32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;
drivers/atm/fore200e.c:	fore200e->bus->write(hcr | SBA200E_HCR_INTR_CLR, fore200e->regs.sba.hcr);
drivers/atm/fore200e.c:	fore200e->bus->write(SBA200E_HCR_RESET, fore200e->regs.sba.hcr);
drivers/atm/fore200e.c:	fore200e->bus->write(0, fore200e->regs.sba.hcr);
drivers/atm/fore200e.c:	fore200e->bus->write(0x02, fore200e->regs.sba.isr); /* XXX hardwired interrupt level */
drivers/atm/fore200e.c:	fore200e->bus->dma_unmap(fore200e, entry->tpd->tsd[ 0 ].buffer, entry->tpd->tsd[ 0 ].length,
drivers/atm/fore200e.c:		fore200e->bus->write(entry->rbd_block_dma, &entry->cp_entry->rbd_block_haddr);
drivers/atm/fore200e.c:	fore200e->bus->dma_sync_for_cpu(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);
drivers/atm/fore200e.c:	fore200e->bus->dma_sync_for_device(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);
drivers/atm/fore200e.c:	fore200e->bus->write(entry->rpd_dma, &entry->cp_entry->rpd_haddr);
drivers/atm/fore200e.c:    if (fore200e->bus->irq_check(fore200e) == 0) {
drivers/atm/fore200e.c:    fore200e->bus->irq_ack(fore200e);
drivers/atm/fore200e.c:	fore200e->bus->write(mtu,                        &entry->cp_entry->cmd.activate_block.mtu);
drivers/atm/fore200e.c:	fore200e->bus->write(*(u32*)&vpvc,         (u32 __iomem *)&entry->cp_entry->cmd.activate_block.vpvc);
drivers/atm/fore200e.c:	fore200e->bus->write(*(u32*)&activ_opcode, (u32 __iomem *)&entry->cp_entry->cmd.activate_block.opcode);
drivers/atm/fore200e.c:	fore200e->bus->write(*(u32*)&vpvc,         (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.vpvc);
drivers/atm/fore200e.c:	fore200e->bus->write(*(u32*)&deactiv_opcode, (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.opcode);
drivers/atm/fore200e.c:    tpd->tsd[ 0 ].buffer = fore200e->bus->dma_map(fore200e, data, tx_len, DMA_TO_DEVICE);
drivers/atm/fore200e.c:    fore200e->bus->write(*(u32*)&tpd_haddr, (u32 __iomem *)&entry->cp_entry->tpd_haddr);
drivers/atm/fore200e.c:    stats_dma_addr = fore200e->bus->dma_map(fore200e, fore200e->stats,
drivers/atm/fore200e.c:    fore200e->bus->write(stats_dma_addr, &entry->cp_entry->cmd.stats_block.stats_haddr);
drivers/atm/fore200e.c:    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.stats_block.opcode);
drivers/atm/fore200e.c:    fore200e->bus->dma_unmap(fore200e, stats_dma_addr, sizeof(struct stats), DMA_FROM_DEVICE);
drivers/atm/fore200e.c:    oc3_regs_dma_addr = fore200e->bus->dma_map(fore200e, regs, sizeof(struct oc3_regs), DMA_FROM_DEVICE);
drivers/atm/fore200e.c:    fore200e->bus->write(oc3_regs_dma_addr, &entry->cp_entry->cmd.oc3_block.regs_haddr);
drivers/atm/fore200e.c:    fore200e->bus->write(*(u32*)&opcode, (u32*)&entry->cp_entry->cmd.oc3_block.opcode);
drivers/atm/fore200e.c:    fore200e->bus->dma_unmap(fore200e, oc3_regs_dma_addr, sizeof(struct oc3_regs), DMA_FROM_DEVICE);
drivers/atm/fore200e.c:    fore200e->bus->write(0, &entry->cp_entry->cmd.oc3_block.regs_haddr);
drivers/atm/fore200e.c:    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.oc3_block.opcode);
drivers/atm/fore200e.c:    ok = fore200e->bus->prom_read(fore200e, prom);
drivers/atm/fore200e.c:					 &buffer[ i ].data, size, fore200e->bus->buffer_alignment,
drivers/atm/fore200e.c:	    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:					       fore200e->bus->status_alignment) < 0) {
drivers/atm/fore200e.c:	    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:					       fore200e->bus->descr_alignment) < 0) {
drivers/atm/fore200e.c:		fore200e->bus->dma_chunk_free(fore200e, &bsq->status);
drivers/atm/fore200e.c:		       fore200e->bus->read(&fore200e->cp_queues->cp_bsq[ scheme ][ magn ]);
drivers/atm/fore200e.c:		fore200e->bus->write(FORE200E_DMA_INDEX(bsq->status.dma_addr, enum status, i), 
drivers/atm/fore200e.c:    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:				       fore200e->bus->status_alignment) < 0) {
drivers/atm/fore200e.c:    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:				       fore200e->bus->descr_alignment) < 0) {
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &rxq->status);
drivers/atm/fore200e.c:    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_rxq);
drivers/atm/fore200e.c:	fore200e->bus->write(FORE200E_DMA_INDEX(rxq->status.dma_addr, enum status, i), 
drivers/atm/fore200e.c:	fore200e->bus->write(FORE200E_DMA_INDEX(rxq->rpd.dma_addr, struct rpd, i),
drivers/atm/fore200e.c:    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:				       fore200e->bus->status_alignment) < 0) {
drivers/atm/fore200e.c:    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:				       fore200e->bus->descr_alignment) < 0) {
drivers/atm/fore200e.c:	fore200e->bus->dma_chunk_free(fore200e, &txq->status);
drivers/atm/fore200e.c:    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_txq);
drivers/atm/fore200e.c:	fore200e->bus->write(FORE200E_DMA_INDEX(txq->status.dma_addr, enum status, i), 
drivers/atm/fore200e.c:    if (fore200e->bus->dma_chunk_alloc(fore200e,
drivers/atm/fore200e.c:				       fore200e->bus->status_alignment) < 0) {
drivers/atm/fore200e.c:    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_cmdq);
drivers/atm/fore200e.c:	fore200e->bus->write(FORE200E_DMA_INDEX(cmdq->status.dma_addr, enum status, i), 
drivers/atm/fore200e.c:    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
drivers/atm/fore200e.c:    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
drivers/atm/fore200e.c:    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
drivers/atm/fore200e.c:    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
drivers/atm/fore200e.c:    fore200e->bus->write(1, &cpq->imask);
drivers/atm/fore200e.c:    if (fore200e->bus->irq_enable)
drivers/atm/fore200e.c:	fore200e->bus->irq_enable(fore200e);
drivers/atm/fore200e.c:    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);
drivers/atm/fore200e.c:    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
drivers/atm/fore200e.c:    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
drivers/atm/fore200e.c:    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);
drivers/atm/fore200e.c:    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
drivers/atm/fore200e.c:    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);
drivers/atm/fore200e.c:    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
drivers/atm/fore200e.c:    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);
drivers/atm/fore200e.c:    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
drivers/atm/fore200e.c:	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);
drivers/atm/fore200e.c:	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
drivers/atm/fore200e.c:    if (strcmp(fore200e->bus->model_name, "PCA-200E") == 0)
drivers/atm/fore200e.c:    else if (strcmp(fore200e->bus->model_name, "SBA-200E") == 0)
drivers/atm/fore200e.c:    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
drivers/atm/fore200e.c:	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
drivers/atm/fore200e.c:	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
drivers/atm/fore200e.c:	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);
drivers/atm/fore200e.c:    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
drivers/atm/fore200e.c:    if (fore200e->bus->configure(fore200e) < 0)
drivers/atm/fore200e.c:    if (fore200e->bus->map(fore200e) < 0)
drivers/atm/fore200e.c:	sprintf(fore200e->name, "%s-%d", bus->model_name, index);
drivers/atm/fore200e.c:    sprintf(fore200e->name, "%s-%d", bus->model_name, index - 1);
drivers/atm/fore200e.c:	   fore200e->bus->model_name, 
drivers/atm/fore200e.c:    sprintf(fore200e->name, "%s-%d", bus->model_name, index);
drivers/atm/fore200e.c:	/* print bus-specific information */
drivers/atm/fore200e.c:	if (fore200e->bus->proc_read)
drivers/atm/fore200e.c:	    len += fore200e->bus->proc_read(fore200e, page + len);
drivers/atm/fore200e.c:	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);
drivers/atm/fore200e.c:	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
drivers/atm/fore200e.c:	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
drivers/atm/fore200e.c:	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
drivers/atm/fore200e.c:	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
drivers/atm/fore200e.c:		       fore200e->bus->read(&cp_monitor->mon_version),
drivers/atm/fore200e.c:		       fore200e->bus->read(&cp_monitor->bstat));
drivers/atm/fore200e.h:/* bus-dependent data */
drivers/atm/fore200e.h:    const struct fore200e_bus* bus;                    /* bus-dependent code and data        */
drivers/atm/fore200e.h:    union        fore200e_regs regs;                   /* bus-dependent registers            */
drivers/atm/fore200e.h:    void*                      bus_dev;                /* bus-specific kernel data           */
drivers/atm/horizon.c:  to enable bus-mastering (with appropriate latency).
drivers/atm/horizon.c:    // (at least) bus-mastering breaks if we try to handle a
drivers/atm/horizon.c:		PRINTD(DBG_WARN, "Buggy ASIC: no TX bus-mastering.");
drivers/atm/iphase.c:		pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));)
drivers/base/base.h:	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
drivers/base/bus.c:		kset_get(&bus->p->subsys);
drivers/base/bus.c:		kset_put(&bus->p->subsys);
drivers/base/bus.c:		error = sysfs_create_file(&bus->p->subsys.kobj, &attr->attr);
drivers/base/bus.c:		sysfs_remove_file(&bus->p->subsys.kobj, &attr->attr);
drivers/base/bus.c:	return sprintf(buf, "%d\n", bus->p->drivers_autoprobe);
drivers/base/bus.c:		bus->p->drivers_autoprobe = 0;
drivers/base/bus.c:		bus->p->drivers_autoprobe = 1;
drivers/base/bus.c:	if (!bus || !bus->p)
drivers/base/bus.c:	klist_iter_init_node(&bus->p->klist_devices, &i,
drivers/base/bus.c:	if (!bus || !bus->p)
drivers/base/bus.c:	klist_iter_init_node(&bus->p->klist_devices, &i,
drivers/base/bus.c:	klist_iter_init_node(&bus->p->klist_drivers, &i,
drivers/base/bus.c:	if (!bus->dev_attrs)
drivers/base/bus.c:	for (i = 0; bus->dev_attrs[i].attr.name; i++) {
drivers/base/bus.c:		error = device_create_file(dev, &bus->dev_attrs[i]);
drivers/base/bus.c:				device_remove_file(dev, &bus->dev_attrs[i]);
drivers/base/bus.c:	if (bus->dev_attrs) {
drivers/base/bus.c:		for (i = 0; bus->dev_attrs[i].attr.name; i++)
drivers/base/bus.c:			device_remove_file(dev, &bus->dev_attrs[i]);
drivers/base/bus.c:		pr_debug("bus: '%s': add device %s\n", bus->name, dev_name(dev));
drivers/base/bus.c:		error = device_add_groups(dev, bus->dev_groups);
drivers/base/bus.c:		error = sysfs_create_link(&bus->p->devices_kset->kobj,
drivers/base/bus.c:				&dev->bus->p->subsys.kobj, "subsystem");
drivers/base/bus.c:		klist_add_tail(&dev->p->knode_bus, &bus->p->klist_devices);
drivers/base/bus.c:	sysfs_remove_link(&bus->p->devices_kset->kobj, dev_name(dev));
drivers/base/bus.c:	device_remove_groups(dev, bus->dev_groups);
drivers/base/bus.c:	if (bus->p->drivers_autoprobe) {
drivers/base/bus.c:	mutex_lock(&bus->p->mutex);
drivers/base/bus.c:	list_for_each_entry(sif, &bus->p->interfaces, node)
drivers/base/bus.c:	mutex_unlock(&bus->p->mutex);
drivers/base/bus.c:	mutex_lock(&bus->p->mutex);
drivers/base/bus.c:	list_for_each_entry(sif, &bus->p->interfaces, node)
drivers/base/bus.c:	mutex_unlock(&bus->p->mutex);
drivers/base/bus.c:	sysfs_remove_link(&dev->bus->p->devices_kset->kobj,
drivers/base/bus.c:	device_remove_groups(dev, dev->bus->dev_groups);
drivers/base/bus.c:		 dev->bus->name, dev_name(dev));
drivers/base/bus.c:	pr_debug("bus: '%s': add driver %s\n", bus->name, drv->name);
drivers/base/bus.c:	priv->kobj.kset = bus->p->drivers_kset;
drivers/base/bus.c:	klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);
drivers/base/bus.c:	if (drv->bus->p->drivers_autoprobe) {
drivers/base/bus.c:	error = driver_add_groups(drv, bus->drv_groups);
drivers/base/bus.c:	driver_remove_groups(drv, drv->bus->drv_groups);
drivers/base/bus.c:	pr_debug("bus: '%s': remove driver %s\n", drv->bus->name, drv->name);
drivers/base/bus.c:	return sysfs_create_groups(&bus->p->subsys.kobj, groups);
drivers/base/bus.c:	sysfs_remove_groups(&bus->p->subsys.kobj, groups);
drivers/base/bus.c:		kobject_uevent(&bus->p->subsys.kobj, action);
drivers/base/bus.c:	struct lock_class_key *key = &bus->lock_key;
drivers/base/bus.c:	bus->p = priv;
drivers/base/bus.c:	retval = kobject_set_name(&priv->subsys.kobj, "%s", bus->name);
drivers/base/bus.c:	retval = bus_add_groups(bus, bus->bus_groups);
drivers/base/bus.c:	pr_debug("bus: '%s': registered\n", bus->name);
drivers/base/bus.c:	kset_unregister(bus->p->drivers_kset);
drivers/base/bus.c:	kset_unregister(bus->p->devices_kset);
drivers/base/bus.c:	kset_unregister(&bus->p->subsys);
drivers/base/bus.c:	kfree(bus->p);
drivers/base/bus.c:	bus->p = NULL;
drivers/base/bus.c:	pr_debug("bus: '%s': unregistering\n", bus->name);
drivers/base/bus.c:	if (bus->dev_root)
drivers/base/bus.c:		device_unregister(bus->dev_root);
drivers/base/bus.c:	bus_remove_groups(bus, bus->bus_groups);
drivers/base/bus.c:	kset_unregister(bus->p->drivers_kset);
drivers/base/bus.c:	kset_unregister(bus->p->devices_kset);
drivers/base/bus.c:	kset_unregister(&bus->p->subsys);
drivers/base/bus.c:	kfree(bus->p);
drivers/base/bus.c:	bus->p = NULL;
drivers/base/bus.c:	return blocking_notifier_chain_register(&bus->p->bus_notifier, nb);
drivers/base/bus.c:	return blocking_notifier_chain_unregister(&bus->p->bus_notifier, nb);
drivers/base/bus.c:	return &bus->p->subsys;
drivers/base/bus.c:	return &bus->p->klist_devices;
drivers/base/core.c:			(dev->bus ? dev->bus->name :
drivers/base/core.c:		return dev->bus->name;
drivers/base/core.c:	if (dev->bus && dev->bus->uevent) {
drivers/base/core.c:		retval = dev->bus->uevent(dev, env);
drivers/base/core.c:	if (!parent && dev->bus && dev->bus->dev_root)
drivers/base/core.c:		return &dev->bus->dev_root->kobj;
drivers/base/core.c:	if (!dev_name(dev) && dev->bus && dev->bus->dev_name)
drivers/base/core.c:		dev_set_name(dev, "%s%u", dev->bus->dev_name, dev->id);
drivers/base/core.c:		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/core.c:		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/core.c:			ret = dev->bus->offline(dev);
drivers/base/core.c:			ret = dev->bus->online(dev);
drivers/base/core.c:		if (dev->bus && dev->bus->shutdown) {
drivers/base/core.c:			dev->bus->shutdown(dev);
drivers/base/core.c:		subsys = dev->bus->name;
drivers/base/cpu.c:	cpu->dev.bus->uevent = arch_cpu_uevent;
drivers/base/dd.c:		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/dd.c:		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/dd.c:		 drv->bus->name, __func__, drv->name, dev_name(dev));
drivers/base/dd.c:	if (dev->bus->probe) {
drivers/base/dd.c:		ret = dev->bus->probe(dev);
drivers/base/dd.c:		 drv->bus->name, __func__, dev_name(dev), drv->name);
drivers/base/dd.c:		 drv->bus->name, __func__, dev_name(dev), drv->name);
drivers/base/dd.c:			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/dd.c:		if (dev->bus && dev->bus->remove)
drivers/base/dd.c:			dev->bus->remove(dev);
drivers/base/dd.c:			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
drivers/base/driver.c:	BUG_ON(!drv->bus->p);
drivers/base/driver.c:	if ((drv->bus->probe && drv->probe) ||
drivers/base/driver.c:	    (drv->bus->remove && drv->remove) ||
drivers/base/driver.c:	    (drv->bus->shutdown && drv->shutdown))
drivers/base/driver.c: * Again, we pass off most of the work to the bus-level call.
drivers/base/driver.c:	struct kobject *k = kset_find_obj(bus->p->drivers_kset, name);
drivers/base/module.c:	driver_name = kasprintf(GFP_KERNEL, "%s:%s", drv->bus->name, drv->name);
drivers/base/platform.c:	spin_lock(&drv->driver.bus->p->klist_drivers.k_lock);
drivers/base/platform.c:	spin_unlock(&drv->driver.bus->p->klist_drivers.k_lock);
drivers/base/power/domain.c:	else if (dev->bus && dev->bus->pm)
drivers/base/power/domain.c:		cb = dev->bus->pm->runtime_suspend;
drivers/base/power/domain.c:	else if (dev->bus && dev->bus->pm)
drivers/base/power/domain.c:		cb = dev->bus->pm->runtime_resume;
drivers/base/power/main.c:		 dev->bus ? dev->bus->name : "No Bus", dev_name(dev));
drivers/base/power/main.c:		 dev->bus ? dev->bus->name : "No Bus", dev_name(dev));
drivers/base/power/main.c:		 deva->bus ? deva->bus->name : "No Bus", dev_name(deva),
drivers/base/power/main.c:		 devb->bus ? devb->bus->name : "No Bus", dev_name(devb));
drivers/base/power/main.c:		 deva->bus ? deva->bus->name : "No Bus", dev_name(deva),
drivers/base/power/main.c:		 devb->bus ? devb->bus->name : "No Bus", dev_name(devb));
drivers/base/power/main.c:		 dev->bus ? dev->bus->name : "No Bus", dev_name(dev));
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = pm_noirq_op(dev->bus->pm, state);
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = pm_late_early_op(dev->bus->pm, state);
drivers/base/power/main.c:		if (dev->bus->pm) {
drivers/base/power/main.c:			callback = pm_op(dev->bus->pm, state);
drivers/base/power/main.c:		} else if (dev->bus->resume) {
drivers/base/power/main.c:			callback = dev->bus->resume;
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = dev->bus->pm->complete;
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = pm_noirq_op(dev->bus->pm, state);
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = pm_late_early_op(dev->bus->pm, state);
drivers/base/power/main.c:		if (dev->bus->pm) {
drivers/base/power/main.c:			callback = pm_op(dev->bus->pm, state);
drivers/base/power/main.c:		} else if (dev->bus->suspend) {
drivers/base/power/main.c:			error = legacy_suspend(dev, state, dev->bus->suspend,
drivers/base/power/main.c:	} else if (dev->bus && dev->bus->pm) {
drivers/base/power/main.c:		callback = dev->bus->pm->prepare;
drivers/base/power/runtime.c:	else if (dev->bus && dev->bus->pm)
drivers/base/power/runtime.c:		callback = dev->bus->pm->runtime_idle;
drivers/base/power/runtime.c:	else if (dev->bus && dev->bus->pm)
drivers/base/power/runtime.c:		callback = dev->bus->pm->runtime_suspend;
drivers/base/power/runtime.c:	else if (dev->bus && dev->bus->pm)
drivers/base/power/runtime.c:		callback = dev->bus->pm->runtime_resume;
drivers/base/regmap/regmap.c: * @bus_context: Data passed to bus-specific callbacks
drivers/base/regmap/regmap.c: * directly, it should be called by bus-specific init functions.
drivers/base/regmap/regmap.c:		if ((bus && bus->fast_io) ||
drivers/base/regmap/regmap.c:		map->read_flag_mask = bus->read_flag_mask;
drivers/base/regmap/regmap.c:		reg_endian = bus->reg_format_endian_default;
drivers/base/regmap/regmap.c:		val_endian = bus->val_format_endian_default;
drivers/base/regmap/regmap.c: * @bus_context: Data passed to bus-specific callbacks
drivers/base/regmap/regmap.c: * directly, it should be called by bus-specific init functions.  The
drivers/base/regmap/regmap.c:	if (map->bus && map->bus->free_context)
drivers/base/regmap/regmap.c:		map->bus->free_context(map->bus_context);
drivers/base/regmap/regmap.c:	if (map->async && map->bus->async_write) {
drivers/base/regmap/regmap.c:			async = map->bus->async_alloc();
drivers/base/regmap/regmap.c:			ret = map->bus->async_write(map->bus_context,
drivers/base/regmap/regmap.c:			ret = map->bus->async_write(map->bus_context,
drivers/base/regmap/regmap.c:		ret = map->bus->write(map->bus_context, map->work_buf,
drivers/base/regmap/regmap.c:	else if (map->bus->gather_write)
drivers/base/regmap/regmap.c:		ret = map->bus->gather_write(map->bus_context, map->work_buf,
drivers/base/regmap/regmap.c:		ret = map->bus->write(map->bus_context, buf, len);
drivers/base/regmap/regmap.c:	ret = map->bus->write(map->bus_context, map->work_buf,
drivers/base/regmap/regmap.c:	ret = map->bus->read(map->bus_context, map->work_buf,
drivers/base/regmap/regmap.c:	if (!map->bus || !map->bus->async_write)
drivers/bcma/core.c:	switch (core->bus->hosttype) {
drivers/bcma/core.c:			 core->bus->hosttype);
drivers/bcma/driver_chipcommon.c:		if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
drivers/bcma/driver_chipcommon.c:		if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
drivers/bcma/driver_chipcommon.c:					     cc->core->bus->num, &wdt,
drivers/bcma/driver_chipcommon.c:		if (cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM43142) {
drivers/bcma/driver_chipcommon.c:		if (cc->core->bus->sprom.leddc_on_time &&
drivers/bcma/driver_chipcommon.c:		    cc->core->bus->sprom.leddc_off_time) {
drivers/bcma/driver_chipcommon.c:			leddc_on = cc->core->bus->sprom.leddc_on_time;
drivers/bcma/driver_chipcommon.c:			leddc_off = cc->core->bus->sprom.leddc_off_time;
drivers/bcma/driver_chipcommon_nflash.c:	if (bus->chipinfo.id != BCMA_CHIP_ID_BCM4706 &&
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:			   bus->chipinfo.id);
drivers/bcma/driver_chipcommon_pmu.c:		if (bus->chipinfo.pkg == 9 || bus->chipinfo.pkg == 11)
drivers/bcma/driver_chipcommon_pmu.c:		else if (bus->chipinfo.rev > 0)
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:		if (bus->chipinfo.rev == 0) {
drivers/bcma/driver_chipcommon_pmu.c:			   bus->chipinfo.id);
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:			  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);
drivers/bcma/driver_chipcommon_pmu.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
drivers/bcma/driver_chipcommon_pmu.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) {
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:			  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);
drivers/bcma/driver_chipcommon_pmu.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM53572)
drivers/bcma/driver_chipcommon_pmu.c:		switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_chipcommon_pmu.c:		phypll_offset = (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
drivers/bcma/driver_chipcommon_pmu.c:		       bus->chipinfo.id == BCMA_CHIP_ID_BCM4749 ||
drivers/bcma/driver_chipcommon_pmu.c:		       bus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;
drivers/bcma/driver_chipcommon_pmu.c:			 bus->chipinfo.id);
drivers/bcma/driver_gpio.c:	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
drivers/bcma/driver_gpio.c:	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
drivers/bcma/driver_mips.c:	return dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM47162 &&
drivers/bcma/driver_mips.c:	       dev->bus->chipinfo.rev == 0 && dev->id.id == BCMA_CORE_MIPS_74K;
drivers/bcma/driver_mips.c:	return (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
drivers/bcma/driver_mips.c:		dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) &&
drivers/bcma/driver_mips.c:	       dev->bus->chipinfo.pkg == 11 &&
drivers/bcma/driver_mips.c:	struct bcma_device *mdev = dev->bus->drv_mips.core;
drivers/bcma/driver_mips.c:	struct bcma_device *mdev = bus->drv_mips.core;
drivers/bcma/driver_mips.c:			list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/driver_mips.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/driver_mips.c:	if (bus->drv_cc.capabilities & BCMA_CC_CAP_PMU)
drivers/bcma/driver_mips.c:		return bcma_pmu_get_cpu_clock(&bus->drv_cc);
drivers/bcma/driver_mips.c:	struct bcma_drv_cc *cc = &bus->drv_cc;
drivers/bcma/driver_mips.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
drivers/bcma/driver_mips.c:	bcma_chipco_serial_init(&bus->drv_cc);
drivers/bcma/driver_mips.c:	if (bus->chipinfo.id != BCMA_CHIP_ID_BCM4716 &&
drivers/bcma/driver_mips.c:	    bus->chipinfo.id != BCMA_CHIP_ID_BCM4748)
drivers/bcma/driver_mips.c:	switch (bus->chipinfo.id) {
drivers/bcma/driver_mips.c:		list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/driver_mips.c:			 bus->chipinfo.id);
drivers/bcma/driver_pci.c:	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
drivers/bcma/driver_pci.c:	pc = &bus->drv_pci[0];
drivers/bcma/driver_pci.c:	if (!pc || core->bus->hosttype != BCMA_HOSTTYPE_PCI) {
drivers/bcma/driver_pci.c:	pdev = pc->core->bus->host_pci;
drivers/bcma/driver_pci.c:	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
drivers/bcma/driver_pci.c:	pc = &bus->drv_pci[0];
drivers/bcma/driver_pci.c:	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
drivers/bcma/driver_pci.c:	pc = &bus->drv_pci[0];
drivers/bcma/driver_pci_host.c:	chipid_top = (bus->chipinfo.id & 0xFF00);
drivers/bcma/driver_pci_host.c:	u16 chipid = pc->core->bus->chipinfo.id;
drivers/bcma/driver_pci_host.c:	pc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);
drivers/bcma/driver_pci_host.c:	pc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);
drivers/bcma/driver_pci_host.c:	if (bus->sprom.boardflags_lo & BCMA_CORE_PCI_BFL_NOPCI) {
drivers/bcma/driver_pci_host.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4716 ||
drivers/bcma/driver_pci_host.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4748) {
drivers/bcma/driver_pci_host.c:	} else if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
drivers/bcma/driver_pci_host.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706 ||
drivers/bcma/driver_pci_host.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4716) {
drivers/bcma/driver_pci_host.c:	if (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {
drivers/bcma/driver_pci_host.c:	if (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {
drivers/bcma/driver_pci_host.c:	if (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {
drivers/bcma/driver_pci_host.c:	pc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,
drivers/bcma/driver_pci_host.c:	if (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {
drivers/bcma/driver_pci_host.c:	pc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,
drivers/bcma/host_pci.c:	pci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN,
drivers/bcma/host_pci.c:	pci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN2,
drivers/bcma/host_pci.c:	core->bus->mapped_core = core;
drivers/bcma/host_pci.c:	if (core->bus->mapped_core != core)
drivers/bcma/host_pci.c:	return ioread8(core->bus->mmio + offset);
drivers/bcma/host_pci.c:	return ioread16(core->bus->mmio + offset);
drivers/bcma/host_pci.c:	return ioread32(core->bus->mmio + offset);
drivers/bcma/host_pci.c:	iowrite8(value, core->bus->mmio + offset);
drivers/bcma/host_pci.c:	iowrite16(value, core->bus->mmio + offset);
drivers/bcma/host_pci.c:	iowrite32(value, core->bus->mmio + offset);
drivers/bcma/host_pci.c:	void __iomem *addr = core->bus->mmio + offset;
drivers/bcma/host_pci.c:	if (core->bus->mapped_core != core)
drivers/bcma/host_pci.c:	void __iomem *addr = core->bus->mmio + offset;
drivers/bcma/host_pci.c:	if (core->bus->mapped_core != core)
drivers/bcma/host_pci.c:	if (core->bus->mapped_core != core)
drivers/bcma/host_pci.c:	return ioread32(core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);
drivers/bcma/host_pci.c:	if (core->bus->mapped_core != core)
drivers/bcma/host_pci.c:	iowrite32(value, core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);
drivers/bcma/host_pci.c:	bus->mmio = pci_iomap(dev, 0, ~0UL);
drivers/bcma/host_pci.c:	if (!bus->mmio)
drivers/bcma/host_pci.c:	bus->host_pci = dev;
drivers/bcma/host_pci.c:	bus->hosttype = BCMA_HOSTTYPE_PCI;
drivers/bcma/host_pci.c:	bus->ops = &bcma_host_pci_ops;
drivers/bcma/host_pci.c:	bus->boardinfo.vendor = bus->host_pci->subsystem_vendor;
drivers/bcma/host_pci.c:	bus->boardinfo.type = bus->host_pci->subsystem_device;
drivers/bcma/host_pci.c:	pci_iounmap(dev, bus->mmio);
drivers/bcma/host_pci.c:	pci_iounmap(dev, bus->mmio);
drivers/bcma/host_pci.c:	bus->mapped_core = NULL;
drivers/bcma/host_soc.c:	bus->mmio = ioremap_nocache(BCMA_ADDR_BASE, BCMA_CORE_SIZE * 1);
drivers/bcma/host_soc.c:	if (!bus->mmio)
drivers/bcma/host_soc.c:	bus->hosttype = BCMA_HOSTTYPE_SOC;
drivers/bcma/host_soc.c:	bus->ops = &bcma_host_soc_ops;
drivers/bcma/host_soc.c:		iounmap(bus->mmio);
drivers/bcma/main.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
drivers/bcma/main.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/main.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/main.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/main.c:		dev_set_name(&core->dev, "bcma%d:%d", bus->num, dev_id);
drivers/bcma/main.c:		switch (bus->hosttype) {
drivers/bcma/main.c:			core->dev.parent = &bus->host_pci->dev;
drivers/bcma/main.c:			core->dma_dev = &bus->host_pci->dev;
drivers/bcma/main.c:			core->irq = bus->host_pci->irq;
drivers/bcma/main.c:	if (bus->drv_cc.pflash.present) {
drivers/bcma/main.c:	if (bus->drv_cc.sflash.present) {
drivers/bcma/main.c:	if (bus->drv_cc.nflash.present) {
drivers/bcma/main.c:	err = bcma_gpio_init(&bus->drv_cc);
drivers/bcma/main.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
drivers/bcma/main.c:		err = bcma_chipco_watchdog_register(&bus->drv_cc);
drivers/bcma/main.c:	list_for_each_entry_safe(core, tmp, &bus->cores, list) {
drivers/bcma/main.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
drivers/bcma/main.c:		platform_device_unregister(bus->drv_cc.watchdog);
drivers/bcma/main.c:	bus->num = bcma_bus_next_num++;
drivers/bcma/main.c:		bus->drv_cc.core = core;
drivers/bcma/main.c:		bcma_core_chipcommon_early_init(&bus->drv_cc);
drivers/bcma/main.c:		bus->drv_cc.core = core;
drivers/bcma/main.c:		bcma_core_chipcommon_init(&bus->drv_cc);
drivers/bcma/main.c:		bus->drv_mips.core = core;
drivers/bcma/main.c:		bcma_core_mips_init(&bus->drv_mips);
drivers/bcma/main.c:		bus->drv_pci[0].core = core;
drivers/bcma/main.c:		bcma_core_pci_init(&bus->drv_pci[0]);
drivers/bcma/main.c:		bus->drv_pci[1].core = core;
drivers/bcma/main.c:		bcma_core_pci_init(&bus->drv_pci[1]);
drivers/bcma/main.c:		bus->drv_gmac_cmn.core = core;
drivers/bcma/main.c:		bcma_core_gmac_cmn_init(&bus->drv_gmac_cmn);
drivers/bcma/main.c:	err = bcma_gpio_unregister(&bus->drv_cc);
drivers/bcma/main.c:		bus->drv_cc.core = core;
drivers/bcma/main.c:		bcma_core_chipcommon_early_init(&bus->drv_cc);
drivers/bcma/main.c:		bus->drv_mips.core = core;
drivers/bcma/main.c:		bcma_core_mips_early_init(&bus->drv_mips);
drivers/bcma/main.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/main.c:	if (bus->drv_cc.core) {
drivers/bcma/main.c:		bus->drv_cc.setup_done = false;
drivers/bcma/main.c:		bcma_core_chipcommon_init(&bus->drv_cc);
drivers/bcma/main.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/scan.c:	return readl(bus->mmio + offset);
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_PCI)
drivers/bcma/scan.c:		pci_write_config_dword(bus->host_pci, BCMA_PCI_BAR0_WIN,
drivers/bcma/scan.c:	list_for_each_entry(core, &bus->cores, list) {
drivers/bcma/scan.c:	list_for_each_entry_reverse(core, &bus->cores, list) {
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
drivers/bcma/scan.c:	struct bcma_chipinfo *chipinfo = &(bus->chipinfo);
drivers/bcma/scan.c:	if (bus->init_done)
drivers/bcma/scan.c:	INIT_LIST_HEAD(&bus->cores);
drivers/bcma/scan.c:	bus->nr_cores = 0;
drivers/bcma/scan.c:	bus->init_done = true;
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
drivers/bcma/scan.c:		eromptr = bus->mmio;
drivers/bcma/scan.c:		bus->nr_cores++;
drivers/bcma/scan.c:		list_add_tail(&core->list, &bus->cores);
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
drivers/bcma/scan.c:		eromptr = bus->mmio;
drivers/bcma/scan.c:		bus->nr_cores++;
drivers/bcma/scan.c:		list_add_tail(&core->list, &bus->cores);
drivers/bcma/scan.c:	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
drivers/bcma/sprom.c:		   bus->sprom.revision);
drivers/bcma/sprom.c:		sprom[i] = bcma_read16(bus->drv_cc.core, offset + (i * 2));
drivers/bcma/sprom.c:	bus->sprom.revision = revision;
drivers/bcma/sprom.c:	bus->sprom._field = ((sprom[SPOFF(_offset)] & (_mask)) >> (_shift))
drivers/bcma/sprom.c:	bus->sprom._field = ((((u32)sprom[SPOFF((_offset)+2)] << 16 | \
drivers/bcma/sprom.c:			ARRAY_SIZE(bus->sprom.core_pwr_info));
drivers/bcma/sprom.c:		*(((__be16 *)bus->sprom.il0mac) + i) = cpu_to_be16(v);
drivers/bcma/sprom.c:	if (bus->drv_cc.core->id.rev >= 31) {
drivers/bcma/sprom.c:		if (!(bus->drv_cc.capabilities & BCMA_CC_CAP_SPROM))
drivers/bcma/sprom.c:		srom_control = bcma_read32(bus->drv_cc.core,
drivers/bcma/sprom.c:	chip_status = bcma_read32(bus->drv_cc.core, BCMA_CC_CHIPSTAT);
drivers/bcma/sprom.c:	switch (bus->chipinfo.id) {
drivers/bcma/sprom.c:	chip_status = bcma_read32(bus->drv_cc.core, BCMA_CC_CHIPSTAT);
drivers/bcma/sprom.c:	switch (bus->chipinfo.id) {
drivers/bcma/sprom.c:		otpsize = bus->drv_cc.capabilities & BCMA_CC_CAP_OTPS;
drivers/bcma/sprom.c:	struct bcma_device *cc = bus->drv_cc.core;
drivers/bcma/sprom.c:	if (!bus->drv_cc.core)
drivers/bcma/sprom.c:			err = bcma_fill_sprom_with_fallback(bus, &bus->sprom);
drivers/bcma/sprom.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
drivers/bcma/sprom.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
drivers/bcma/sprom.c:		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, false);
drivers/bcma/sprom.c:	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
drivers/bcma/sprom.c:	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
drivers/bcma/sprom.c:		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, true);
drivers/bcma/sprom.c:		err = bcma_fill_sprom_with_fallback(bus, &bus->sprom);
drivers/block/DAC960.c:  Controller->Bus = PCI_Device->bus->number;
drivers/block/cciss.c:	pciinfo.bus = h->pdev->bus->number;
drivers/block/cciss_scsi.c: * complaining.  Doing a host- or bus-reset can't do anything good here. 
drivers/block/cpqarray.c:			pdev->device, pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/block/cpqarray.c:		pciinfo.bus = host->pci_dev->bus->number;
drivers/block/rbd.c:                 Documentation/ABI/testing/sysfs-bus-rbd
drivers/block/skd_main.c:	inq.pcie_bus_number = cpu_to_be16(pdev->bus->number);
drivers/block/umem.c:	 * is doing (bus-to-card) DMA, or you will need the
drivers/block/xsysace.c:	/* Call the bus-independent setup code */
drivers/bus/mvebu-mbus.c:	void __iomem *addr = mbus->mbuswins_base +
drivers/bus/mvebu-mbus.c:		mbus->soc->win_cfg_offset(win);
drivers/bus/mvebu-mbus.c:		if (win < mbus->soc->num_remappable_wins) {
drivers/bus/mvebu-mbus.c:	addr = mbus->mbuswins_base + mbus->soc->win_cfg_offset(win);
drivers/bus/mvebu-mbus.c:	if (win < mbus->soc->num_remappable_wins) {
drivers/bus/mvebu-mbus.c:	void __iomem *addr = mbus->mbuswins_base +
drivers/bus/mvebu-mbus.c:		mbus->soc->win_cfg_offset(win);
drivers/bus/mvebu-mbus.c:	for (win = 0; win < mbus->soc->num_wins; win++) {
drivers/bus/mvebu-mbus.c:	for (win = 0; win < mbus->soc->num_wins; win++) {
drivers/bus/mvebu-mbus.c:	void __iomem *addr = mbus->mbuswins_base +
drivers/bus/mvebu-mbus.c:		mbus->soc->win_cfg_offset(win);
drivers/bus/mvebu-mbus.c:	if (win < mbus->soc->num_remappable_wins) {
drivers/bus/mvebu-mbus.c:		for (win = mbus->soc->num_remappable_wins;
drivers/bus/mvebu-mbus.c:		     win < mbus->soc->num_wins; win++)
drivers/bus/mvebu-mbus.c:	for (win = 0; win < mbus->soc->num_wins; win++)
drivers/bus/mvebu-mbus.c:		u32 basereg = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:		u32 sizereg = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:		u32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:	return mbus->soc->show_cpu_target(mbus, seq, v);
drivers/bus/mvebu-mbus.c:	for (win = 0; win < mbus->soc->num_wins; win++) {
drivers/bus/mvebu-mbus.c:		if (win < mbus->soc->num_remappable_wins) {
drivers/bus/mvebu-mbus.c:		u32 base = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:		u32 size = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:			if (mbus->hw_io_coherency)
drivers/bus/mvebu-mbus.c:		u32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));
drivers/bus/mvebu-mbus.c:	mbus->mbuswins_base = ioremap(mbuswins_phys_base, mbuswins_size);
drivers/bus/mvebu-mbus.c:	if (!mbus->mbuswins_base)
drivers/bus/mvebu-mbus.c:	mbus->sdramwins_base = ioremap(sdramwins_phys_base, sdramwins_size);
drivers/bus/mvebu-mbus.c:	if (!mbus->sdramwins_base) {
drivers/bus/mvebu-mbus.c:		mbus->hw_io_coherency = 1;
drivers/bus/mvebu-mbus.c:	for (win = 0; win < mbus->soc->num_wins; win++)
drivers/bus/mvebu-mbus.c:	mbus->soc->setup_cpu_target(mbus);
drivers/bus/mvebu-mbus.c:		pr_err("could not find an 'mbus-controller' node\n");
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 1));
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 2));
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(30, 0));
drivers/char/agp/sworks-agp.c:	bridge_dev = pci_get_bus_and_slot((unsigned int)pdev->bus->number,
drivers/clk/clk-highbank.c:CLK_OF_DECLARE(hb_a9bus, "calxeda,hb-a9bus-clock", hb_a9bus_init);
drivers/clk/samsung/clk-s3c64xx.c:	ALIAS(SCLK_UHOST, "s3c2410-ohci", "usb-bus-host"),
drivers/cpufreq/pmac32-cpufreq.c:		freqs = of_get_property(cpunode, "bus-frequencies", &lenp);
drivers/cpufreq/pmac32-cpufreq.c:			printk(KERN_ERR "cpufreq: bus-frequencies incorrect or missing\n");
drivers/cpufreq/pmac32-cpufreq.c:		ratio = of_get_property(cpunode, "processor-to-bus-ratio*2",
drivers/cpufreq/pmac32-cpufreq.c:			printk(KERN_ERR "cpufreq: processor-to-bus-ratio*2 missing\n");
drivers/crypto/caam/regs.h: * CAAM's bus-addressable registers are 64 bits internally.
drivers/dca/dca-core.c:	while (bus->parent)
drivers/dca/dca-core.c:		bus = bus->parent;
drivers/devfreq/exynos/exynos5_bus.c:		.name		= "exynos5-bus-int",
drivers/devfreq/exynos/exynos5_bus.c:		platform_device_register_simple("exynos5-bus-int", -1, NULL, 0);
drivers/dma/amba-pl08x.c:		if (bd.remainder < mbus->buswidth)
drivers/dma/amba-pl08x.c:			early_bytes = mbus->buswidth -
drivers/dma/amba-pl08x.c:				(mbus->addr & (mbus->buswidth - 1));
drivers/dma/amba-pl08x.c:			if ((bd.remainder - early_bytes) < mbus->buswidth)
drivers/dma/amba-pl08x.c:				sbus->buswidth = 1;
drivers/dma/amba-pl08x.c:			while (bd.remainder > (mbus->buswidth - 1)) {
drivers/dma/amba-pl08x.c:				width = max(mbus->buswidth, sbus->buswidth);
drivers/dma/ioat/dca.c:	return (pci->bus->number << 8) | pci->devfn;
drivers/edac/amd64_edac.c:		    (dev->bus->number == related->bus->number) &&
drivers/edac/edac_mc_sysfs.c:	mci->bus->name = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);
drivers/edac/edac_mc_sysfs.c:	if (!mci->bus->name)
drivers/edac/edac_mc_sysfs.c:	edac_dbg(0, "creating bus %s\n", mci->bus->name);
drivers/edac/edac_mc_sysfs.c:		kfree(mci->bus->name);
drivers/edac/edac_mc_sysfs.c:	kfree(mci->bus->name);
drivers/edac/edac_mc_sysfs.c:	kfree(mci->bus->name);
drivers/edac/i5000_edac.c:	edac_dbg(1, "System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
drivers/edac/i5000_edac.c:		 pdev->bus->number,
drivers/edac/i5100_edac.c:	priv->debugfs = debugfs_create_dir(mci->bus->name, i5100_debugfs);
drivers/edac/i5400_edac.c:	edac_dbg(1, "System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
drivers/edac/i5400_edac.c:		 pdev->bus->number,
drivers/edac/i7300_edac.c:	edac_dbg(1, "System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
drivers/edac/i7300_edac.c:		 pdev->bus->number,
drivers/edac/i7core_edac.c:		 dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
drivers/edac/i7core_edac.c:		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
drivers/edac/i7core_edac.c:			 pdev->bus->number,
drivers/edac/i7core_edac.c:	bus = pdev->bus->number;
drivers/edac/sb_edac.c:			 pdev->bus->number,
drivers/edac/sb_edac.c:	bus = pdev->bus->number;
drivers/extcon/extcon-palmas.c:						"ti,enable-vbus-detection");
drivers/gpio/gpiolib.c:		seq_printf(s, ", %s/%s", dev->bus ? dev->bus->name : "no-bus",
drivers/gpu/drm/drm_info.c:	bus_name = dev->driver->bus->get_name(dev);
drivers/gpu/drm/drm_ioctl.c:	if (!dev->driver->bus->set_unique)
drivers/gpu/drm/drm_ioctl.c:	ret = dev->driver->bus->set_unique(dev, master, u);
drivers/gpu/drm/drm_ioctl.c:	ret = dev->driver->bus->set_busid(dev, master);
drivers/gpu/drm/drm_irq.c:	if (!dev->driver->bus->irq_by_busid)
drivers/gpu/drm/drm_irq.c:	return dev->driver->bus->irq_by_busid(dev, p);
drivers/gpu/drm/drm_pci.c:		       dev->pdev->bus->number,
drivers/gpu/drm/drm_pci.c:	bus_name = dev->driver->bus->get_name(dev);
drivers/gpu/drm/drm_pci.c:	    (bus != dev->pdev->bus->number) ||
drivers/gpu/drm/drm_pci.c:	    (p->busnum & 0xff) != dev->pdev->bus->number ||
drivers/gpu/drm/drm_pci.c:	root = dev->pdev->bus->self;
drivers/gpu/drm/drm_platform.c:	 * set to -1.. use 0 instead to avoid a funny looking bus-id:
drivers/gpu/drm/drm_stub.c:	if (dev->driver->bus->agp_init) {
drivers/gpu/drm/drm_stub.c:		ret = dev->driver->bus->agp_init(dev);
drivers/gpu/drm/drm_stub.c:	if (dev->driver->bus->agp_destroy)
drivers/gpu/drm/drm_stub.c:		dev->driver->bus->agp_destroy(dev);
drivers/gpu/drm/drm_stub.c:	if (dev->driver->bus->agp_destroy)
drivers/gpu/drm/drm_stub.c:		dev->driver->bus->agp_destroy(dev);
drivers/gpu/drm/drm_vm.c:		 * Adjust to a bus-relative address
drivers/gpu/drm/gma500/cdv_intel_crt.c:				       &gma_encoder->ddc_bus->adapter);
drivers/gpu/drm/gma500/cdv_intel_hdmi.c:	edid = drm_get_edid(connector, &gma_encoder->i2c_bus->adapter);
drivers/gpu/drm/gma500/cdv_intel_hdmi.c:	edid = drm_get_edid(connector, &gma_encoder->i2c_bus->adapter);
drivers/gpu/drm/gma500/cdv_intel_hdmi.c:	hdmi_priv->hdmi_i2c_adapter = &(gma_encoder->i2c_bus->adapter);
drivers/gpu/drm/gma500/cdv_intel_lvds.c:			.addr = lvds_i2c_bus->slave_addr,
drivers/gpu/drm/gma500/cdv_intel_lvds.c:	if (i2c_transfer(&lvds_i2c_bus->adapter, msgs, 1) == 1)
drivers/gpu/drm/gma500/cdv_intel_lvds.c:	ret = psb_intel_ddc_get_modes(connector, &gma_encoder->i2c_bus->adapter);
drivers/gpu/drm/gma500/cdv_intel_lvds.c:	gma_encoder->i2c_bus->slave_addr = 0x2C;
drivers/gpu/drm/gma500/cdv_intel_lvds.c:				&gma_encoder->ddc_bus->adapter);
drivers/gpu/drm/gma500/intel_gmbus.c:	if (bus->force_bit)
drivers/gpu/drm/gma500/intel_gmbus.c:					    bus->force_bit, msgs, num);
drivers/gpu/drm/gma500/intel_gmbus.c:	GMBUS_REG_WRITE(GMBUS0 + reg_offset, bus->reg0);
drivers/gpu/drm/gma500/intel_gmbus.c:		 bus->reg0 & 0xff, bus->adapter.name);
drivers/gpu/drm/gma500/intel_gmbus.c:	bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 0xff);
drivers/gpu/drm/gma500/intel_gmbus.c:	if (!bus->force_bit)
drivers/gpu/drm/gma500/intel_gmbus.c:	return intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
drivers/gpu/drm/gma500/intel_gmbus.c:	if (bus->force_bit)
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->force_bit->algo->functionality(bus->force_bit);
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.owner = THIS_MODULE;
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.class = I2C_CLASS_DDC;
drivers/gpu/drm/gma500/intel_gmbus.c:		snprintf(bus->adapter.name,
drivers/gpu/drm/gma500/intel_gmbus.c:			 sizeof(bus->adapter.name),
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.algo_data	= dev_priv;
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.algo = &gmbus_algorithm;
drivers/gpu/drm/gma500/intel_gmbus.c:		ret = i2c_add_adapter(&bus->adapter);
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->reg0 = i | GMBUS_RATE_100KHZ;
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->force_bit = intel_gpio_create(dev_priv, i);
drivers/gpu/drm/gma500/intel_gmbus.c:		i2c_del_adapter(&bus->adapter);
drivers/gpu/drm/gma500/intel_gmbus.c:	bus->reg0 = (bus->reg0 & ~(0x3 << 8)) | (speed << 8);
drivers/gpu/drm/gma500/intel_gmbus.c:		if (bus->force_bit == NULL) {
drivers/gpu/drm/gma500/intel_gmbus.c:			bus->force_bit = intel_gpio_create(dev_priv,
drivers/gpu/drm/gma500/intel_gmbus.c:							   bus->reg0 & 0xff);
drivers/gpu/drm/gma500/intel_gmbus.c:		if (bus->force_bit) {
drivers/gpu/drm/gma500/intel_gmbus.c:			i2c_del_adapter(bus->force_bit);
drivers/gpu/drm/gma500/intel_gmbus.c:			kfree(bus->force_bit);
drivers/gpu/drm/gma500/intel_gmbus.c:			bus->force_bit = NULL;
drivers/gpu/drm/gma500/intel_gmbus.c:		if (bus->force_bit) {
drivers/gpu/drm/gma500/intel_gmbus.c:			i2c_del_adapter(bus->force_bit);
drivers/gpu/drm/gma500/intel_gmbus.c:			kfree(bus->force_bit);
drivers/gpu/drm/gma500/intel_gmbus.c:		i2c_del_adapter(&bus->adapter);
drivers/gpu/drm/gma500/psb_intel_lvds.c:			.addr = lvds_i2c_bus->slave_addr,
drivers/gpu/drm/gma500/psb_intel_lvds.c:	if (i2c_transfer(&lvds_i2c_bus->adapter, msgs, 1) == 1) {
drivers/gpu/drm/gma500/psb_intel_lvds.c:		ret = psb_intel_ddc_get_modes(connector, &lvds_priv->i2c_bus->adapter);
drivers/gpu/drm/gma500/psb_intel_lvds.c:	lvds_priv->i2c_bus->slave_addr = 0x2C;
drivers/gpu/drm/gma500/psb_intel_lvds.c:	psb_intel_ddc_get_modes(connector, &lvds_priv->ddc_bus->adapter);
drivers/gpu/drm/i915/dvo_ns2501.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/dvo_ns2501.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:		reserved = I915_READ_NOTRACE(bus->gpio_reg) &
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved | GPIO_CLOCK_DIR_MASK);
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved);
drivers/gpu/drm/i915/intel_i2c.c:	return (I915_READ_NOTRACE(bus->gpio_reg) & GPIO_CLOCK_VAL_IN) != 0;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved | GPIO_DATA_DIR_MASK);
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved);
drivers/gpu/drm/i915/intel_i2c.c:	return (I915_READ_NOTRACE(bus->gpio_reg) & GPIO_DATA_VAL_IN) != 0;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved | clock_bits);
drivers/gpu/drm/i915/intel_i2c.c:	POSTING_READ(bus->gpio_reg);
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE_NOTRACE(bus->gpio_reg, reserved | data_bits);
drivers/gpu/drm/i915/intel_i2c.c:	POSTING_READ(bus->gpio_reg);
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	algo = &bus->bit_algo;
drivers/gpu/drm/i915/intel_i2c.c:	bus->gpio_reg = dev_priv->gpio_mmio_base + gmbus_ports[pin - 1].reg;
drivers/gpu/drm/i915/intel_i2c.c:	bus->adapter.algo_data = algo;
drivers/gpu/drm/i915/intel_i2c.c:	struct drm_i915_private *dev_priv = bus->dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:	if (bus->force_bit) {
drivers/gpu/drm/i915/intel_i2c.c:	I915_WRITE(GMBUS0 + reg_offset, bus->reg0);
drivers/gpu/drm/i915/intel_i2c.c:		 bus->adapter.name, bus->reg0 & 0xff);
drivers/gpu/drm/i915/intel_i2c.c:	bus->force_bit = 1;
drivers/gpu/drm/i915/intel_i2c.c:		bus->adapter.owner = THIS_MODULE;
drivers/gpu/drm/i915/intel_i2c.c:		bus->adapter.class = I2C_CLASS_DDC;
drivers/gpu/drm/i915/intel_i2c.c:		snprintf(bus->adapter.name,
drivers/gpu/drm/i915/intel_i2c.c:			 sizeof(bus->adapter.name),
drivers/gpu/drm/i915/intel_i2c.c:		bus->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/i915/intel_i2c.c:		bus->dev_priv = dev_priv;
drivers/gpu/drm/i915/intel_i2c.c:		bus->adapter.algo = &gmbus_algorithm;
drivers/gpu/drm/i915/intel_i2c.c:		bus->reg0 = port | GMBUS_RATE_100KHZ;
drivers/gpu/drm/i915/intel_i2c.c:			bus->force_bit = 1;
drivers/gpu/drm/i915/intel_i2c.c:		ret = i2c_add_adapter(&bus->adapter);
drivers/gpu/drm/i915/intel_i2c.c:		i2c_del_adapter(&bus->adapter);
drivers/gpu/drm/i915/intel_i2c.c:	bus->reg0 = (bus->reg0 & ~(0x3 << 8)) | speed;
drivers/gpu/drm/i915/intel_i2c.c:	bus->force_bit += force_bit ? 1 : -1;
drivers/gpu/drm/i915/intel_i2c.c:		      bus->force_bit);
drivers/gpu/drm/i915/intel_i2c.c:		i2c_del_adapter(&bus->adapter);
drivers/gpu/drm/i915/intel_opregion.c:	list_for_each_entry(acpi_cdev, &acpi_video_bus->children, node) {
drivers/gpu/drm/mga/mga_drv.c:	if ((pdev->device == 0x0525) && pdev->bus->self
drivers/gpu/drm/mga/mga_drv.c:	    && (pdev->bus->self->vendor == 0x3388)
drivers/gpu/drm/mga/mga_drv.c:	    && (pdev->bus->self->device == 0x0021)) {
drivers/gpu/drm/msm/mdp4/mdp4_kms.h: * to find their pdata to make the bus-scaling stuff work.
drivers/gpu/drm/nouveau/core/subdev/bus/hwsq.c:		if (hwsq->c.size <= pbus->hwsq_size) {
drivers/gpu/drm/nouveau/core/subdev/bus/hwsq.c:				ret = pbus->hwsq_exec(pbus, (u32 *)hwsq->c.data,
drivers/gpu/drm/nouveau/nouveau_acpi.c:	if (pdev->bus->number == 0)
drivers/gpu/drm/nouveau/nouveau_drm.c:	name |= pdev->bus->number << 16;
drivers/gpu/drm/nouveau/nouveau_drm.c:	drm->hdmi_device = pci_get_bus_and_slot((unsigned int)pdev->bus->number,
drivers/gpu/drm/nouveau/nouveau_drm.c:		DRM_INFO("hdmi device  not found %d %d %d\n", pdev->bus->number, PCI_SLOT(pdev->devfn), 1);
drivers/gpu/drm/r128/r128_cce.c:	/* We don't support anything other than bus-mastering ring mode,
drivers/gpu/drm/radeon/atombios_dp.c:					 dig_connector->dp_i2c_bus->rec.i2c_id, 0);
drivers/gpu/drm/radeon/cik.c:	struct pci_dev *root = rdev->pdev->bus->self;
drivers/gpu/drm/radeon/cik.c:				struct pci_dev *root = rdev->pdev->bus->self;
drivers/gpu/drm/radeon/evergreen.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/evergreen.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/r600.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/r600.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/r600_cp.c:	/* We don't support anything other than bus-mastering ring mode,
drivers/gpu/drm/radeon/radeon_acpi.c:	atcs_input.client_id = rdev->pdev->devfn | (rdev->pdev->bus->number << 8);
drivers/gpu/drm/radeon/radeon_atombios.c:			i2c_bus->valid = false;
drivers/gpu/drm/radeon/radeon_atombios.c:	    (i2c_bus->valid == false) &&
drivers/gpu/drm/radeon/radeon_atombios.c:			i2c_new_device(&rdev->pm.i2c_bus->adapter, &info);
drivers/gpu/drm/radeon/radeon_atombios.c:				i2c_new_device(&rdev->pm.i2c_bus->adapter, &info);
drivers/gpu/drm/radeon/radeon_bios.c:	if (vhdr->PCIBus != rdev->pdev->bus->number ||
drivers/gpu/drm/radeon/radeon_combios.c:				i2c_new_device(&rdev->pm.i2c_bus->adapter, &info);
drivers/gpu/drm/radeon/radeon_combios.c:				i2c_new_device(&rdev->pm.i2c_bus->adapter, &info);
drivers/gpu/drm/radeon/radeon_connectors.c:							      &radeon_connector->ddc_bus->adapter);
drivers/gpu/drm/radeon/radeon_connectors.c:		radeon_connector->edid = drm_get_edid(&radeon_connector->base, &radeon_connector->ddc_bus->adapter);
drivers/gpu/drm/radeon/radeon_connectors.c:		radeon_connector->edid = drm_get_edid(&radeon_connector->base, &radeon_connector->ddc_bus->adapter);
drivers/gpu/drm/radeon/radeon_connectors.c:					    (list_radeon_connector->ddc_bus->rec.i2c_id ==
drivers/gpu/drm/radeon/radeon_connectors.c:					     radeon_connector->ddc_bus->rec.i2c_id)) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (radeon_connector->ddc_bus && i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (radeon_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:			if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid)
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid) {
drivers/gpu/drm/radeon/radeon_connectors.c:		if (i2c_bus->valid)
drivers/gpu/drm/radeon/radeon_cp.c:	/* We don't support anything other than bus-mastering ring mode,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.mask_clk_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.mask_data_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.a_clk_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.a_data_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.en_clk_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.en_data_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.y_clk_reg,
drivers/gpu/drm/radeon/radeon_display.c:				 radeon_connector->ddc_bus->rec.y_data_reg);
drivers/gpu/drm/radeon/radeon_display.c:							      &dig->dp_i2c_bus->adapter);
drivers/gpu/drm/radeon/radeon_display.c:							      &dig->dp_i2c_bus->adapter);
drivers/gpu/drm/radeon/radeon_display.c:							      &radeon_connector->ddc_bus->adapter);
drivers/gpu/drm/radeon/radeon_display.c:							      &radeon_connector->ddc_bus->adapter);
drivers/gpu/drm/radeon/radeon_i2c.c:		ret = i2c_transfer(&dig->dp_i2c_bus->adapter, msgs, 2);
drivers/gpu/drm/radeon/radeon_i2c.c:		ret = i2c_transfer(&radeon_connector->ddc_bus->adapter, msgs, 2);
drivers/gpu/drm/radeon/radeon_i2c.c:		    (rdev->i2c_bus[i]->rec.i2c_id == i2c_bus->i2c_id)) {
drivers/gpu/drm/radeon/radeon_i2c.c:	if (i2c_transfer(&i2c_bus->adapter, msgs, 2) == 2) {
drivers/gpu/drm/radeon/radeon_i2c.c:	if (i2c_transfer(&i2c_bus->adapter, &msg, 1) != 1)
drivers/gpu/drm/radeon/rv770.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/rv770.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/si.c:	struct pci_dev *root = rdev->pdev->bus->self;
drivers/gpu/drm/radeon/si.c:				struct pci_dev *root = rdev->pdev->bus->self;
drivers/gpu/drm/tegra/bus.c:	const char *bus = dev->dev->bus->name;
drivers/gpu/vga/vga_switcheroo.c:	ret = dev->bus->pm->runtime_suspend(dev);
drivers/gpu/vga/vga_switcheroo.c:	ret = dev->bus->pm->runtime_resume(dev);
drivers/gpu/vga/vga_switcheroo.c:	if (dev->bus && dev->bus->pm) {
drivers/gpu/vga/vga_switcheroo.c:		domain->ops = *dev->bus->pm;
drivers/gpu/vga/vga_switcheroo.c:	ret = dev->bus->pm->runtime_resume(dev);
drivers/gpu/vga/vga_switcheroo.c:	if (dev->bus && dev->bus->pm) {
drivers/gpu/vga/vga_switcheroo.c:		domain->ops = *dev->bus->pm;
drivers/gpu/vga/vgaarb.c:		new_bridge = new_bus->self;
drivers/gpu/vga/vgaarb.c:			bridge = bus->self;
drivers/gpu/vga/vgaarb.c:				bridge = bus->self;
drivers/gpu/vga/vgaarb.c:					if (bridge == vgadev->pdev->bus->self)
drivers/gpu/vga/vgaarb.c:				bus = bus->parent;
drivers/gpu/vga/vgaarb.c:		new_bus = new_bus->parent;
drivers/gpu/vga/vgaarb.c:		bridge = bus->self;
drivers/gpu/vga/vgaarb.c:		bus = bus->parent;
drivers/hid/usbhid/hid-core.c:			hid_to_usb_dev(hid)->bus->bus_name,
drivers/hid/usbhid/hid-core.c:				hid_to_usb_dev(hid)->bus->bus_name,
drivers/hid/usbhid/hiddev.c:			dinfo.busnum = dev->bus->busnum;
drivers/hid/usbhid/usbkbd.c:			kbd->usbdev->bus->bus_name,
drivers/hid/usbhid/usbmouse.c:			mouse->usbdev->bus->bus_name,
drivers/hv/Makefile:hv_vmbus-y := vmbus_drv.o \
drivers/hwmon/max6697.c:	prop = of_get_property(node, "smbus-timeout-disable", &len);
drivers/hwmon/ultra45_env.c:		.compatible = "SUNW,ebus-pic16f747-env",
drivers/i2c/busses/Kconfig:	  will be called i2c-cbus-gpio.
drivers/i2c/busses/Makefile:obj-$(CONFIG_I2C_CBUS_GPIO)	+= i2c-cbus-gpio.o
drivers/i2c/busses/i2c-amd8111.c:	while ((inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_IBF) && --timeout)
drivers/i2c/busses/i2c-amd8111.c:		dev_warn(&smbus->dev->dev,
drivers/i2c/busses/i2c-amd8111.c:	while ((~inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_OBF) && --timeout)
drivers/i2c/busses/i2c-amd8111.c:		dev_warn(&smbus->dev->dev,
drivers/i2c/busses/i2c-amd8111.c:	outb(AMD_EC_CMD_RD, smbus->base + AMD_EC_CMD);
drivers/i2c/busses/i2c-amd8111.c:	outb(address, smbus->base + AMD_EC_DATA);
drivers/i2c/busses/i2c-amd8111.c:	*data = inb(smbus->base + AMD_EC_DATA);
drivers/i2c/busses/i2c-amd8111.c:	outb(AMD_EC_CMD_WR, smbus->base + AMD_EC_CMD);
drivers/i2c/busses/i2c-amd8111.c:	outb(address, smbus->base + AMD_EC_DATA);
drivers/i2c/busses/i2c-amd8111.c:	outb(data, smbus->base + AMD_EC_DATA);
drivers/i2c/busses/i2c-amd8111.c:	smbus->dev = dev;
drivers/i2c/busses/i2c-amd8111.c:	smbus->base = pci_resource_start(dev, 0);
drivers/i2c/busses/i2c-amd8111.c:	smbus->size = pci_resource_len(dev, 0);
drivers/i2c/busses/i2c-amd8111.c:	if (!request_region(smbus->base, smbus->size, amd8111_driver.name)) {
drivers/i2c/busses/i2c-amd8111.c:	smbus->adapter.owner = THIS_MODULE;
drivers/i2c/busses/i2c-amd8111.c:	snprintf(smbus->adapter.name, sizeof(smbus->adapter.name),
drivers/i2c/busses/i2c-amd8111.c:		"SMBus2 AMD8111 adapter at %04x", smbus->base);
drivers/i2c/busses/i2c-amd8111.c:	smbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
drivers/i2c/busses/i2c-amd8111.c:	smbus->adapter.algo = &smbus_algorithm;
drivers/i2c/busses/i2c-amd8111.c:	smbus->adapter.algo_data = smbus;
drivers/i2c/busses/i2c-amd8111.c:	smbus->adapter.dev.parent = &dev->dev;
drivers/i2c/busses/i2c-amd8111.c:	pci_write_config_dword(smbus->dev, AMD_PCI_MISC, 0);
drivers/i2c/busses/i2c-amd8111.c:	error = i2c_add_adapter(&smbus->adapter);
drivers/i2c/busses/i2c-amd8111.c:	release_region(smbus->base, smbus->size);
drivers/i2c/busses/i2c-amd8111.c:	i2c_del_adapter(&smbus->adapter);
drivers/i2c/busses/i2c-amd8111.c:	release_region(smbus->base, smbus->size);
drivers/i2c/busses/i2c-cbus-gpio.c:#include <linux/platform_data/i2c-cbus-gpio.h>
drivers/i2c/busses/i2c-cbus-gpio.c:	{ .compatible = "i2c-cbus-gpio", },
drivers/i2c/busses/i2c-cbus-gpio.c:		.name	= "i2c-cbus-gpio",
drivers/i2c/busses/i2c-cbus-gpio.c:MODULE_ALIAS("platform:i2c-cbus-gpio");
drivers/i2c/busses/i2c-diolan-u2c.c:		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum, frequency);
drivers/i2c/busses/i2c-diolan-u2c.c:		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
drivers/i2c/busses/i2c-nforce2-s4985.c:	error = nforce2_smbus->algo->smbus_xfer(adap, addr, flags, read_write,
drivers/i2c/busses/i2c-nforce2-s4985.c:		error = nforce2_smbus->algo->smbus_xfer(adap, 0x18, 0,
drivers/i2c/busses/i2c-nforce2-s4985.c:	error = nforce2_smbus->algo->smbus_xfer(adap, addr, flags, read_write,
drivers/i2c/busses/i2c-nforce2-s4985.c:		dev_err(&nforce2_smbus->dev, "PCA9556 configuration failed\n");
drivers/i2c/busses/i2c-nforce2-s4985.c:	s4985_algo[0] = *(nforce2_smbus->algo);
drivers/i2c/busses/i2c-nforce2-s4985.c:	s4985_adapter[0].dev.parent = nforce2_smbus->dev.parent;
drivers/i2c/busses/i2c-nforce2-s4985.c:		s4985_algo[i] = *(nforce2_smbus->algo);
drivers/i2c/busses/i2c-nforce2-s4985.c:		s4985_adapter[i].dev.parent = nforce2_smbus->dev.parent;
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_PRTCL	(smbus->base + 0x00)	/* protocol, PEC */
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_STS		(smbus->base + 0x01)	/* status */
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_ADDR		(smbus->base + 0x02)	/* address */
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_CMD		(smbus->base + 0x03)	/* command */
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_DATA		(smbus->base + 0x04)	/* 32 data registers */
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_BCNT		(smbus->base + 0x24)	/* number of data
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_STATUS_ABRT	(smbus->base + 0x3c)	/* register used to
drivers/i2c/busses/i2c-nforce2.c:#define NVIDIA_SMB_CTRL		(smbus->base + 0x3e)	/* control register */
drivers/i2c/busses/i2c-nforce2.c:		if (smbus->can_abort)
drivers/i2c/busses/i2c-nforce2.c:	smbus->base = pci_resource_start(dev, bar);
drivers/i2c/busses/i2c-nforce2.c:	if (smbus->base) {
drivers/i2c/busses/i2c-nforce2.c:		smbus->size = pci_resource_len(dev, bar);
drivers/i2c/busses/i2c-nforce2.c:		smbus->base = iobase & PCI_BASE_ADDRESS_IO_MASK;
drivers/i2c/busses/i2c-nforce2.c:		smbus->size = 64;
drivers/i2c/busses/i2c-nforce2.c:	error = acpi_check_region(smbus->base, smbus->size,
drivers/i2c/busses/i2c-nforce2.c:	if (!request_region(smbus->base, smbus->size, nforce2_driver.name)) {
drivers/i2c/busses/i2c-nforce2.c:		dev_err(&smbus->adapter.dev, "Error requesting region %02x .. %02X for %s\n",
drivers/i2c/busses/i2c-nforce2.c:			smbus->base, smbus->base+smbus->size-1, name);
drivers/i2c/busses/i2c-nforce2.c:	smbus->adapter.owner = THIS_MODULE;
drivers/i2c/busses/i2c-nforce2.c:	smbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
drivers/i2c/busses/i2c-nforce2.c:	smbus->adapter.algo = &smbus_algorithm;
drivers/i2c/busses/i2c-nforce2.c:	smbus->adapter.algo_data = smbus;
drivers/i2c/busses/i2c-nforce2.c:	smbus->adapter.dev.parent = &dev->dev;
drivers/i2c/busses/i2c-nforce2.c:	snprintf(smbus->adapter.name, sizeof(smbus->adapter.name),
drivers/i2c/busses/i2c-nforce2.c:		"SMBus nForce2 adapter at %04x", smbus->base);
drivers/i2c/busses/i2c-nforce2.c:	error = i2c_add_adapter(&smbus->adapter);
drivers/i2c/busses/i2c-nforce2.c:		dev_err(&smbus->adapter.dev, "Failed to register adapter.\n");
drivers/i2c/busses/i2c-nforce2.c:		release_region(smbus->base, smbus->size);
drivers/i2c/busses/i2c-nforce2.c:	dev_info(&smbus->adapter.dev, "nForce2 SMBus adapter at %#x\n",
drivers/i2c/busses/i2c-nforce2.c:		smbus->base);
drivers/i2c/busses/i2c-pasemi.c:	dev_dbg(&smbus->dev->dev, "smbus write reg %lx val %08x\n",
drivers/i2c/busses/i2c-pasemi.c:		smbus->base + reg, val);
drivers/i2c/busses/i2c-pasemi.c:	outl(val, smbus->base + reg);
drivers/i2c/busses/i2c-pasemi.c:	ret = inl(smbus->base + reg);
drivers/i2c/busses/i2c-pasemi.c:	dev_dbg(&smbus->dev->dev, "smbus read reg %lx val %08x\n",
drivers/i2c/busses/i2c-pasemi.c:		smbus->base + reg, ret);
drivers/i2c/busses/i2c-pasemi.c:		dev_warn(&smbus->dev->dev, "Timeout, status 0x%08x\n", status);
drivers/i2c/busses/i2c-pasemi.c:	smbus->dev = dev;
drivers/i2c/busses/i2c-pasemi.c:	smbus->base = pci_resource_start(dev, 0);
drivers/i2c/busses/i2c-pasemi.c:	smbus->size = pci_resource_len(dev, 0);
drivers/i2c/busses/i2c-pasemi.c:	if (!request_region(smbus->base, smbus->size,
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.owner = THIS_MODULE;
drivers/i2c/busses/i2c-pasemi.c:	snprintf(smbus->adapter.name, sizeof(smbus->adapter.name),
drivers/i2c/busses/i2c-pasemi.c:		 "PA Semi SMBus adapter at 0x%lx", smbus->base);
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.algo = &smbus_algorithm;
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.algo_data = smbus;
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.nr = PCI_FUNC(dev->devfn);
drivers/i2c/busses/i2c-pasemi.c:	smbus->adapter.dev.parent = &dev->dev;
drivers/i2c/busses/i2c-pasemi.c:	error = i2c_add_numbered_adapter(&smbus->adapter);
drivers/i2c/busses/i2c-pasemi.c:	release_region(smbus->base, smbus->size);
drivers/i2c/busses/i2c-pasemi.c:	i2c_del_adapter(&smbus->adapter);
drivers/i2c/busses/i2c-pasemi.c:	release_region(smbus->base, smbus->size);
drivers/i2c/busses/i2c-s3c2410.c:	of_property_read_u32(np, "samsung,i2c-max-bus-freq",
drivers/i2c/busses/i2c-tiny-usb.c:		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
drivers/i2c/busses/i2c-tiny-usb.c:		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
drivers/i2c/busses/i2c-viperboard.c:		 vb->usb_dev->bus->busnum, vb->usb_dev->devnum);
drivers/ide/ide-acpi.c:	bus = pdev->bus->number;
drivers/ide/ide-dma-sff.c: *	bus-mastering IDE controller behaviour.
drivers/ide/ide-gd.c:	drive->gendev.bus->suspend(&drive->gendev, PMSG_SUSPEND);
drivers/ide/pdc202xx_new.c:	struct pci_dev *bridge = dev->bus->self;
drivers/ide/pdc202xx_old.c:		struct pci_dev *bridge = dev->bus->self;
drivers/ide/pmac.c:	bidp = of_get_property(np, "AAPL,bus-id", NULL);
drivers/ide/pmac.c:	hw.dev = &mdev->bus->pdev->dev;
drivers/ide/sl82c105.c:	bridge = pci_get_bus_and_slot(dev->bus->number,
drivers/ide/trm290.c: * This module provides support for the bus-master IDE DMA function
drivers/infiniband/hw/amso1100/c2.c:	/* Enables bus-mastering on the device */
drivers/infiniband/hw/mlx4/main.c:				i, j, dev->pdev->bus->name);
drivers/infiniband/hw/nes/nes.c:			bus_number = nesdev->pcidev->bus->number;
drivers/infiniband/hw/nes/nes_hw.c:				nesdev->pcidev->bus->number );
drivers/infiniband/hw/nes/nes_hw.c:				(nesadapter->bus_number == nesdev->pcidev->bus->number)) {
drivers/infiniband/hw/nes/nes_hw.c:	nesadapter->bus_number = nesdev->pcidev->bus->number;
drivers/infiniband/hw/qib/qib_pcie.c:	parent = dd->pcidev->bus->self;
drivers/infiniband/hw/qib/qib_pcie.c:	if (parent->bus->parent) {
drivers/infiniband/hw/qib/qib_pcie.c: * BIOS may not set PCIe bus-utilization parameters for best performance.
drivers/infiniband/hw/qib/qib_pcie.c:	parent = dd->pcidev->bus->self;
drivers/input/misc/sparcspkr.c:		.compatible = "SUNW,smbus-beep",
drivers/input/tablet/acecad.c:			acecad->usbdev->bus->bus_name,
drivers/input/touchscreen/wm97xx-core.c:		return wm->ac97->bus->ops->read(wm->ac97, reg);
drivers/input/touchscreen/wm97xx-core.c:		wm->ac97->bus->ops->write(wm->ac97, reg, val);
drivers/input/touchscreen/wm97xx-core.c:	wm->ac97->bus->ops->write(wm->ac97, AC97_WM97XX_DIGITISER2, reg);
drivers/iommu/amd_iommu.c:	return PCI_DEVID(pdev->bus->number, pdev->devfn);
drivers/iommu/amd_iommu.c:	while (!bus->self) {
drivers/iommu/amd_iommu.c:			bus = bus->parent;
drivers/iommu/amd_iommu.c:		if (pci_acs_path_enabled(bus->self, NULL, REQ_ACS_FLAGS))
drivers/iommu/amd_iommu.c:		swap_pci_ref(&dma_pdev, pci_dev_get(bus->self));
drivers/iommu/amd_iommu.c:		if (IS_ERR(bus) || !bus->self)
drivers/iommu/amd_iommu.c:		dma_pdev = get_isolation_root(pci_dev_get(bus->self));
drivers/iommu/amd_iommu.c:		if (dma_pdev != bus->self || (dma_pdev->multifunction &&
drivers/iommu/amd_iommu_init.c:		iommu->root_pdev = pci_get_bus_and_slot(iommu->dev->bus->number,
drivers/iommu/amd_iommu_v2.c:	devid = pdev->bus->number;
drivers/iommu/dmar.c:		dev = dev->bus->self;
drivers/iommu/fsl_pamu_domain.c:		list_for_each_entry(tmp, &bus->devices, bus_list) {
drivers/iommu/fsl_pamu_domain.c:		bus = bus->parent;
drivers/iommu/fsl_pamu_domain.c:			while (!bus->self) {
drivers/iommu/fsl_pamu_domain.c:					bus = bus->parent;
drivers/iommu/fsl_pamu_domain.c:			if (pci_acs_path_enabled(bus->self, NULL, REQ_ACS_FLAGS))
drivers/iommu/fsl_pamu_domain.c:			swap_pci_ref(&dma_pdev, pci_dev_get(bus->self));
drivers/iommu/intel-iommu.c:			    drhd->devices[i]->bus->number == bus &&
drivers/iommu/intel-iommu.c:					 pdev->bus->number, pdev->devfn,
drivers/iommu/intel-iommu.c:	parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:						 parent->bus->number,
drivers/iommu/intel-iommu.c:		parent = parent->bus->self;
drivers/iommu/intel-iommu.c:						  tmp->bus->number,
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:	ret = device_context_mapped(iommu, pdev->bus->number, pdev->devfn);
drivers/iommu/intel-iommu.c:	parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:		ret = device_context_mapped(iommu, parent->bus->number,
drivers/iommu/intel-iommu.c:		parent = parent->bus->self;
drivers/iommu/intel-iommu.c:		return device_context_mapped(iommu, tmp->bus->number,
drivers/iommu/intel-iommu.c:			bus = dev_tmp->bus->number;
drivers/iommu/intel-iommu.c:	info->bus = pdev->bus->number;
drivers/iommu/intel-iommu.c:	info->bus = pdev->bus->number;
drivers/iommu/intel-iommu.c:	for (bus = dev->bus; bus; bus = bus->parent) {
drivers/iommu/intel-iommu.c:		struct pci_dev *bridge = bus->self;
drivers/iommu/intel-iommu.c:		parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:			iommu_detach_dev(iommu, parent->bus->number,
drivers/iommu/intel-iommu.c:			parent = parent->bus->self;
drivers/iommu/intel-iommu.c:			iommu_detach_dev(iommu, tmp->bus->number,
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:		    info->bus == pdev->bus->number &&
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:			     pdev->bus->number, pdev->devfn))
drivers/iommu/intel-iommu.c:		while (!bus->self) {
drivers/iommu/intel-iommu.c:				bus = bus->parent;
drivers/iommu/intel-iommu.c:		if (pci_acs_path_enabled(bus->self, NULL, REQ_ACS_FLAGS))
drivers/iommu/intel-iommu.c:		swap_pci_ref(&dma_pdev, pci_dev_get(bus->self));
drivers/iommu/intel_irq_remapping.c:	if (pci_is_pcie(dev) || !dev->bus->parent) {
drivers/iommu/intel_irq_remapping.c:			     (dev->bus->number << 8) | dev->devfn);
drivers/iommu/intel_irq_remapping.c:				(bridge->bus->number << 8) | dev->bus->number);
drivers/iommu/intel_irq_remapping.c:				(bridge->bus->number << 8) | bridge->devfn);
drivers/iommu/iommu.c:	struct iommu_ops *ops = dev->bus->iommu_ops;
drivers/iommu/iommu.c:	if (bus->iommu_ops != NULL)
drivers/iommu/iommu.c:	bus->iommu_ops = ops;
drivers/iommu/iommu.c:	/* Do IOMMU specific setup for this bus-type */
drivers/iommu/iommu.c:	return bus->iommu_ops != NULL;
drivers/iommu/iommu.c:	if (bus == NULL || bus->iommu_ops == NULL)
drivers/iommu/iommu.c:	domain->ops = bus->iommu_ops;
drivers/ipack/carriers/tpci200.c:	tpci200 = dev_get_drvdata(dev->bus->parent);
drivers/ipack/carriers/tpci200.c:			 dev->bus->bus_nr, dev->slot, TPCI200_NB_SLOT-1);
drivers/ipack/carriers/tpci200.c:			dev->bus->bus_nr,
drivers/ipack/carriers/tpci200.c:			dev->bus->bus_nr, dev->slot);
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:	tpci200->number = tpci200->info->ipack_bus->bus_nr;
drivers/ipack/devices/ipoctal.c:	ipoctal->dev->bus->ops->request_irq(ipoctal->dev,
drivers/ipack/devices/ipoctal.c:	res = ipoctal_inst_slot(ipoctal, dev->bus->bus_nr, dev->slot);
drivers/ipack/devices/ipoctal.c:	ipoctal->dev->bus->ops->free_irq(ipoctal->dev);
drivers/ipack/ipack.c:	bus->bus_nr = bus_nr;
drivers/ipack/ipack.c:	bus->parent = parent;
drivers/ipack/ipack.c:	bus->slots = slots;
drivers/ipack/ipack.c:	bus->ops = ops;
drivers/ipack/ipack.c:	ida_simple_remove(&ipack_ida, bus->bus_nr);
drivers/ipack/ipack.c:	dev->dev.parent = dev->bus->parent;
drivers/ipack/ipack.c:		     "ipack-dev.%u.%u", dev->bus->bus_nr, dev->slot);
drivers/ipack/ipack.c:	if (dev->bus->ops->set_clockrate(dev, 8))
drivers/ipack/ipack.c:	if (dev->bus->ops->reset_timeout(dev))
drivers/ipack/ipack.c:		ret = dev->bus->ops->set_clockrate(dev, 32);
drivers/isdn/hardware/eicon/divasmain.c:	return ((byte) pdev->bus->number);
drivers/isdn/hardware/eicon/divasmain.c:		 pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:		       pdev->bus->number, pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			       Name, pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			 DRIVERLNAME, pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:			       DRIVERLNAME, pdev->bus->number, pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			       Name, pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:		 pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:		       DRIVERLNAME, pdev->bus->number, pdev->devfn);
drivers/isdn/hisax/bkm_a8.c:				pci_bus = dev_a8->bus->number;
drivers/isdn/hysdn/hysdn_init.c:	card->bus = akt_pcidev->bus->number;
drivers/macintosh/macio_asic.c:	if (dev->bus->chip->type != macio_gatwick)
drivers/macintosh/rack-meter.c:	struct macio_chip *macio = rm->mdev->bus->chip;
drivers/media/common/b2c2/flexcop.c: * struct flexcop_device from the bus-parts */
drivers/media/common/saa7146/saa7146_core.c:	/* enable bus-mastering */
drivers/media/pci/bt8xx/bt878.c:	       bt878_num, bt->id, bt->revision, dev->bus->number,
drivers/media/pci/bt8xx/bt878.c:	/* disable PCI bus-mastering */
drivers/media/pci/bt8xx/dvb-bt8xx.c:		(adev->bus->number == bdev->bus->number) &&
drivers/media/pci/cx18/cx18-driver.c:		   cx->pci_dev->device, cx->card_rev, pci_dev->bus->number,
drivers/media/pci/cx23885/cx23885-core.c:	dev->pci_bus  = dev->pci->bus->number;
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					       &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					       &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					   &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					   &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap, 0x61,
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:				.i2c_adap  = &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:							&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					       &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				.i2c_adap  = &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					       &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				&tevii_ts2020_config, &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:							&i2c_bus->i2c_adap, 0);
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap)) {
drivers/media/pci/cx23885/cx23885-dvb.c:							&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:							&i2c_bus->i2c_adap, 1);
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap)) {
drivers/media/pci/cx23885/cx23885-dvb.c:							&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:				&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				&tevii_ts2020_config, &i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-dvb.c:					&i2c_bus->i2c_adap))
drivers/media/pci/cx23885/cx23885-dvb.c:						&i2c_bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-dvb.c:				   &i2c_bus->i2c_adap,
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:	return cx_read(bus->reg_stat) & 0x01;
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:	return cx_read(bus->reg_stat) & 0x02 ? 1 : 0;
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));
drivers/media/pci/cx23885/cx23885-i2c.c:	ctrl = bus->i2c_period | (1 << 12) | (1 << 2);
drivers/media/pci/cx23885/cx23885-i2c.c:	cx_write(bus->reg_addr, addr);
drivers/media/pci/cx23885/cx23885-i2c.c:	cx_write(bus->reg_wdata, wdata);
drivers/media/pci/cx23885/cx23885-i2c.c:	cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx23885/cx23885-i2c.c:		ctrl = bus->i2c_period | (1 << 12) | (1 << 2);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_addr, addr);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_wdata, wdata);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);
drivers/media/pci/cx23885/cx23885-i2c.c:		ctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx23885/cx23885-i2c.c:		cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx23885/cx23885-i2c.c:		msg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:	struct cx23885_dev *dev = bus->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:	dprintk(1, "%s(bus = %d)\n", __func__, bus->nr);
drivers/media/pci/cx23885/cx23885-i2c.c:	bus->i2c_adap = cx23885_i2c_adap_template;
drivers/media/pci/cx23885/cx23885-i2c.c:	bus->i2c_client = cx23885_i2c_client_template;
drivers/media/pci/cx23885/cx23885-i2c.c:	bus->i2c_adap.dev.parent = &dev->pci->dev;
drivers/media/pci/cx23885/cx23885-i2c.c:	strlcpy(bus->i2c_adap.name, bus->dev->name,
drivers/media/pci/cx23885/cx23885-i2c.c:		sizeof(bus->i2c_adap.name));
drivers/media/pci/cx23885/cx23885-i2c.c:	bus->i2c_adap.algo_data = bus;
drivers/media/pci/cx23885/cx23885-i2c.c:	i2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);
drivers/media/pci/cx23885/cx23885-i2c.c:	i2c_add_adapter(&bus->i2c_adap);
drivers/media/pci/cx23885/cx23885-i2c.c:	bus->i2c_client.adapter = &bus->i2c_adap;
drivers/media/pci/cx23885/cx23885-i2c.c:	if (0 == bus->i2c_rc) {
drivers/media/pci/cx23885/cx23885-i2c.c:		dprintk(1, "%s: i2c bus %d registered\n", dev->name, bus->nr);
drivers/media/pci/cx23885/cx23885-i2c.c:					dev->name, bus->nr);
drivers/media/pci/cx23885/cx23885-i2c.c:			do_i2c_scan(dev->name, &bus->i2c_client);
drivers/media/pci/cx23885/cx23885-i2c.c:			dev->name, bus->nr);
drivers/media/pci/cx23885/cx23885-i2c.c:	if (0 == bus->i2c_rc) {
drivers/media/pci/cx23885/cx23885-i2c.c:		i2c_new_probed_device(&bus->i2c_adap, &info, addr_list,
drivers/media/pci/cx23885/cx23885-i2c.c:	return bus->i2c_rc;
drivers/media/pci/cx23885/cx23885-i2c.c:	i2c_del_adapter(&bus->i2c_adap);
drivers/media/pci/cx23885/netup-init.c:	struct i2c_adapter *i2c = &i2c_bus->i2c_adap;
drivers/media/pci/cx25821/cx25821-core.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-core.c:	return cx_read(bus->reg_stat) & 0x01;
drivers/media/pci/cx25821/cx25821-core.c:	dev->pci_bus = dev->pci->bus->number;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:	return cx_read(bus->reg_stat) & 0x01;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:	return cx_read(bus->reg_stat) & 0x02 ? 1 : 0;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));
drivers/media/pci/cx25821/cx25821-i2c.c:	ctrl = bus->i2c_period | (1 << 12) | (1 << 2);
drivers/media/pci/cx25821/cx25821-i2c.c:	cx_write(bus->reg_addr, addr);
drivers/media/pci/cx25821/cx25821-i2c.c:	cx_write(bus->reg_wdata, wdata);
drivers/media/pci/cx25821/cx25821-i2c.c:	cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx25821/cx25821-i2c.c:		ctrl = bus->i2c_period | (1 << 12) | (1 << 2);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_addr, addr);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_wdata, wdata);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);
drivers/media/pci/cx25821/cx25821-i2c.c:		ctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_addr, msg->addr << 25);
drivers/media/pci/cx25821/cx25821-i2c.c:		cx_write(bus->reg_ctrl, ctrl);
drivers/media/pci/cx25821/cx25821-i2c.c:		msg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct cx25821_dev *dev = bus->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:	dprintk(1, "%s(bus = %d)\n", __func__, bus->nr);
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_adap = cx25821_i2c_adap_template;
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_client = cx25821_i2c_client_template;
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_adap.dev.parent = &dev->pci->dev;
drivers/media/pci/cx25821/cx25821-i2c.c:	strlcpy(bus->i2c_adap.name, bus->dev->name, sizeof(bus->i2c_adap.name));
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_adap.algo_data = bus;
drivers/media/pci/cx25821/cx25821-i2c.c:	i2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);
drivers/media/pci/cx25821/cx25821-i2c.c:	i2c_add_adapter(&bus->i2c_adap);
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_client.adapter = &bus->i2c_adap;
drivers/media/pci/cx25821/cx25821-i2c.c:	bus->i2c_client.addr = (0x88 >> 1);
drivers/media/pci/cx25821/cx25821-i2c.c:	return bus->i2c_rc;
drivers/media/pci/cx25821/cx25821-i2c.c:	i2c_del_adapter(&bus->i2c_adap);
drivers/media/pci/cx25821/cx25821-i2c.c:	struct i2c_client *client = &bus->i2c_client;
drivers/media/pci/cx25821/cx25821-i2c.c:	struct i2c_client *client = &bus->i2c_client;
drivers/media/pci/cx88/cx88-cards.c:	core->pci_bus  = pci->bus->number;
drivers/media/pci/cx88/cx88-core.c:		if (pci->bus->number != core->pci_bus)
drivers/media/pci/ivtv/ivtv-driver.c:		   pdev->device, pdev->revision, pdev->bus->number,
drivers/media/pci/mantis/mantis_core.c:		mantis->pdev->bus->number, PCI_SLOT(mantis->pdev->devfn), PCI_FUNC(mantis->pdev->devfn));
drivers/media/pci/mantis/mantis_pci.c:		mantis->pdev->bus->number,
drivers/media/pci/saa7164/saa7164-api.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-api.c:	ret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,
drivers/media/pci/saa7164/saa7164-api.c:	ret = saa7164_cmd_send(bus->dev, unitid, GET_CUR,
drivers/media/pci/saa7164/saa7164-api.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-api.c:	ret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,
drivers/media/pci/saa7164/saa7164-api.c:	ret = saa7164_cmd_send(bus->dev, unitid, SET_CUR,
drivers/media/pci/saa7164/saa7164-bus.c:	mutex_lock(&bus->lock);
drivers/media/pci/saa7164/saa7164-bus.c:	curr_srp = le32_to_cpu(saa7164_readl(bus->m_dwSetReadPos));
drivers/media/pci/saa7164/saa7164-bus.c:	curr_swp = le32_to_cpu(saa7164_readl(bus->m_dwSetWritePos));
drivers/media/pci/saa7164/saa7164-bus.c:		free_write_space = (curr_srp + bus->m_dwSizeSetRing) - curr_swp;
drivers/media/pci/saa7164/saa7164-bus.c:		curr_srp = le32_to_cpu(saa7164_readl(bus->m_dwSetReadPos));
drivers/media/pci/saa7164/saa7164-bus.c:			free_write_space = (curr_srp + bus->m_dwSizeSetRing) -
drivers/media/pci/saa7164/saa7164-bus.c:	dprintk(DBGLVL_BUS, "%s() bus->m_dwSizeSetRing = %x\n", __func__,
drivers/media/pci/saa7164/saa7164-bus.c:		bus->m_dwSizeSetRing);
drivers/media/pci/saa7164/saa7164-bus.c:	if (new_swp > bus->m_dwSizeSetRing) {
drivers/media/pci/saa7164/saa7164-bus.c:		new_swp -= bus->m_dwSizeSetRing;
drivers/media/pci/saa7164/saa7164-bus.c:		space_rem = bus->m_dwSizeSetRing - curr_swp;
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing + curr_swp, msg, space_rem);
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing, (u8 *)msg + space_rem,
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing + sizeof(*msg) - space_rem,
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing, buf, msg->size);
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:				memcpy(bus->m_pdwSetRing + curr_swp +
drivers/media/pci/saa7164/saa7164-bus.c:				memcpy(bus->m_pdwSetRing, (u8 *)buf +
drivers/media/pci/saa7164/saa7164-bus.c:	} /* (new_swp > bus->m_dwSizeSetRing) */
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy(bus->m_pdwSetRing + curr_swp + sizeof(*msg), buf,
drivers/media/pci/saa7164/saa7164-bus.c:	saa7164_writel(bus->m_dwSetWritePos, cpu_to_le32(new_swp));
drivers/media/pci/saa7164/saa7164-bus.c:	mutex_unlock(&bus->lock);
drivers/media/pci/saa7164/saa7164-bus.c:	mutex_lock(&bus->lock);
drivers/media/pci/saa7164/saa7164-bus.c:	curr_gwp = le32_to_cpu(saa7164_readl(bus->m_dwGetWritePos));
drivers/media/pci/saa7164/saa7164-bus.c:	curr_grp = le32_to_cpu(saa7164_readl(bus->m_dwGetReadPos));
drivers/media/pci/saa7164/saa7164-bus.c:		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
drivers/media/pci/saa7164/saa7164-bus.c:	if (new_grp > bus->m_dwSizeGetRing) {
drivers/media/pci/saa7164/saa7164-bus.c:		new_grp -= bus->m_dwSizeGetRing;
drivers/media/pci/saa7164/saa7164-bus.c:		space_rem = bus->m_dwSizeGetRing - curr_grp;
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);
drivers/media/pci/saa7164/saa7164-bus.c:		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
drivers/media/pci/saa7164/saa7164-bus.c:	if (new_grp > bus->m_dwSizeGetRing) {
drivers/media/pci/saa7164/saa7164-bus.c:		new_grp -= bus->m_dwSizeGetRing;
drivers/media/pci/saa7164/saa7164-bus.c:		space_rem = bus->m_dwSizeGetRing - curr_grp;
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(msg, bus->m_pdwGetRing + curr_grp, space_rem);
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy((u8 *)msg + space_rem, bus->m_pdwGetRing,
drivers/media/pci/saa7164/saa7164-bus.c:				memcpy(buf, bus->m_pdwGetRing + sizeof(*msg) -
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:				memcpy(buf, bus->m_pdwGetRing, buf_size);
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:				memcpy(buf, bus->m_pdwGetRing + curr_grp +
drivers/media/pci/saa7164/saa7164-bus.c:					bus->m_pdwGetRing, bytes_to_read -
drivers/media/pci/saa7164/saa7164-bus.c:		memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
drivers/media/pci/saa7164/saa7164-bus.c:			memcpy(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
drivers/media/pci/saa7164/saa7164-bus.c:	saa7164_writel(bus->m_dwGetReadPos, cpu_to_le32(new_grp));
drivers/media/pci/saa7164/saa7164-bus.c:	mutex_unlock(&bus->lock);
drivers/media/pci/saa7164/saa7164-cards.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-cards.c:		if ((bus->nr == unit->i2c_bus_nr) &&
drivers/media/pci/saa7164/saa7164-cards.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-cards.c:		if ((bus->nr == unit->i2c_bus_nr) &&
drivers/media/pci/saa7164/saa7164-cmd.c:	cmds = size / bus->m_wMaxReqSize;
drivers/media/pci/saa7164/saa7164-cmd.c:	if (size % bus->m_wMaxReqSize == 0)
drivers/media/pci/saa7164/saa7164-cmd.c:		msg->size = bus->m_wMaxReqSize;
drivers/media/pci/saa7164/saa7164-cmd.c:		tmp = buf + idx * bus->m_wMaxReqSize;
drivers/media/pci/saa7164/saa7164-cmd.c:	msg->size = size - idx * bus->m_wMaxReqSize;
drivers/media/pci/saa7164/saa7164-cmd.c:	ret = saa7164_bus_set(dev, msg, buf + idx * bus->m_wMaxReqSize);
drivers/media/pci/saa7164/saa7164-core.c:	dev->pci_bus  = dev->pci->bus->number;
drivers/media/pci/saa7164/saa7164-dvb.c:				&i2c_bus->i2c_adap);
drivers/media/pci/saa7164/saa7164-dvb.c:					0xc0 >> 1, &i2c_bus->i2c_adap,
drivers/media/pci/saa7164/saa7164-dvb.c:				&i2c_bus->i2c_adap);
drivers/media/pci/saa7164/saa7164-dvb.c:					0xc0 >> 1, &i2c_bus->i2c_adap,
drivers/media/pci/saa7164/saa7164-dvb.c:			&i2c_bus->i2c_adap);
drivers/media/pci/saa7164/saa7164-dvb.c:					0xc0 >> 1, &i2c_bus->i2c_adap,
drivers/media/pci/saa7164/saa7164-dvb.c:					0xc0 >> 1, &i2c_bus->i2c_adap,
drivers/media/pci/saa7164/saa7164-i2c.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-i2c.c:	struct saa7164_dev *dev = bus->dev;
drivers/media/pci/saa7164/saa7164-i2c.c:	dprintk(DBGLVL_I2C, "%s(bus = %d)\n", __func__, bus->nr);
drivers/media/pci/saa7164/saa7164-i2c.c:	bus->i2c_adap = saa7164_i2c_adap_template;
drivers/media/pci/saa7164/saa7164-i2c.c:	bus->i2c_client = saa7164_i2c_client_template;
drivers/media/pci/saa7164/saa7164-i2c.c:	bus->i2c_adap.dev.parent = &dev->pci->dev;
drivers/media/pci/saa7164/saa7164-i2c.c:	strlcpy(bus->i2c_adap.name, bus->dev->name,
drivers/media/pci/saa7164/saa7164-i2c.c:		sizeof(bus->i2c_adap.name));
drivers/media/pci/saa7164/saa7164-i2c.c:	bus->i2c_adap.algo_data = bus;
drivers/media/pci/saa7164/saa7164-i2c.c:	i2c_set_adapdata(&bus->i2c_adap, bus);
drivers/media/pci/saa7164/saa7164-i2c.c:	i2c_add_adapter(&bus->i2c_adap);
drivers/media/pci/saa7164/saa7164-i2c.c:	bus->i2c_client.adapter = &bus->i2c_adap;
drivers/media/pci/saa7164/saa7164-i2c.c:	if (0 != bus->i2c_rc)
drivers/media/pci/saa7164/saa7164-i2c.c:			dev->name, bus->nr);
drivers/media/pci/saa7164/saa7164-i2c.c:	return bus->i2c_rc;
drivers/media/pci/saa7164/saa7164-i2c.c:	i2c_del_adapter(&bus->i2c_adap);
drivers/media/pci/zoran/zoran_card.c:	/* disable PCI bus-mastering */
drivers/media/pci/zoran/zoran_device.c:	/* Enable bus-mastering */
drivers/media/platform/exynos4-is/mipi-csis.c:	if (of_property_read_u32(node, "bus-width",
drivers/media/platform/omap3isp/ispvideo.c:	pix->width = mbus->width;
drivers/media/platform/omap3isp/ispvideo.c:	pix->height = mbus->height;
drivers/media/platform/omap3isp/ispvideo.c:		if (formats[i].code == mbus->code)
drivers/media/platform/omap3isp/ispvideo.c:	pix->colorspace = mbus->colorspace;
drivers/media/platform/omap3isp/ispvideo.c:	pix->field = mbus->field;
drivers/media/platform/omap3isp/ispvideo.c:	mbus->width = pix->width;
drivers/media/platform/omap3isp/ispvideo.c:	mbus->height = pix->height;
drivers/media/platform/omap3isp/ispvideo.c:	mbus->code = formats[i].code;
drivers/media/platform/omap3isp/ispvideo.c:	mbus->colorspace = pix->colorspace;
drivers/media/platform/omap3isp/ispvideo.c:	mbus->field = pix->field;
drivers/media/platform/sh_vou.c:		pr_warning("%s(): Invalid bus-format code %d, using default 8-bit\n",
drivers/media/platform/soc_camera/mx3_camera.c:	/* Set generic data, platform-biggest bus-width */
drivers/media/rc/imon.c:		 usbdev->bus->busnum, usbdev->devnum);
drivers/media/rc/keymaps/rc-pctv-sedna.c:   http://www.sednacomputer.com/photo/cardbus-tv.jpg
drivers/media/rc/streamzap.c:		 usbdev->bus->busnum, usbdev->devnum);
drivers/media/usb/cx231xx/cx231xx-core.c:	struct cx231xx *dev = i2c_bus->dev;
drivers/media/usb/cx231xx/cx231xx-core.c:	_i2c_period = i2c_bus->i2c_period;
drivers/media/usb/cx231xx/cx231xx-core.c:	_i2c_nostop = i2c_bus->i2c_nostop;
drivers/media/usb/cx231xx/cx231xx-core.c:	_i2c_reserve = i2c_bus->i2c_reserve;
drivers/media/usb/cx231xx/cx231xx-core.c:		ven_req.bRequest = i2c_bus->nr + 4;
drivers/media/usb/cx231xx/cx231xx-core.c:		ven_req.bRequest = i2c_bus->nr;	/* channel number,  */
drivers/media/usb/cx231xx/cx231xx-i2c.c:	if (bus->nr != dev->board.tuner_i2c_master)
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:			bus->i2c_nostop = (size > 16) ? 1 : 0;
drivers/media/usb/cx231xx/cx231xx-i2c.c:			bus->i2c_reserve = (loop == 0) ? 0 : 1;
drivers/media/usb/cx231xx/cx231xx-i2c.c:		bus->i2c_nostop = 0;
drivers/media/usb/cx231xx/cx231xx-i2c.c:		bus->i2c_reserve = 0;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:			   && (msgs[i].len <= 2) && (bus->nr < 3)) {
drivers/media/usb/cx231xx/cx231xx-i2c.c:	struct cx231xx *dev = bus->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	bus->i2c_adap = cx231xx_adap_template;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	bus->i2c_client = cx231xx_client_template;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	bus->i2c_adap.dev.parent = &dev->udev->dev;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	strlcpy(bus->i2c_adap.name, bus->dev->name, sizeof(bus->i2c_adap.name));
drivers/media/usb/cx231xx/cx231xx-i2c.c:	bus->i2c_adap.algo_data = bus;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	i2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);
drivers/media/usb/cx231xx/cx231xx-i2c.c:	i2c_add_adapter(&bus->i2c_adap);
drivers/media/usb/cx231xx/cx231xx-i2c.c:	bus->i2c_client.adapter = &bus->i2c_adap;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	if (0 == bus->i2c_rc) {
drivers/media/usb/cx231xx/cx231xx-i2c.c:			cx231xx_do_i2c_scan(dev, &bus->i2c_client);
drivers/media/usb/cx231xx/cx231xx-i2c.c:			     dev->name, bus->nr);
drivers/media/usb/cx231xx/cx231xx-i2c.c:	return bus->i2c_rc;
drivers/media/usb/cx231xx/cx231xx-i2c.c:	i2c_del_adapter(&bus->i2c_adap);
drivers/media/usb/cx231xx/cx231xx-pcb-cfg.c:	if (config_info & BUS_POWER) {	/* bus-power */
drivers/media/usb/cx231xx/cx231xx-pcb-cfg.h:	u8 digital_index;	/* bus-power used */
drivers/media/usb/cx231xx/cx231xx-pcb-cfg.h:	u8 analog_index;	/* bus-power used */
drivers/media/usb/cx231xx/cx231xx-pcb-cfg.h:	u8 dif_index;		/* bus-power used */
drivers/media/usb/cx231xx/cx231xx-pcb-cfg.h:	u8 external_index;	/* bus-power used */
drivers/media/usb/em28xx/em28xx-cards.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-dvb.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-dvb.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-dvb.c:        struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-i2c.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-i2c.c:	if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)
drivers/media/usb/em28xx/em28xx-i2c.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-i2c.c:	if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)
drivers/media/usb/em28xx/em28xx-i2c.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-i2c.c:	if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)
drivers/media/usb/em28xx/em28xx-i2c.c:	else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)
drivers/media/usb/em28xx/em28xx-i2c.c:	struct em28xx *dev = i2c_bus->dev;
drivers/media/usb/em28xx/em28xx-i2c.c:	unsigned bus = i2c_bus->bus;
drivers/media/usb/em28xx/em28xx-i2c.c:	    i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX) {
drivers/media/usb/em28xx/em28xx-i2c.c:	if ((i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX) ||
drivers/media/usb/em28xx/em28xx-i2c.c:	    (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)) {
drivers/media/usb/em28xx/em28xx-i2c.c:	} else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)  {
drivers/media/usb/siano/smsusb.c:			 udev->bus->busnum, udev->devpath);
drivers/media/usb/tm6000/tm6000-alsa.c:		dev->udev->bus->busnum, dev->udev->devnum);
drivers/media/usb/usbvision/usbvision-i2c.c:		usbvision->dev->bus->busnum, usbvision->dev->devpath);
drivers/media/usb/uvc/uvc_debugfs.c:	sprintf(dir_name, "%u-%u", udev->bus->busnum, udev->devnum);
drivers/media/v4l2-core/v4l2-of.c:	u32 data_lanes[ARRAY_SIZE(bus->data_lanes)];
drivers/media/v4l2-core/v4l2-of.c:		bus->num_data_lanes = i;
drivers/media/v4l2-core/v4l2-of.c:			bus->data_lanes[i] = data_lanes[i];
drivers/media/v4l2-core/v4l2-of.c:		bus->clock_lane = v;
drivers/media/v4l2-core/v4l2-of.c:	else if (have_clk_lane || bus->num_data_lanes > 0)
drivers/media/v4l2-core/v4l2-of.c:	bus->flags = flags;
drivers/media/v4l2-core/v4l2-of.c:	if (!of_property_read_u32(node, "bus-width", &v))
drivers/media/v4l2-core/v4l2-of.c:		bus->bus_width = v;
drivers/media/v4l2-core/v4l2-of.c:		bus->data_shift = v;
drivers/media/v4l2-core/v4l2-of.c:	bus->flags = flags;
drivers/memory/mvebu-devbus.c:		dev_err(devbus->dev, "%s has no '%s' property\n",
drivers/memory/mvebu-devbus.c:	*ticks = (time_ps + devbus->tick_ps - 1) / devbus->tick_ps;
drivers/memory/mvebu-devbus.c:	dev_dbg(devbus->dev, "%s: %u ps -> 0x%x\n",
drivers/memory/mvebu-devbus.c:	dev_dbg(devbus->dev, "Setting timing parameter, tick is %lu ps\n",
drivers/memory/mvebu-devbus.c:		devbus->tick_ps);
drivers/memory/mvebu-devbus.c:	err = of_property_read_u32(node, "devbus,bus-width", &r.bus_width);
drivers/memory/mvebu-devbus.c:		dev_err(devbus->dev,
drivers/memory/mvebu-devbus.c:			"%s has no 'devbus,bus-width' property\n",
drivers/memory/mvebu-devbus.c:		dev_err(devbus->dev,
drivers/memory/mvebu-devbus.c:	dev_dbg(devbus->dev, "read parameters register 0x%p = 0x%x\n",
drivers/memory/mvebu-devbus.c:		devbus->base + READ_PARAM_OFFSET,
drivers/memory/mvebu-devbus.c:	writel(value, devbus->base + READ_PARAM_OFFSET);
drivers/memory/mvebu-devbus.c:	dev_dbg(devbus->dev, "write parameters register: 0x%p = 0x%x\n",
drivers/memory/mvebu-devbus.c:		devbus->base + WRITE_PARAM_OFFSET,
drivers/memory/mvebu-devbus.c:	writel(value, devbus->base + WRITE_PARAM_OFFSET);
drivers/memory/mvebu-devbus.c:	devbus->dev = dev;
drivers/memory/mvebu-devbus.c:	devbus->base = devm_ioremap_resource(&pdev->dev, res);
drivers/memory/mvebu-devbus.c:	if (IS_ERR(devbus->base))
drivers/memory/mvebu-devbus.c:		return PTR_ERR(devbus->base);
drivers/memory/mvebu-devbus.c:	devbus->tick_ps = 1000000000 / rate;
drivers/message/fusion/mptbase.c:	    ioc->name, pci_name(pdev), pdev->bus->number,
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
drivers/message/fusion/mptctl.c:	karg.bus = pdev->bus->number;
drivers/message/i2o/Makefile:i2o_bus-y		+= bus-osm.o
drivers/message/i2o/bus-osm.c:#define OSM_NAME	"bus-osm"
drivers/message/i2o/iop.c:		res->name = c->pdev->bus->name;
drivers/message/i2o/iop.c:		res->name = c->pdev->bus->name;
drivers/mfd/sm501.c:	 * for 33MHZ PCI with proper bus-mastering operation */
drivers/mfd/viperboard.c:		 vb->usb_dev->bus->busnum, vb->usb_dev->devnum);
drivers/misc/ibmasm/module.c:	/* vnc client won't work without bus-mastering */
drivers/misc/ibmasm/module.c:	sp->number = pdev->bus->number;
drivers/misc/ioc4.c:		    idd->idd_pdev->bus->number == pdev->bus->number &&
drivers/misc/ioc4.c:		    idd->idd_pdev->bus->number == pdev->bus->number &&
drivers/mmc/core/host.c:	/* "bus-width" is translated to MMC_CAP_*_BIT_DATA flags */
drivers/mmc/core/host.c:	if (of_property_read_u32(np, "bus-width", &bus_width) < 0) {
drivers/mmc/core/host.c:			"\"bus-width\" property is missing, assuming 1 bit.\n");
drivers/mmc/core/host.c:			"Invalid \"bus-width\" value %ud!\n", bus_width);
drivers/mmc/host/atmel-mci.c:		if (of_property_read_u32(cnp, "bus-width",
drivers/mmc/host/davinci_mmc.c:	of_property_read_u32(np, "bus-width", &data);
drivers/mmc/host/dw_mmc.c:/* find out bus-width for a given slot */
drivers/mmc/host/dw_mmc.c:	if (of_property_read_u32(np, "bus-width", &bus_wd))
drivers/mmc/host/dw_mmc.c:		dev_err(dev, "bus-width property not found, assuming width"
drivers/mmc/host/mmci.c:	of_property_read_u32(np, "bus-width", &bus_width);
drivers/mmc/host/mmci.c:		/* No bus-width supplied. */
drivers/mmc/host/mxs-mmc.c:	of_property_read_u32(np, "bus-width", &bus_width);
drivers/mmc/host/omap_hsmmc.c:	of_property_read_u32(np, "bus-width", &bus_width);
drivers/mmc/host/sdhci-esdhc-imx.c:	of_property_read_u32(np, "bus-width", &boarddata->max_bus_width);
drivers/mmc/host/sdhci-pltfm.c:		    (of_property_read_u32(np, "bus-width", &bus_width) == 0 &&
drivers/mmc/host/sdhci-pxav2.c:	of_property_read_u32(np, "bus-width", &bus_width);
drivers/mmc/host/sdhci-s3c.c:	/* if the bus-width property is not specified, assume width as 1 */
drivers/mmc/host/sdhci-s3c.c:	if (of_property_read_u32(node, "bus-width", &max_width))
drivers/mtd/chips/cfi_cmdset_0001.c:	/* If it's not bus-aligned, do the first byte write */
drivers/mtd/chips/cfi_cmdset_0002.c:	/* If it's not bus-aligned, do the first byte write */
drivers/mtd/chips/cfi_cmdset_0002.c:	/* If it's not bus-aligned, do the first word write */
drivers/mtd/nand/bcm47xxnflash/main.c:	if (b47n->cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
drivers/mtd/nand/gpio.c: * Needed on PXA due to bus-reordering within the SoC itself (see section on
drivers/mtd/nand/nand_base.c:	 * Try again to make sure, as some systems the bus-hold or other
drivers/mtd/nand/omap2.c:		pr_err("nand device scan failed, may be bus-width mismatch\n");
drivers/mtd/nand/pasemi_nand.c:		.compatible   = "pasemi,localbus-nand",
drivers/net/can/at91_can.c:		netdev_dbg(dev, "bus-off\n");
drivers/net/can/bfin_can.c:		netdev_dbg(dev, "bus-off mode interrupt\n");
drivers/net/can/c_can/c_can.c:		/* silent mode : bus-monitoring mode */
drivers/net/can/c_can/c_can.c:		/* bus-off state */
drivers/net/can/c_can/c_can.c:		 * disable all interrupts in bus-off mode to ensure that
drivers/net/can/cc770/cc770.c:	/* Enable configuration and puts chip in bus-off, disable interrupts */
drivers/net/can/cc770/cc770.c:	 * Clear bus-off, interrupts only for errors,
drivers/net/can/cc770/cc770.c:	/* Enable configuration and put chip in bus-off, disable interrupts */
drivers/net/can/cc770/cc770.c:	/* Enable configuration, put chip in bus-off, disable ints */
drivers/net/can/cc770/cc770.c:			/* Exit in case of bus-off */
drivers/net/can/dev.c: * CAN device restart for bus-off recovery
drivers/net/can/dev.c:	 * No synchronization needed because the device is bus-off and
drivers/net/can/dev.c:	 * disabled and the device is in the bus-off state
drivers/net/can/dev.c: * CAN bus-off
drivers/net/can/dev.c: * This functions should be called when the device goes bus-off to
drivers/net/can/dev.c: * If enabled, a timer is started to trigger bus-off recovery.
drivers/net/can/dev.c:	netdev_dbg(dev, "bus-off\n");
drivers/net/can/dev.c:	/* Switch carrier on if device was stopped while in bus-off state */
drivers/net/can/grcan.c:				netdev_dbg(dev, "bus-off\n");
drivers/net/can/janz-ican3.c:		 * The controller automatically disables bus-error interrupts
drivers/net/can/janz-ican3.c:			dev_err(mod->dev, "unable to re-enable bus-error\n");
drivers/net/can/janz-ican3.c:		dev_err(mod->dev, "unable to set bus-error\n");
drivers/net/can/janz-ican3.c:		dev_err(mod->dev, "unable to set bus-on\n");
drivers/net/can/janz-ican3.c:		dev_err(mod->dev, "unable to set bus-off\n");
drivers/net/can/janz-ican3.c:		dev_err(mod->dev, "unable to set bus-on\n");
drivers/net/can/mscan/mscan.c:		/* Clear pending bus-off condition */
drivers/net/can/mscan/mscan.c:		     "bus-off state expected\n");
drivers/net/can/mscan/mscan.c:			 * The MSCAN on the MPC5200 does recover from bus-off
drivers/net/can/mscan/mscan.c:		ctl1 |= MSCAN_BORM; /* bus-off recovery upon request */
drivers/net/can/sja1000/Kconfig:	   - Marathon CAN-bus-PCI card (http://www.marathon.ru/)
drivers/net/can/sja1000/plx_pci.c:			"Marathon CAN-bus-PCI, "
drivers/net/can/sja1000/plx_pci.c:	"Marathon CAN-bus-PCI", 2,
drivers/net/can/sja1000/plx_pci.c:		/* Marathon CAN-bus-PCI card */
drivers/net/can/ti_hecc.c:	 * INFO: CAN net stack handles bus off and hence disabling auto-bus-on
drivers/net/can/ti_hecc.c:		/* Disable all interrupts in bus-off to avoid int hog */
drivers/net/can/usb/kvaser_usb.c:	/* Sometimes the state change doesn't come after a bus-off event */
drivers/net/ethernet/3com/3c515.c:   programmed-I/O for Vortex cards.  Full-bus-master transfers are always
drivers/net/ethernet/3com/3c515.c:The card is capable of full-bus-master transfers with separate
drivers/net/ethernet/3com/3c515.c:		full_duplex:1, autoselect:1, bus_master:1,	/* Vortex can only do a fragment bus-m. */
drivers/net/ethernet/3com/3c515.c:	pr_debug("  Flags; bus-master %d, full %d; dirty %d current %d.\n",
drivers/net/ethernet/3com/3c515.c:	if (vp->full_bus_master_tx) {	/* BOOMERANG bus-master */
drivers/net/ethernet/3com/3c515.c:		/* Set the bus-master controller to transfer the packet. */
drivers/net/ethernet/3com/3c574_cs.c:The 3c574 uses a Boomerang-style interface, without the bus-master capability.
drivers/net/ethernet/3com/3c59x.c:/* ARM systems perform better by disregarding the bus-master
drivers/net/ethernet/3com/3c59x.c:alternate single-contiguous-region bus-master transfer (see next).
drivers/net/ethernet/3com/3c59x.c:The 3c900 "Boomerang" series uses a full-bus-master interface with separate
drivers/net/ethernet/3com/3c59x.c:The Boomerang chip's full-bus-master interface is useful, and has the
drivers/net/ethernet/3com/3c59x.c:With full-bus-master support, this driver uses a "RX_COPYBREAK" scheme.
drivers/net/ethernet/3com/3c59x.c:		bus_master:1,					/* Vortex can only do a fragment bus-m. */
drivers/net/ethernet/3com/3c59x.c:		/* enable bus-mastering if necessary */
drivers/net/ethernet/3com/3c59x.c:			pr_info("  Enabling bus-master transmits and %s receives.\n",
drivers/net/ethernet/3com/3c59x.c:		/* Set the bus-master controller to transfer the packet. */
drivers/net/ethernet/3com/3c59x.c:			pr_err("  Flags; bus-master %d, dirty %d(%d) current %d(%d)\n",
drivers/net/ethernet/8390/ax88796.c:	ax->mii_bus->name = "ax88796_mii_bus";
drivers/net/ethernet/8390/ax88796.c:	ax->mii_bus->parent = dev->dev.parent;
drivers/net/ethernet/8390/ax88796.c:	snprintf(ax->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/8390/ax88796.c:	ax->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/8390/ax88796.c:	if (!ax->mii_bus->irq) {
drivers/net/ethernet/8390/ax88796.c:		ax->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/8390/ax88796.c:	kfree(ax->mii_bus->irq);
drivers/net/ethernet/8390/mac8390.c:/* mac8390.c: New driver for 8390-based Nubus (or Nubus-alike)
drivers/net/ethernet/adi/bfin_mac.c:		struct phy_device *const tmp_phydev = lp->mii_bus->phy_map[i];
drivers/net/ethernet/adi/bfin_mac.c:		if (lp->mii_bus->irq[i] != PHY_POLL)
drivers/net/ethernet/adi/bfin_mac.c:	lp->mii_bus->priv = ndev;
drivers/net/ethernet/adi/bfin_mac.c:	lp->mii_bus->priv = NULL;
drivers/net/ethernet/adi/bfin_mac.c:	miibus->read = bfin_mdiobus_read;
drivers/net/ethernet/adi/bfin_mac.c:	miibus->write = bfin_mdiobus_write;
drivers/net/ethernet/adi/bfin_mac.c:	miibus->reset = bfin_mdiobus_reset;
drivers/net/ethernet/adi/bfin_mac.c:	miibus->parent = &pdev->dev;
drivers/net/ethernet/adi/bfin_mac.c:	miibus->name = "bfin_mii_bus";
drivers/net/ethernet/adi/bfin_mac.c:	miibus->phy_mask = mii_bus_pd->phy_mask;
drivers/net/ethernet/adi/bfin_mac.c:	snprintf(miibus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/adi/bfin_mac.c:	miibus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/adi/bfin_mac.c:	if (!miibus->irq)
drivers/net/ethernet/adi/bfin_mac.c:		miibus->irq[i] = PHY_POLL;
drivers/net/ethernet/adi/bfin_mac.c:			miibus->irq[phyaddr] = mii_bus_pd->phydev_data[i].irq;
drivers/net/ethernet/adi/bfin_mac.c:	kfree(miibus->irq);
drivers/net/ethernet/adi/bfin_mac.c:	kfree(miibus->irq);
drivers/net/ethernet/aeroflex/greth.c:	strlcpy(info->bus_info, greth->dev->bus->name, sizeof(info->bus_info));
drivers/net/ethernet/aeroflex/greth.c:	struct greth_private *greth = bus->priv;
drivers/net/ethernet/aeroflex/greth.c:	struct greth_private *greth = bus->priv;
drivers/net/ethernet/amd/au1000_eth.c:	/* WARNING: bus->phy_map[phy_addr].attached_dev == dev does
drivers/net/ethernet/amd/au1000_eth.c:	struct net_device *const dev = bus->priv;
drivers/net/ethernet/amd/au1000_eth.c:	struct net_device *const dev = bus->priv;
drivers/net/ethernet/amd/au1000_eth.c:	struct net_device *const dev = bus->priv;
drivers/net/ethernet/amd/au1000_eth.c:			phydev = aup->mii_bus->phy_map[aup->phy_addr];
drivers/net/ethernet/amd/au1000_eth.c:		if (aup->mii_bus->phy_map[phy_addr]) {
drivers/net/ethernet/amd/au1000_eth.c:			phydev = aup->mii_bus->phy_map[phy_addr];
drivers/net/ethernet/amd/au1000_eth.c:					aup->mii_bus->phy_map[phy_addr];
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->priv = dev;
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->read = au1000_mdiobus_read;
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->write = au1000_mdiobus_write;
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->reset = au1000_mdiobus_reset;
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->name = "au1000_eth_mii";
drivers/net/ethernet/amd/au1000_eth.c:	snprintf(aup->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/amd/au1000_eth.c:	aup->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/amd/au1000_eth.c:	if (aup->mii_bus->irq == NULL) {
drivers/net/ethernet/amd/au1000_eth.c:		aup->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/amd/au1000_eth.c:			aup->mii_bus->irq[aup->phy_addr] = aup->phy_irq;
drivers/net/ethernet/amd/lance.c:	with most other LANCE-based bus-master (NE2100/NE2500) ethercards.
drivers/net/ethernet/amd/lance.c:bus-master mode, rather than in shared memory mode.	 (Only older designs
drivers/net/ethernet/amd/lance.c:		dev->dma = 4;			/* Native bus-master, no DMA channel needed. */
drivers/net/ethernet/arc/emac_mdio.c:	struct arc_emac_priv *priv = bus->priv;
drivers/net/ethernet/arc/emac_mdio.c:	struct arc_emac_priv *priv = bus->priv;
drivers/net/ethernet/arc/emac_mdio.c:	bus->priv = priv;
drivers/net/ethernet/arc/emac_mdio.c:	bus->parent = priv->dev;
drivers/net/ethernet/arc/emac_mdio.c:	bus->name = "Synopsys MII Bus",
drivers/net/ethernet/arc/emac_mdio.c:	bus->read = &arc_mdio_read;
drivers/net/ethernet/arc/emac_mdio.c:	bus->write = &arc_mdio_write;
drivers/net/ethernet/arc/emac_mdio.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
drivers/net/ethernet/arc/emac_mdio.c:		dev_err(priv->dev, "cannot register MDIO bus %s\n", bus->name);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	 * Enables bus-mastering on the device and calls
drivers/net/ethernet/atheros/atlx/atl1.c:	 * Enables bus-mastering on the device and calls
drivers/net/ethernet/atheros/atlx/atl2.c:	/* Enables bus-mastering on the device and calls
drivers/net/ethernet/broadcom/b44.c:	ssb_pcicore_dev_irqvecs_enable(&sdev->bus->pcicore, sdev);
drivers/net/ethernet/broadcom/b44.c:	switch (sdev->bus->bustype) {
drivers/net/ethernet/broadcom/b44.c:	if (bp->sdev->bus->bustype != SSB_BUSTYPE_SSB) {
drivers/net/ethernet/broadcom/b44.c:		pci_read_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, &val);
drivers/net/ethernet/broadcom/b44.c:		pci_write_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, val | SSB_PE);
drivers/net/ethernet/broadcom/b44.c:	switch (bus->bustype) {
drivers/net/ethernet/broadcom/b44.c:		strlcpy(info->bus_info, pci_name(bus->host_pci), sizeof(info->bus_info));
drivers/net/ethernet/broadcom/b44.c:	if (sdev->bus->bustype == SSB_BUSTYPE_SSB &&
drivers/net/ethernet/broadcom/b44.c:		addr = sdev->bus->sprom.et1mac;
drivers/net/ethernet/broadcom/b44.c:		bp->phy_addr = sdev->bus->sprom.et1phyaddr;
drivers/net/ethernet/broadcom/b44.c:		addr = sdev->bus->sprom.et0mac;
drivers/net/ethernet/broadcom/b44.c:		bp->phy_addr = sdev->bus->sprom.et0phyaddr;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	return bcm_enet_mdio_read(bus->priv, mii_id, regnum);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	return bcm_enet_mdio_write(bus->priv, mii_id, regnum, value);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			 priv->mii_bus->id, priv->phy_id);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->name = "bcm63xx_enet MII bus";
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->parent = &pdev->dev;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->priv = priv;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->read = bcm_enet_mdio_read_phylib;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->write = bcm_enet_mdio_write_phylib;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		sprintf(bus->id, "%s-%d", pdev->name, priv->mac_id);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->phy_mask = ~(1 << priv->phy_id);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->irq = devm_kzalloc(&pdev->dev, sizeof(int) * PHY_MAX_ADDR,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		if (!bus->irq) {
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			bus->irq[priv->phy_id] = priv->phy_interrupt;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			bus->irq[priv->phy_id] = PHY_POLL;
drivers/net/ethernet/broadcom/bgmac.c:		core = bgmac->core->bus->drv_gmac_cmn.core;
drivers/net/ethernet/broadcom/bgmac.c:		core = bgmac->core->bus->drv_gmac_cmn.core;
drivers/net/ethernet/broadcom/bgmac.c:	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
drivers/net/ethernet/broadcom/bgmac.c:	struct bcma_drv_cc *cc = &bgmac->core->bus->drv_cc;
drivers/net/ethernet/broadcom/bgmac.c:	struct bcma_chipinfo *ci = &bus->chipinfo;
drivers/net/ethernet/broadcom/bgmac.c:		struct bcma_drv_cc *cc = &bgmac->core->bus->drv_cc;
drivers/net/ethernet/broadcom/bgmac.c:	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
drivers/net/ethernet/broadcom/bgmac.c:		bcma_chipco_chipctl_maskset(&bgmac->core->bus->drv_cc, 1, ~0,
drivers/net/ethernet/broadcom/bgmac.c:	bp_clk = bcma_pmu_get_bus_clock(&bgmac->core->bus->drv_cc) / 1000000;
drivers/net/ethernet/broadcom/bgmac.c:	return bgmac_phy_read(bus->priv, mii_id, regnum);
drivers/net/ethernet/broadcom/bgmac.c:	return bgmac_phy_write(bus->priv, mii_id, regnum, value);
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->name = "bgmac mii bus";
drivers/net/ethernet/broadcom/bgmac.c:	sprintf(mii_bus->id, "%s-%d-%d", "bgmac", bgmac->core->bus->num,
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->priv = bgmac;
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->read = bgmac_mii_read;
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->write = bgmac_mii_write;
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->parent = &bgmac->core->dev;
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->phy_mask = ~(1 << bgmac->phyaddr);
drivers/net/ethernet/broadcom/bgmac.c:	mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
drivers/net/ethernet/broadcom/bgmac.c:	if (!mii_bus->irq) {
drivers/net/ethernet/broadcom/bgmac.c:		mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/broadcom/bgmac.c:	kfree(mii_bus->irq);
drivers/net/ethernet/broadcom/bgmac.c:	kfree(mii_bus->irq);
drivers/net/ethernet/broadcom/bgmac.c:	struct ssb_sprom *sprom = &core->bus->sprom;
drivers/net/ethernet/broadcom/bgmac.c:	    !core->bus->drv_gmac_cmn.core) {
drivers/net/ethernet/broadcom/bgmac.c:	bgmac->cmn = core->bus->drv_gmac_cmn.core;
drivers/net/ethernet/broadcom/bgmac.c:	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
drivers/net/ethernet/broadcom/bgmac.c:	bgmac->has_robosw = !!(core->bus->sprom.boardflags_lo &
drivers/net/ethernet/broadcom/bgmac.c:	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
drivers/net/ethernet/broadcom/bnx2.c:	/* enable device (incl. PCI PM wakeup), and bus-mastering */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		    bp->pdev->bus->number == tmp_list->bus &&
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	tmp_list->bus = bp->pdev->bus->number;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c:	return dev->bus->number + ((dev->devfn + iov->offset +
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c:	return dev->bus->self && dev->bus->self->ari_enabled;
drivers/net/ethernet/broadcom/sb1250-mac.c:	struct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;
drivers/net/ethernet/broadcom/sb1250-mac.c:	struct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->name = sbmac_mdio_string;
drivers/net/ethernet/broadcom/sb1250-mac.c:	snprintf(sc->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->priv = sc;
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->read = sbmac_mii_read;
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->write = sbmac_mii_write;
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->irq = sc->phy_irq;
drivers/net/ethernet/broadcom/sb1250-mac.c:		sc->mii_bus->irq[i] = SBMAC_PHY_INT;
drivers/net/ethernet/broadcom/sb1250-mac.c:	sc->mii_bus->parent = &pldev->dev;
drivers/net/ethernet/broadcom/sb1250-mac.c:		phy_dev = sc->mii_bus->phy_map[i];
drivers/net/ethernet/broadcom/tg3.c:	phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->name     = "tg3 mdio bus";
drivers/net/ethernet/broadcom/tg3.c:	snprintf(tp->mdio_bus->id, MII_BUS_ID_SIZE, "%x",
drivers/net/ethernet/broadcom/tg3.c:		 (tp->pdev->bus->number << 8) | tp->pdev->devfn);
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->priv     = tp;
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->parent   = &tp->pdev->dev;
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->read     = &tg3_mdio_read;
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->write    = &tg3_mdio_write;
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->reset    = &tg3_mdio_reset;
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->phy_mask = ~(1 << tp->phy_addr);
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->irq      = &tp->mdio_irq[0];
drivers/net/ethernet/broadcom/tg3.c:		tp->mdio_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/broadcom/tg3.c:	phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		autoneg = tp->mdio_bus->phy_map[tp->phy_addr]->autoneg;
drivers/net/ethernet/broadcom/tg3.c:	struct phy_device *phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:	phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		phy_disconnect(tp->mdio_bus->phy_map[tp->phy_addr]);
drivers/net/ethernet/broadcom/tg3.c:	phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:	phy_stop(tp->mdio_bus->phy_map[tp->phy_addr]);
drivers/net/ethernet/broadcom/tg3.c:		phy_disconnect(tp->mdio_bus->phy_map[tp->phy_addr]);
drivers/net/ethernet/broadcom/tg3.c:			phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		r = phy_start_aneg(tp->mdio_bus->phy_map[tp->phy_addr]);
drivers/net/ethernet/broadcom/tg3.c:		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number) &&
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number) &&
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
drivers/net/ethernet/cadence/at91_ether.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/cadence/macb.c:	struct macb *bp = bus->priv;
drivers/net/ethernet/cadence/macb.c:	struct macb *bp = bus->priv;
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->name = "MACB_mii_bus";
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->read = &macb_mdio_read;
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->write = &macb_mdio_write;
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->reset = &macb_mdio_reset;
drivers/net/ethernet/cadence/macb.c:	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->priv = bp;
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->parent = &bp->dev->dev;
drivers/net/ethernet/cadence/macb.c:	bp->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/cadence/macb.c:	if (!bp->mii_bus->irq) {
drivers/net/ethernet/cadence/macb.c:			bp->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/cadence/macb.c:			bp->mii_bus->phy_mask = pdata->phy_mask;
drivers/net/ethernet/cadence/macb.c:	kfree(bp->mii_bus->irq);
drivers/net/ethernet/cadence/macb.c:		kfree(bp->mii_bus->irq);
drivers/net/ethernet/dec/tulip/de4x5.c:    list_for_each_entry(this_dev, &pdev->bus->devices, bus_list) {
drivers/net/ethernet/dec/tulip/de4x5.c:	pb = this_dev->bus->number;
drivers/net/ethernet/dec/tulip/de4x5.c:	pb = pdev->bus->number;
drivers/net/ethernet/dec/tulip/tulip_core.c:               if ((pdev->bus->number == 0) &&
drivers/net/ethernet/dnet.c:	struct dnet *bp = bus->priv;
drivers/net/ethernet/dnet.c:	struct dnet *bp = bus->priv;
drivers/net/ethernet/dnet.c:		if (bp->mii_bus->phy_map[phy_addr]) {
drivers/net/ethernet/dnet.c:			phydev = bp->mii_bus->phy_map[phy_addr];
drivers/net/ethernet/dnet.c:	bp->mii_bus->name = "dnet_mii_bus";
drivers/net/ethernet/dnet.c:	bp->mii_bus->read = &dnet_mdio_read;
drivers/net/ethernet/dnet.c:	bp->mii_bus->write = &dnet_mdio_write;
drivers/net/ethernet/dnet.c:	bp->mii_bus->reset = &dnet_mdio_reset;
drivers/net/ethernet/dnet.c:	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/dnet.c:	bp->mii_bus->priv = bp;
drivers/net/ethernet/dnet.c:	bp->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/dnet.c:	if (!bp->mii_bus->irq) {
drivers/net/ethernet/dnet.c:		bp->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/dnet.c:	kfree(bp->mii_bus->irq);
drivers/net/ethernet/dnet.c:		kfree(bp->mii_bus->irq);
drivers/net/ethernet/ethoc.c:	struct ethoc *priv = bus->priv;
drivers/net/ethernet/ethoc.c:	struct ethoc *priv = bus->priv;
drivers/net/ethernet/faraday/ftgmac100.c:		struct phy_device *tmp = priv->mii_bus->phy_map[i];
drivers/net/ethernet/faraday/ftgmac100.c:	struct net_device *netdev = bus->priv;
drivers/net/ethernet/faraday/ftgmac100.c:	struct net_device *netdev = bus->priv;
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->name = "ftgmac100_mdio";
drivers/net/ethernet/faraday/ftgmac100.c:	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "ftgmac100_mii");
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->priv = netdev;
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->read = ftgmac100_mdiobus_read;
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->write = ftgmac100_mdiobus_write;
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->reset = ftgmac100_mdiobus_reset;
drivers/net/ethernet/faraday/ftgmac100.c:	priv->mii_bus->irq = priv->phy_irq;
drivers/net/ethernet/faraday/ftgmac100.c:		priv->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/freescale/fec_main.c:	struct fec_enet_private *fep = bus->priv;
drivers/net/ethernet/freescale/fec_main.c:	struct fec_enet_private *fep = bus->priv;
drivers/net/ethernet/freescale/fec_main.c:		if ((fep->mii_bus->phy_mask & (1 << phy_id)))
drivers/net/ethernet/freescale/fec_main.c:		if (fep->mii_bus->phy_map[phy_id] == NULL)
drivers/net/ethernet/freescale/fec_main.c:		if (fep->mii_bus->phy_map[phy_id]->phy_id == 0)
drivers/net/ethernet/freescale/fec_main.c:		strncpy(mdio_bus_id, fep->mii_bus->id, MII_BUS_ID_SIZE);
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->name = "fec_enet_mii_bus";
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->read = fec_enet_mdio_read;
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->write = fec_enet_mdio_write;
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->reset = fec_enet_mdio_reset;
drivers/net/ethernet/freescale/fec_main.c:	snprintf(fep->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->priv = fep;
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/freescale/fec_main.c:	if (!fep->mii_bus->irq) {
drivers/net/ethernet/freescale/fec_main.c:		fep->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/freescale/fec_main.c:	kfree(fep->mii_bus->irq);
drivers/net/ethernet/freescale/fec_main.c:		kfree(fep->mii_bus->irq);
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	struct mpc52xx_fec_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->name = "mpc52xx MII bus";
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->read = mpc52xx_fec_mdio_read;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->write = mpc52xx_fec_mdio_write;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->irq = priv->mdio_irqs;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%x", res.start);
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->priv = priv;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	bus->parent = dev;
drivers/net/ethernet/freescale/fec_mpc52xx_phy.c:	struct mpc52xx_fec_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mac-fec.c:	struct fec_info* feci= fep->phydev->bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	struct bb_info *bitbang = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%x", res.start);
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	new_bus->name = "CPM2 Bitbanged MII",
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	new_bus->phy_mask = ~0;
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	new_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	if (!new_bus->irq) {
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	new_bus->parent = &ofdev->dev;
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	kfree(new_bus->irq);
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	struct bb_info *bitbang = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-bitbang.c:	kfree(bus->irq);
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	struct fec_info* fec = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	struct fec_info* fec = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->priv = fec;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->name = "FEC MII Bus";
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->read = &fs_enet_fec_mii_read;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->write = &fs_enet_fec_mii_write;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->reset = &fs_enet_fec_mii_reset;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%x", res.start);
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->phy_mask = ~0;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	if (!new_bus->irq) {
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	new_bus->parent = &ofdev->dev;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	kfree(new_bus->irq);
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	struct fec_info *fec = bus->priv;
drivers/net/ethernet/freescale/fs_enet/mii-fec.c:	kfree(bus->irq);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct fsl_pq_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct fsl_pq_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	dev_dbg(&bus->dev, "read %04x from address %x/%x\n", value, mii_id, regnum);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct fsl_pq_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	mutex_lock(&bus->mdio_lock);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	mutex_unlock(&bus->mdio_lock);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:		dev_err(&bus->dev, "timeout waiting for MII bus\n");
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	priv = new_bus->priv;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->name = "Freescale PowerQUICC MII Bus",
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->read = &fsl_pq_mdio_read;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->write = &fsl_pq_mdio_write;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->reset = &fsl_pq_mdio_reset;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->irq = priv->irqs;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s@%llx", np->name,
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:			new_bus->name);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct fsl_pq_mdio_priv *priv = bus->priv;
drivers/net/ethernet/freescale/gianfar_ethtool.c:	"ethernet-bus-error",
drivers/net/ethernet/freescale/xgmac_mdio.c:	struct tgec_mdio_controller __iomem *regs = bus->priv;
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_free(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_free(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_done(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	struct tgec_mdio_controller __iomem *regs = bus->priv;
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_free(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_free(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_done(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:		dev_err(&bus->dev, "MDIO read error\n");
drivers/net/ethernet/freescale/xgmac_mdio.c:	dev_dbg(&bus->dev, "read %04x\n", value);
drivers/net/ethernet/freescale/xgmac_mdio.c:	struct tgec_mdio_controller __iomem *regs = bus->priv;
drivers/net/ethernet/freescale/xgmac_mdio.c:	mutex_lock(&bus->mdio_lock);
drivers/net/ethernet/freescale/xgmac_mdio.c:	ret = xgmac_wait_until_free(&bus->dev, regs);
drivers/net/ethernet/freescale/xgmac_mdio.c:	mutex_unlock(&bus->mdio_lock);
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->name = "Freescale XGMAC MDIO Bus";
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->read = xgmac_mdio_read;
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->write = xgmac_mdio_write;
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->reset = xgmac_mdio_reset;
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->irq = bus->priv;
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/xgmac_mdio.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->priv = of_iomap(np, 0);
drivers/net/ethernet/freescale/xgmac_mdio.c:	if (!bus->priv) {
drivers/net/ethernet/freescale/xgmac_mdio.c:	iounmap(bus->priv);
drivers/net/ethernet/freescale/xgmac_mdio.c:	iounmap(bus->priv);
drivers/net/ethernet/hp/hp100.h:#define HP100_EN_BUS_FAIL       0x80	/* Enables bus-fail portion of misc */
drivers/net/ethernet/i825xx/82596.c:   This driver is for the Apricot 82596 bus-master interface
drivers/net/ethernet/i825xx/lasi_82596.c:   This driver is for the Apricot 82596 bus-master interface
drivers/net/ethernet/i825xx/lib82596.c:   This driver is for the Apricot 82596 bus-master interface
drivers/net/ethernet/intel/e1000e/ich8lan.c:	if (bus->width == e1000_bus_width_unknown)
drivers/net/ethernet/intel/e1000e/ich8lan.c:		bus->width = e1000_bus_width_pcie_x1;
drivers/net/ethernet/intel/e1000e/mac.c:		bus->width = e1000_bus_width_unknown;
drivers/net/ethernet/intel/e1000e/mac.c:		bus->width = (enum e1000_bus_width)((pcie_link_status &
drivers/net/ethernet/intel/e1000e/mac.c:	bus->func = (reg & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;
drivers/net/ethernet/intel/e1000e/mac.c:	bus->func = 0;
drivers/net/ethernet/intel/e1000e/netdev.c:		struct pci_dev *us_dev = pdev->bus->self;
drivers/net/ethernet/intel/e1000e/netdev.c:	struct pci_dev *parent = pdev->bus->self;
drivers/net/ethernet/intel/igb/e1000_mac.c:	bus->type = e1000_bus_type_pci_express;
drivers/net/ethernet/intel/igb/e1000_mac.c:		bus->width = e1000_bus_width_unknown;
drivers/net/ethernet/intel/igb/e1000_mac.c:		bus->speed = e1000_bus_speed_unknown;
drivers/net/ethernet/intel/igb/e1000_mac.c:			bus->speed = e1000_bus_speed_2500;
drivers/net/ethernet/intel/igb/e1000_mac.c:			bus->speed = e1000_bus_speed_5000;
drivers/net/ethernet/intel/igb/e1000_mac.c:			bus->speed = e1000_bus_speed_unknown;
drivers/net/ethernet/intel/igb/e1000_mac.c:		bus->width = (enum e1000_bus_width)((pcie_link_status &
drivers/net/ethernet/intel/igb/e1000_mac.c:	bus->func = (reg & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:			bus->func = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	bus->func = (reg & IXGBE_STATUS_LAN_ID) >> IXGBE_STATUS_LAN_ID_SHIFT;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	bus->lan_id = bus->func;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		bus->func ^= 0x1;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	parent_bus = adapter->pdev->bus->parent;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	parent_dev = parent_bus->self;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		pdev = adapter->pdev->bus->parent->self;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	bdev = pdev->bus->self;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		bdev = bdev->bus->self;
drivers/net/ethernet/lantiq_etop.c:		if (priv->mii_bus->phy_map[phy_addr]) {
drivers/net/ethernet/lantiq_etop.c:			phydev = priv->mii_bus->phy_map[phy_addr];
drivers/net/ethernet/lantiq_etop.c:	priv->mii_bus->priv = dev;
drivers/net/ethernet/lantiq_etop.c:	priv->mii_bus->read = ltq_etop_mdio_rd;
drivers/net/ethernet/lantiq_etop.c:	priv->mii_bus->write = ltq_etop_mdio_wr;
drivers/net/ethernet/lantiq_etop.c:	priv->mii_bus->name = "ltq_mii";
drivers/net/ethernet/lantiq_etop.c:	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/lantiq_etop.c:	priv->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/lantiq_etop.c:	if (!priv->mii_bus->irq) {
drivers/net/ethernet/lantiq_etop.c:		priv->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/lantiq_etop.c:	kfree(priv->mii_bus->irq);
drivers/net/ethernet/lantiq_etop.c:	kfree(priv->mii_bus->irq);
drivers/net/ethernet/marvell/mvmdio.c:	struct orion_mdio_dev *dev = bus->priv;
drivers/net/ethernet/marvell/mvmdio.c:	dev_err(bus->parent, "Timeout: SMI busy for too long\n");
drivers/net/ethernet/marvell/mvmdio.c:	struct orion_mdio_dev *dev = bus->priv;
drivers/net/ethernet/marvell/mvmdio.c:		dev_err(bus->parent, "SMI bus read not valid\n");
drivers/net/ethernet/marvell/mvmdio.c:	struct orion_mdio_dev *dev = bus->priv;
drivers/net/ethernet/marvell/mvmdio.c:	bus->name = "orion_mdio_bus";
drivers/net/ethernet/marvell/mvmdio.c:	bus->read = orion_mdio_read;
drivers/net/ethernet/marvell/mvmdio.c:	bus->write = orion_mdio_write;
drivers/net/ethernet/marvell/mvmdio.c:	bus->reset = orion_mdio_reset;
drivers/net/ethernet/marvell/mvmdio.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
drivers/net/ethernet/marvell/mvmdio.c:	bus->parent = &pdev->dev;
drivers/net/ethernet/marvell/mvmdio.c:	bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/marvell/mvmdio.c:	if (!bus->irq) {
drivers/net/ethernet/marvell/mvmdio.c:		bus->irq[i] = PHY_POLL;
drivers/net/ethernet/marvell/mvmdio.c:	dev = bus->priv;
drivers/net/ethernet/marvell/mvmdio.c:	kfree(bus->irq);
drivers/net/ethernet/marvell/mvmdio.c:	struct orion_mdio_dev *dev = bus->priv;
drivers/net/ethernet/marvell/mvmdio.c:	kfree(bus->irq);
drivers/net/ethernet/marvell/pxa168_eth.c:	struct pxa168_eth_private *pep = bus->priv;
drivers/net/ethernet/marvell/pxa168_eth.c:	struct pxa168_eth_private *pep = bus->priv;
drivers/net/ethernet/marvell/pxa168_eth.c:		if (bus->phy_map[addr] == NULL)
drivers/net/ethernet/marvell/pxa168_eth.c:			phydev = bus->phy_map[addr];
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->priv = pep;
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->name = "pxa168_eth smi";
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->read = pxa168_smi_read;
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->write = pxa168_smi_write;
drivers/net/ethernet/marvell/pxa168_eth.c:	snprintf(pep->smi_bus->id, MII_BUS_ID_SIZE, "%s-%d",
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->parent = &pdev->dev;
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->phy_mask = 0xffffffff;
drivers/net/ethernet/micrel/ks8851_mll.c:	depending on bus-width.
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct pci_dev *bridge = mgp->pdev->bus->self;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				bridge = bridge->bus->self;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct pci_dev *bridge = pdev->bus->self;
drivers/net/ethernet/natsemi/macsonic.c:/* These should basically be bus-size and endian independent (since
drivers/net/ethernet/natsemi/sonic.h:/* Note!  These are all measured in bus-size units, so use SONIC_BUS_SCALE */
drivers/net/ethernet/neterion/s2io.c:			if (tdev->bus == s2io_pdev->bus->parent) {
drivers/net/ethernet/neterion/vxge/vxge-main.c:	if (((bus != pdev->bus->number) || (device != PCI_SLOT(pdev->devfn))) &&
drivers/net/ethernet/neterion/vxge/vxge-main.c:	bus = pdev->bus->number;
drivers/net/ethernet/nxp/lpc_eth.c:	struct netdata_local *pldat = bus->priv;
drivers/net/ethernet/nxp/lpc_eth.c:	struct netdata_local *pldat = bus->priv;
drivers/net/ethernet/nxp/lpc_eth.c:	return __lpc_mii_mngt_reset((struct netdata_local *)bus->priv);
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->name = "lpc_mii_bus";
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->read = &lpc_mdio_read;
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->write = &lpc_mdio_write;
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->reset = &lpc_mdio_reset;
drivers/net/ethernet/nxp/lpc_eth.c:	snprintf(pldat->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->priv = pldat;
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->parent = &pldat->pdev->dev;
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/nxp/lpc_eth.c:	if (!pldat->mii_bus->irq) {
drivers/net/ethernet/nxp/lpc_eth.c:		pldat->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/nxp/lpc_eth.c:	kfree(pldat->mii_bus->irq);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	adapter->ptp_pdev = pci_get_bus_and_slot(adapter->pdev->bus->number,
drivers/net/ethernet/packetengines/hamachi.c:The Hamachi uses a typical descriptor based bus-master architecture.
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	struct pci_dev *root = pdev->bus->self;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			(pdev->bus), pdev->bus->number,
drivers/net/ethernet/rdc/r6040.c:	struct net_device *dev = bus->priv;
drivers/net/ethernet/rdc/r6040.c:	struct net_device *dev = bus->priv;
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->priv = dev;
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->read = r6040_mdiobus_read;
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->write = r6040_mdiobus_write;
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->reset = r6040_mdiobus_reset;
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->name = "r6040_eth_mii";
drivers/net/ethernet/rdc/r6040.c:	snprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/rdc/r6040.c:	lp->mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
drivers/net/ethernet/rdc/r6040.c:	if (!lp->mii_bus->irq) {
drivers/net/ethernet/rdc/r6040.c:		lp->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/rdc/r6040.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/rdc/r6040.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/renesas/sh_eth.c:		mdp->mii_bus->id , mdp->phy_id);
drivers/net/ethernet/renesas/sh_eth.c:	mdp->mii_bus->name = "sh_mii";
drivers/net/ethernet/renesas/sh_eth.c:	mdp->mii_bus->parent = &ndev->dev;
drivers/net/ethernet/renesas/sh_eth.c:	snprintf(mdp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/renesas/sh_eth.c:	mdp->mii_bus->irq = devm_kzalloc(&ndev->dev,
drivers/net/ethernet/renesas/sh_eth.c:	if (!mdp->mii_bus->irq) {
drivers/net/ethernet/renesas/sh_eth.c:		mdp->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/s6gmac.c:	struct s6gmac *pd = bus->priv;
drivers/net/ethernet/s6gmac.c:	struct s6gmac *pd = bus->priv;
drivers/net/ethernet/s6gmac.c:	struct s6gmac *pd = bus->priv;
drivers/net/ethernet/s6gmac.c:	while ((i < PHY_MAX_ADDR) && (!(p = pd->mii.bus->phy_map[i])))
drivers/net/ethernet/sfc/efx.c:	/* Reinitialise bus-mastering, which may have been turned off before
drivers/net/ethernet/sfc/siena_sriov.c:			 pci_domain_nr(pci_dev->bus), pci_dev->bus->number,
drivers/net/ethernet/sgi/ioc3-eth.c:	return pdev->bus->parent == NULL &&
drivers/net/ethernet/smsc/smsc911x.c:	struct smsc911x_data *pdata = (struct smsc911x_data *)bus->priv;
drivers/net/ethernet/smsc/smsc911x.c:	struct smsc911x_data *pdata = (struct smsc911x_data *)bus->priv;
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->name = SMSC_MDIONAME;
drivers/net/ethernet/smsc/smsc911x.c:	snprintf(pdata->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->priv = pdata;
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->read = smsc911x_mii_read;
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->write = smsc911x_mii_write;
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->irq = pdata->phy_irq;
drivers/net/ethernet/smsc/smsc911x.c:		pdata->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->parent = &pdev->dev;
drivers/net/ethernet/smsc/smsc911x.c:		pdata->mii_bus->phy_mask = ~(1 << 1);
drivers/net/ethernet/smsc/smsc9420.c:	struct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;
drivers/net/ethernet/smsc/smsc9420.c:	struct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;
drivers/net/ethernet/smsc/smsc9420.c:	if (!pd->mii_bus->phy_map[1]) {
drivers/net/ethernet/smsc/smsc9420.c:	phydev = pd->mii_bus->phy_map[1];
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->name = DRV_MDIONAME;
drivers/net/ethernet/smsc/smsc9420.c:	snprintf(pd->mii_bus->id, MII_BUS_ID_SIZE, "%x",
drivers/net/ethernet/smsc/smsc9420.c:		(pd->pdev->bus->number << 8) | pd->pdev->devfn);
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->priv = pd;
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->read = smsc9420_mii_read;
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->write = smsc9420_mii_write;
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->irq = pd->phy_irq;
drivers/net/ethernet/smsc/smsc9420.c:		pd->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/smsc/smsc9420.c:	pd->mii_bus->phy_mask = ~(1 << 1);
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	struct net_device *ndev = bus->priv;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	struct net_device *ndev = bus->priv;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	struct net_device *ndev = bus->priv;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->name = "stmmac";
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->read = &stmmac_mdio_read;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->write = &stmmac_mdio_write;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->reset = &stmmac_mdio_reset;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:		 new_bus->name, priv->plat->bus_id);
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->priv = ndev;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->irq = irqlist;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->phy_mask = mdio_bus_data->phy_mask;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:	new_bus->parent = priv->device;
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:		pr_err("%s: Cannot register as MDIO bus\n", new_bus->name);
drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c:		struct phy_device *phydev = new_bus->phy_map[addr];
drivers/net/ethernet/sun/cassini.c:	struct pci_dev *pdev = cas_pdev->bus->self;
drivers/net/ethernet/sun/niu.c:	parent_id.pci.bus = pdev->bus->number;
drivers/net/ethernet/sun/sunhme.c:	struct pci_dev *bdev = pdev->bus->self;
drivers/net/ethernet/sun/sunhme.c:	struct pci_dev *busdev = pdev->bus->self;
drivers/net/ethernet/sun/sunhme.c:	list_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {
drivers/net/ethernet/sun/sunhme.c:	if (!is_qfe && model && !strcmp(model, "SUNW,sbus-qfe"))
drivers/net/ethernet/ti/cpmac.c:	while (cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0)) & MDIO_BUSY)
drivers/net/ethernet/ti/cpmac.c:	cpmac_write(bus->priv, CPMAC_MDIO_ACCESS(0), MDIO_BUSY | MDIO_REG(reg) |
drivers/net/ethernet/ti/cpmac.c:	while ((val = cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0))) & MDIO_BUSY)
drivers/net/ethernet/ti/cpmac.c:	while (cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0)) & MDIO_BUSY)
drivers/net/ethernet/ti/cpmac.c:	cpmac_write(bus->priv, CPMAC_MDIO_ACCESS(0), MDIO_BUSY | MDIO_WRITE |
drivers/net/ethernet/ti/cpmac.c:	cpmac_clk = clk_get(&bus->dev, "cpmac");
drivers/net/ethernet/ti/cpmac.c:	cpmac_write(bus->priv, CPMAC_MDIO_CONTROL, MDIOC_ENABLE |
drivers/net/ethernet/ti/davinci_mdio.c:	struct davinci_mdio_data *data = bus->priv;
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->phy_mask = phy_mask;
drivers/net/ethernet/ti/davinci_mdio.c:	struct davinci_mdio_data *data = bus->priv;
drivers/net/ethernet/ti/davinci_mdio.c:	struct davinci_mdio_data *data = bus->priv;
drivers/net/ethernet/ti/davinci_mdio.c:		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
drivers/net/ethernet/ti/davinci_mdio.c:		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->name		= dev_name(dev);
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->read		= davinci_mdio_read,
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->write	= davinci_mdio_write,
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->reset	= davinci_mdio_reset,
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->parent	= dev;
drivers/net/ethernet/ti/davinci_mdio.c:	data->bus->priv		= data;
drivers/net/ethernet/ti/davinci_mdio.c:		phy = data->bus->phy_map[addr];
drivers/net/ethernet/toshiba/tc35815.c:	struct net_device *dev = bus->priv;
drivers/net/ethernet/toshiba/tc35815.c:	struct net_device *dev = bus->priv;
drivers/net/ethernet/toshiba/tc35815.c:		if (lp->mii_bus->phy_map[phy_addr]) {
drivers/net/ethernet/toshiba/tc35815.c:			phydev = lp->mii_bus->phy_map[phy_addr];
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->name = "tc35815_mii_bus";
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->read = tc_mdio_read;
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->write = tc_mdio_write;
drivers/net/ethernet/toshiba/tc35815.c:	snprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%x",
drivers/net/ethernet/toshiba/tc35815.c:		 (lp->pci_dev->bus->number << 8) | lp->pci_dev->devfn);
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->priv = dev;
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->parent = &lp->pci_dev->dev;
drivers/net/ethernet/toshiba/tc35815.c:	lp->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
drivers/net/ethernet/toshiba/tc35815.c:	if (!lp->mii_bus->irq) {
drivers/net/ethernet/toshiba/tc35815.c:		lp->mii_bus->irq[i] = PHY_POLL;
drivers/net/ethernet/toshiba/tc35815.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/toshiba/tc35815.c:	/* enable device (incl. PCI PM wakeup), and bus-mastering */
drivers/net/ethernet/toshiba/tc35815.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/via/via-rhine.c:Boards with this chip are functional only in a bus-master PCI slot.
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	struct temac_local *lp = bus->priv;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	struct temac_local *lp = bus->priv;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%.8llx",
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->priv = lp;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->name = "Xilinx TEMAC MDIO";
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->read = temac_mdio_read;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->write = temac_mdio_write;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->parent = lp->dev;
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	bus->irq = lp->mdio_irqs; /* preallocated IRQ table */
drivers/net/ethernet/xilinx/ll_temac_mdio.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	struct axienet_local *lp = bus->priv;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	struct axienet_local *lp = bus->priv;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%.8llx",
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->priv = lp;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->name = "Xilinx Axi Ethernet MDIO";
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->read = axienet_mdio_read;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->write = axienet_mdio_write;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->parent = lp->dev;
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	bus->irq = lp->mdio_irqs; /* preallocated IRQ table */
drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c:	kfree(lp->mii_bus->irq);
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	struct net_local *lp = bus->priv;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	struct net_local *lp = bus->priv;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%.8llx",
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->priv = lp;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->name = "Xilinx Emaclite MDIO";
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->read = xemaclite_mdio_read;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->write = xemaclite_mdio_write;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->reset = xemaclite_mdio_reset;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->parent = dev;
drivers/net/ethernet/xilinx/xilinx_emaclite.c:	bus->irq = lp->mdio_irqs; /* preallocated IRQ table */
drivers/net/ethernet/xilinx/xilinx_emaclite.c:		kfree(lp->mii_bus->irq);
drivers/net/ethernet/xscale/ixp4xx_eth.c:		printk(KERN_ERR "%s: MII not ready to transmit\n", bus->name);
drivers/net/ethernet/xscale/ixp4xx_eth.c:		printk(KERN_ERR "%s #%i: MII write failed\n", bus->name,
drivers/net/ethernet/xscale/ixp4xx_eth.c:	printk(KERN_DEBUG "%s #%i: mdio_%s() took %i cycles\n", bus->name,
drivers/net/ethernet/xscale/ixp4xx_eth.c:		printk(KERN_DEBUG "%s #%i: MII read failed\n", bus->name,
drivers/net/ethernet/xscale/ixp4xx_eth.c:	printk(KERN_DEBUG "%s #%i: MII read [%i] -> 0x%X\n", bus->name,
drivers/net/ethernet/xscale/ixp4xx_eth.c:	       bus->name, phy_id, location, val, ret);
drivers/net/ethernet/xscale/ixp4xx_eth.c:	mdio_bus->name = "IXP4xx MII Bus";
drivers/net/ethernet/xscale/ixp4xx_eth.c:	mdio_bus->read = &ixp4xx_mdio_read;
drivers/net/ethernet/xscale/ixp4xx_eth.c:	mdio_bus->write = &ixp4xx_mdio_write;
drivers/net/ethernet/xscale/ixp4xx_eth.c:	snprintf(mdio_bus->id, MII_BUS_ID_SIZE, "ixp4xx-eth-0");
drivers/net/ethernet/xscale/ixp4xx_eth.c:		mdio_bus->id, plat->phy);
drivers/net/fddi/defxx.c: *		initialization, the	only bus-specific differences is in how the
drivers/net/fddi/defxx.c: *		have a bus-logic chip interrupt enable/disable as well as a DMA
drivers/net/fddi/defxx.c: *		bus-logic chip and assumes that Linux will take care of clearing or
drivers/net/fddi/defxx.c: *   Initializes the bus-specific controller logic.
drivers/net/fddi/defxx.c: *   then perform bus-specific logic initialization.
drivers/net/fddi/defxx.c: *   Interrupts are enabled at the adapter bus-specific logic.
drivers/net/fddi/defxx.c: *   Uninitializes the bus-specific controller logic.
drivers/net/fddi/defxx.c: *   Perform bus-specific logic uninitialization.
drivers/net/fddi/defxx.c: *   Interrupts are disabled at the adapter bus-specific logic.
drivers/net/fddi/defxx.c:	/* Initialize bus-specific hardware registers */
drivers/net/fddi/defxx.h:	/* Store device, bus-specific, and parameter information for this adapter */
drivers/net/fddi/skfp/skfddi.c:	/* Initialize board structure with bus-specific info */
drivers/net/irda/vlsi_ir.h:	 * are indeed bus-mappable to the same 16MB range (for x86 this
drivers/net/irda/vlsi_ir.h:/* Contains [23:10] part of the ring base (bus-) address
drivers/net/irda/vlsi_ir.h:/* sw-ring descriptors consists of a bus-mapped transfer buffer with
drivers/net/phy/dp83640.c:		put_device(&clock->bus->dev);
drivers/net/phy/dp83640.c:	get_device(&bus->dev);
drivers/net/phy/fixed.c:	struct fixed_mdio_bus *fmb = bus->priv;
drivers/net/phy/fixed.c:	snprintf(fmb->mii_bus->id, MII_BUS_ID_SIZE, "fixed-0");
drivers/net/phy/fixed.c:	fmb->mii_bus->name = "Fixed MDIO Bus";
drivers/net/phy/fixed.c:	fmb->mii_bus->priv = fmb;
drivers/net/phy/fixed.c:	fmb->mii_bus->parent = &pdev->dev;
drivers/net/phy/fixed.c:	fmb->mii_bus->read = &fixed_mdio_read;
drivers/net/phy/fixed.c:	fmb->mii_bus->write = &fixed_mdio_write;
drivers/net/phy/fixed.c:	fmb->mii_bus->irq = fmb->irqs;
drivers/net/phy/mdio-bitbang.c:	struct mdiobb_ctrl *ctrl = bus->priv;
drivers/net/phy/mdio-bitbang.c:	struct mdiobb_ctrl *ctrl = bus->priv;
drivers/net/phy/mdio-bitbang.c:	struct mdiobb_ctrl *ctrl = bus->priv;
drivers/net/phy/mdio-bitbang.c:	bus->read = mdiobb_read;
drivers/net/phy/mdio-bitbang.c:	bus->write = mdiobb_write;
drivers/net/phy/mdio-bitbang.c:	bus->reset = mdiobb_reset;
drivers/net/phy/mdio-bitbang.c:	bus->priv = ctrl;
drivers/net/phy/mdio-bitbang.c:	struct mdiobb_ctrl *ctrl = bus->priv;
drivers/net/phy/mdio-gpio.c:	new_bus->name = "GPIO Bitbanged MDIO",
drivers/net/phy/mdio-gpio.c:	new_bus->phy_mask = pdata->phy_mask;
drivers/net/phy/mdio-gpio.c:	new_bus->irq = pdata->irqs;
drivers/net/phy/mdio-gpio.c:	new_bus->parent = dev;
drivers/net/phy/mdio-gpio.c:	if (new_bus->phy_mask == ~0)
drivers/net/phy/mdio-gpio.c:		if (!new_bus->irq[i])
drivers/net/phy/mdio-gpio.c:			new_bus->irq[i] = PHY_POLL;
drivers/net/phy/mdio-gpio.c:	snprintf(new_bus->id, MII_BUS_ID_SIZE, "gpio-%x", bus_id);
drivers/net/phy/mdio-gpio.c:	struct mdio_gpio_info *bitbang = bus->priv;
drivers/net/phy/mdio-moxart.c:	struct moxart_mdio_data *data = bus->priv;
drivers/net/phy/mdio-moxart.c:	dev_dbg(&bus->dev, "%s\n", __func__);
drivers/net/phy/mdio-moxart.c:	dev_dbg(&bus->dev, "%s timed out\n", __func__);
drivers/net/phy/mdio-moxart.c:	struct moxart_mdio_data *data = bus->priv;
drivers/net/phy/mdio-moxart.c:	dev_dbg(&bus->dev, "%s\n", __func__);
drivers/net/phy/mdio-moxart.c:	dev_dbg(&bus->dev, "%s timed out\n", __func__);
drivers/net/phy/mdio-moxart.c:	bus->name = "MOXA ART Ethernet MII";
drivers/net/phy/mdio-moxart.c:	bus->read = &moxart_mdio_read;
drivers/net/phy/mdio-moxart.c:	bus->write = &moxart_mdio_write;
drivers/net/phy/mdio-moxart.c:	bus->reset = &moxart_mdio_reset;
drivers/net/phy/mdio-moxart.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d-mii", pdev->name, pdev->id);
drivers/net/phy/mdio-moxart.c:	bus->parent = &pdev->dev;
drivers/net/phy/mdio-moxart.c:	bus->irq = devm_kzalloc(&pdev->dev, sizeof(int) * PHY_MAX_ADDR,
drivers/net/phy/mdio-moxart.c:	if (!bus->irq) {
drivers/net/phy/mdio-moxart.c:		bus->irq[i] = PHY_IGNORE_INTERRUPT;
drivers/net/phy/mdio-moxart.c:	data = bus->priv;
drivers/net/phy/mdio-mux.c:	struct mdio_mux_child_bus *cb = bus->priv;
drivers/net/phy/mdio-mux.c:	mutex_lock_nested(&pb->mii_bus->mdio_lock, SINGLE_DEPTH_NESTING);
drivers/net/phy/mdio-mux.c:	r = pb->mii_bus->read(pb->mii_bus, phy_id, regnum);
drivers/net/phy/mdio-mux.c:	mutex_unlock(&pb->mii_bus->mdio_lock);
drivers/net/phy/mdio-mux.c:	struct mdio_mux_child_bus *cb = bus->priv;
drivers/net/phy/mdio-mux.c:	mutex_lock_nested(&pb->mii_bus->mdio_lock, SINGLE_DEPTH_NESTING);
drivers/net/phy/mdio-mux.c:	r = pb->mii_bus->write(pb->mii_bus, phy_id, regnum, val);
drivers/net/phy/mdio-mux.c:	mutex_unlock(&pb->mii_bus->mdio_lock);
drivers/net/phy/mdio-mux.c:		cb->mii_bus->priv = cb;
drivers/net/phy/mdio-mux.c:		cb->mii_bus->irq = cb->phy_irq;
drivers/net/phy/mdio-mux.c:		cb->mii_bus->name = "mdio_mux";
drivers/net/phy/mdio-mux.c:		snprintf(cb->mii_bus->id, MII_BUS_ID_SIZE, "%x.%x",
drivers/net/phy/mdio-mux.c:		cb->mii_bus->parent = dev;
drivers/net/phy/mdio-mux.c:		cb->mii_bus->read = mdio_mux_read;
drivers/net/phy/mdio-mux.c:		cb->mii_bus->write = mdio_mux_write;
drivers/net/phy/mdio-octeon.c:	struct octeon_mdiobus *p = bus->priv;
drivers/net/phy/mdio-octeon.c:	struct octeon_mdiobus *p = bus->priv;
drivers/net/phy/mdio-octeon.c:	bus->mdio_phys = res_mem->start;
drivers/net/phy/mdio-octeon.c:	bus->regsize = resource_size(res_mem);
drivers/net/phy/mdio-octeon.c:	if (!devm_request_mem_region(&pdev->dev, bus->mdio_phys, bus->regsize,
drivers/net/phy/mdio-octeon.c:	bus->register_base =
drivers/net/phy/mdio-octeon.c:		(u64)devm_ioremap(&pdev->dev, bus->mdio_phys, bus->regsize);
drivers/net/phy/mdio-octeon.c:	bus->mii_bus = mdiobus_alloc();
drivers/net/phy/mdio-octeon.c:	if (!bus->mii_bus)
drivers/net/phy/mdio-octeon.c:	cvmx_write_csr(bus->register_base + SMI_EN, smi_en.u64);
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->priv = bus;
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->irq = bus->phy_irq;
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->name = "mdio-octeon";
drivers/net/phy/mdio-octeon.c:	snprintf(bus->mii_bus->id, MII_BUS_ID_SIZE, "%llx", bus->register_base);
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->parent = &pdev->dev;
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->read = octeon_mdiobus_read;
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->write = octeon_mdiobus_write;
drivers/net/phy/mdio-octeon.c:	err = of_mdiobus_register(bus->mii_bus, pdev->dev.of_node);
drivers/net/phy/mdio-octeon.c:	mdiobus_free(bus->mii_bus);
drivers/net/phy/mdio-octeon.c:	cvmx_write_csr(bus->register_base + SMI_EN, smi_en.u64);
drivers/net/phy/mdio-octeon.c:	mdiobus_unregister(bus->mii_bus);
drivers/net/phy/mdio-octeon.c:	mdiobus_free(bus->mii_bus);
drivers/net/phy/mdio-octeon.c:	cvmx_write_csr(bus->register_base + SMI_EN, smi_en.u64);
drivers/net/phy/mdio-sun4i.c:	struct sun4i_mdio_data *data = bus->priv;
drivers/net/phy/mdio-sun4i.c:	struct sun4i_mdio_data *data = bus->priv;
drivers/net/phy/mdio-sun4i.c:	bus->name = "sun4i_mii_bus";
drivers/net/phy/mdio-sun4i.c:	bus->read = &sun4i_mdio_read;
drivers/net/phy/mdio-sun4i.c:	bus->write = &sun4i_mdio_write;
drivers/net/phy/mdio-sun4i.c:	bus->reset = &sun4i_mdio_reset;
drivers/net/phy/mdio-sun4i.c:	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii", dev_name(&pdev->dev));
drivers/net/phy/mdio-sun4i.c:	bus->parent = &pdev->dev;
drivers/net/phy/mdio-sun4i.c:	bus->irq = devm_kzalloc(&pdev->dev, sizeof(int) * PHY_MAX_ADDR,
drivers/net/phy/mdio-sun4i.c:	if (!bus->irq) {
drivers/net/phy/mdio-sun4i.c:		bus->irq[i] = PHY_POLL;
drivers/net/phy/mdio-sun4i.c:	data = bus->priv;
drivers/net/phy/mdio_bus.c: * If non-zero, then bus->priv is points to that memory.
drivers/net/phy/mdio_bus.c:		bus->state = MDIOBUS_ALLOCATED;
drivers/net/phy/mdio_bus.c:			bus->priv = (void *)bus + aligned_size;
drivers/net/phy/mdio_bus.c:	BUG_ON(bus->state != MDIOBUS_RELEASED &&
drivers/net/phy/mdio_bus.c:	       bus->state != MDIOBUS_ALLOCATED);
drivers/net/phy/mdio_bus.c:	if (NULL == bus || NULL == bus->name ||
drivers/net/phy/mdio_bus.c:			NULL == bus->read ||
drivers/net/phy/mdio_bus.c:			NULL == bus->write)
drivers/net/phy/mdio_bus.c:	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
drivers/net/phy/mdio_bus.c:	       bus->state != MDIOBUS_UNREGISTERED);
drivers/net/phy/mdio_bus.c:	bus->dev.parent = bus->parent;
drivers/net/phy/mdio_bus.c:	bus->dev.class = &mdio_bus_class;
drivers/net/phy/mdio_bus.c:	bus->dev.groups = NULL;
drivers/net/phy/mdio_bus.c:	dev_set_name(&bus->dev, "%s", bus->id);
drivers/net/phy/mdio_bus.c:	err = device_register(&bus->dev);
drivers/net/phy/mdio_bus.c:		pr_err("mii_bus %s failed to register\n", bus->id);
drivers/net/phy/mdio_bus.c:	mutex_init(&bus->mdio_lock);
drivers/net/phy/mdio_bus.c:	if (bus->reset)
drivers/net/phy/mdio_bus.c:		bus->reset(bus);
drivers/net/phy/mdio_bus.c:		if ((bus->phy_mask & (1 << i)) == 0) {
drivers/net/phy/mdio_bus.c:	bus->state = MDIOBUS_REGISTERED;
drivers/net/phy/mdio_bus.c:	pr_info("%s: probed\n", bus->name);
drivers/net/phy/mdio_bus.c:		if (bus->phy_map[i])
drivers/net/phy/mdio_bus.c:			device_unregister(&bus->phy_map[i]->dev);
drivers/net/phy/mdio_bus.c:	device_del(&bus->dev);
drivers/net/phy/mdio_bus.c:	BUG_ON(bus->state != MDIOBUS_REGISTERED);
drivers/net/phy/mdio_bus.c:	bus->state = MDIOBUS_UNREGISTERED;
drivers/net/phy/mdio_bus.c:	device_del(&bus->dev);
drivers/net/phy/mdio_bus.c:		if (bus->phy_map[i])
drivers/net/phy/mdio_bus.c:			device_unregister(&bus->phy_map[i]->dev);
drivers/net/phy/mdio_bus.c:		bus->phy_map[i] = NULL;
drivers/net/phy/mdio_bus.c:	if (bus->state == MDIOBUS_ALLOCATED) {
drivers/net/phy/mdio_bus.c:	BUG_ON(bus->state != MDIOBUS_UNREGISTERED);
drivers/net/phy/mdio_bus.c:	bus->state = MDIOBUS_RELEASED;
drivers/net/phy/mdio_bus.c:	put_device(&bus->dev);
drivers/net/phy/mdio_bus.c:	mutex_lock(&bus->mdio_lock);
drivers/net/phy/mdio_bus.c:	retval = bus->read(bus, addr, regnum);
drivers/net/phy/mdio_bus.c:	mutex_unlock(&bus->mdio_lock);
drivers/net/phy/mdio_bus.c:	mutex_lock(&bus->mdio_lock);
drivers/net/phy/mdio_bus.c:	err = bus->write(bus, addr, regnum, val);
drivers/net/phy/mdio_bus.c:	mutex_unlock(&bus->mdio_lock);
drivers/net/phy/phy.c:			phydev->bus->name, phydev->irq);
drivers/net/phy/phy.c:	bus->write(bus, addr, MII_MMD_CTRL, devad);
drivers/net/phy/phy.c:	bus->write(bus, addr, MII_MMD_DATA, prtad);
drivers/net/phy/phy.c:	bus->write(bus, addr, MII_MMD_CTRL, (devad | MII_MMD_CTRL_NOINCR));
drivers/net/phy/phy.c:	ret = bus->read(bus, addr, MII_MMD_DATA);
drivers/net/phy/phy.c:	bus->write(bus, addr, MII_MMD_DATA, data);
drivers/net/phy/phy_device.c:	dev->dev.parent = bus->parent;
drivers/net/phy/phy_device.c:	dev->irq = bus->irq != NULL ? bus->irq[addr] : PHY_POLL;
drivers/net/phy/phy_device.c:	dev_set_name(&dev->dev, PHY_ID_FMT, bus->id, addr);
drivers/net/phy/phy_device.c:	if (phydev->bus->phy_map[phydev->addr])
drivers/net/phy/phy_device.c:	phydev->bus->phy_map[phydev->addr] = phydev;
drivers/net/phy/phy_device.c:	phydev->bus->phy_map[phydev->addr] = NULL;
drivers/net/phy/phy_device.c:		if (bus->phy_map[addr])
drivers/net/phy/phy_device.c:			return bus->phy_map[addr];
drivers/net/usb/ax88172a.c:	return asix_mdio_read(((struct usbnet *)bus->priv)->net, phy_id,
drivers/net/usb/ax88172a.c:	asix_mdio_write(((struct usbnet *)bus->priv)->net, phy_id, regnum, val);
drivers/net/usb/ax88172a.c:		 dev->udev->bus->busnum, dev->udev->devnum);
drivers/net/usb/catc.c:			catc->usbdev->bus->bus_name,
drivers/net/usb/catc.c:	       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);
drivers/net/usb/kaweth.c:			kaweth->dev->bus->bus_name,
drivers/net/usb/net1080.c:		  dev->udev->bus->bus_name, dev->udev->devpath,
drivers/net/usb/net1080.c:		  dev->udev->bus->bus_name, dev->udev->devpath,
drivers/net/usb/net1080.c:		  dev->udev->bus->bus_name, dev->udev->devpath,
drivers/net/usb/net1080.c:			   dev->udev->bus->bus_name, dev->udev->devpath, retval);
drivers/net/usb/rtl8150.c:			dev->udev->bus->bus_name, dev->udev->devpath, res);
drivers/net/usb/usbnet.c:				   dev->udev->bus->bus_name, dev->udev->devpath,
drivers/net/usb/usbnet.c:			   dev->udev->bus->bus_name,
drivers/net/usb/usbnet.c:			   dev->udev->bus->bus_name,
drivers/net/usb/usbnet.c:				    dev->udev->bus->bus_name,
drivers/net/usb/usbnet.c:		   xdev->bus->bus_name, xdev->devpath,
drivers/net/usb/usbnet.c:		   xdev->bus->bus_name, xdev->devpath,
drivers/net/wan/cosa.c: * COSA can be also a bus-mastering device.
drivers/net/wan/cosa.c: * In the COSA bus-master mode, we need to tell the card the address of a
drivers/net/wan/cosa.h:/* Set the driver for the bus-master operations */
drivers/net/wimax/i2400m/driver.c: * The bus-driver implementation of reset takes care of falling back
drivers/net/wimax/i2400m/driver.c: * TX needs to be setup before the bus-specific code (otherwise on
drivers/net/wimax/i2400m/driver.c: * shutdown, the bus-tx code could try to access it).
drivers/net/wimax/i2400m/driver.c:			dev_err(dev, "bus-specific setup failed: %d\n",
drivers/net/wimax/i2400m/driver.c: * bus-specific functions ops as needed.
drivers/net/wimax/i2400m/driver.c: * This is a bus-generic API call.
drivers/net/wimax/i2400m/driver.c: * i2400m_setup - bus-generic setup function for the i2400m device
drivers/net/wimax/i2400m/driver.c: * @i2400m: device descriptor (bus-specific parts have been initialized)
drivers/net/wimax/i2400m/driver.c:		 "i2400m-%s:%s", dev->bus->name, dev_name(dev));
drivers/net/wimax/i2400m/driver.c:			dev_err(dev, "bus-specific setup failed: %d\n",
drivers/net/wimax/i2400m/driver.c: * i2400m_release - release the bus-generic driver resources
drivers/net/wimax/i2400m/driver.c:MODULE_DESCRIPTION("Intel 2400M WiMAX networking bus-generic driver");
drivers/net/wimax/i2400m/fw.c: * This code is bus-generic; the bus-specific driver provides back end
drivers/net/wimax/i2400m/fw.c: * i2400m_bm_cmd_prepare              Used by bus-drivers to prep
drivers/net/wimax/i2400m/fw.c: *     bus-specific drivers padding requirements.
drivers/net/wimax/i2400m/i2400m-usb.h: * This driver implements the bus-specific part of the i2400m for
drivers/net/wimax/i2400m/i2400m-usb.h: * @i2400m: bus-generic i2400m implementation; has to be first (see
drivers/net/wimax/i2400m/i2400m.h: * Declarations for bus-generic internal APIs
drivers/net/wimax/i2400m/i2400m.h: * For details on each bus-specific driver, see it's include file,
drivers/net/wimax/i2400m/i2400m.h: * The bus-generic functionality break up is:
drivers/net/wimax/i2400m/i2400m.h: *        device. bus-specific driver just needs to provides a way to
drivers/net/wimax/i2400m/i2400m.h: *  - RX handling: rx.c - receives data from the bus-specific code and
drivers/net/wimax/i2400m/i2400m.h: *        the driver state. bus-specific driver only has to receive
drivers/net/wimax/i2400m/i2400m.h: *        for the bus-specific TX code to pull data from the FIFO
drivers/net/wimax/i2400m/i2400m.h: *        queue. bus-specific code just pulls frames from this module
drivers/net/wimax/i2400m/i2400m.h: *        controlling the device. bus-generic only.
drivers/net/wimax/i2400m/i2400m.h: *        device-model glue done by the bus-specific layer
drivers/net/wimax/i2400m/i2400m.h: *  - internal API for the bus-generic code
drivers/net/wimax/i2400m/i2400m.h: *  - external API for the bus-specific drivers
drivers/net/wimax/i2400m/i2400m.h: * When the bus-specific driver probes, it allocates a network device
drivers/net/wimax/i2400m/i2400m.h: * While the device is up, it might reset. The bus-specific driver has
drivers/net/wimax/i2400m/i2400m.h: * @bus_setup: [optional fill] Function called by the bus-generic code
drivers/net/wimax/i2400m/i2400m.h: *     [i2400m_setup()] to setup the basic bus-specific communications
drivers/net/wimax/i2400m/i2400m.h: *     care of by the bus-generic code.
drivers/net/wimax/i2400m/i2400m.h: * @bus_release: [optional fill] Function called by the bus-generic
drivers/net/wimax/i2400m/i2400m.h: *     code [i2400m_release()] to shutdown the basic bus-specific
drivers/net/wimax/i2400m/i2400m.h: * @bus_dev_start: [optional fill] Function called by the bus-generic
drivers/net/wimax/i2400m/i2400m.h: *     care of by the bus-generic code.
drivers/net/wimax/i2400m/i2400m.h: * @bus_dev_stop: [optional fill] Function called by the bus-generic
drivers/net/wimax/i2400m/i2400m.h: * @bus_tx_kick: [fill] Function called by the bus-generic code to let
drivers/net/wimax/i2400m/i2400m.h: *     the bus-specific code know that there is data available in the
drivers/net/wimax/i2400m/i2400m.h: * @bus_reset: [fill] Function called by the bus-generic code to reset
drivers/net/wimax/i2400m/i2400m.h: *     bus-specific reset (eg: USB reset) to get the device to a
drivers/net/wimax/i2400m/i2400m.h: *     bus-specific driver. Note this value is used in two places,
drivers/net/wimax/i2400m/i2400m.h: *     bus-specific code.
drivers/net/wimax/i2400m/i2400m.h: * API for the bus-specific drivers
drivers/net/wimax/i2400m/i2400m.h: * the bus-specific drivers.
drivers/net/wimax/i2400m/rx.c: * We receive an RX message from the bus-specific driver, which
drivers/net/wimax/i2400m/rx.c:		 *   bus-specific subdrivers and workqueues, so the we
drivers/net/wimax/i2400m/tx.c: *    well as splitting out bus-specific code.
drivers/net/wimax/i2400m/tx.c: * the transmission of that. This is split between a bus-independent
drivers/net/wimax/i2400m/tx.c: * part that just prepares everything and a bus-specific part that
drivers/net/wimax/i2400m/tx.c: * bus-specific driver).
drivers/net/wimax/i2400m/tx.c: * Then the bus-specific code takes the parts of that FIFO that are
drivers/net/wimax/i2400m/tx.c: * course, when the bus-specific driver attempts to TX a message that
drivers/net/wimax/i2400m/tx.c: * Now i2400m->bus_tx_kick() is the the bus-specific driver backend
drivers/net/wimax/i2400m/tx.c: * Appends the buffer to the TX FIFO and notifies the bus-specific
drivers/net/wimax/i2400m/tx.c: * Called by the bus-specific driver to get the first TX message at
drivers/net/wimax/i2400m/tx.c: * It sets the state in @i2400m to indicate the bus-specific driver is
drivers/net/wimax/i2400m/tx.c: * Called by the bus-specific driver when a message has been sent;
drivers/net/wimax/i2400m/usb.c: * generic driver to implement the bus-specific functions (device
drivers/net/wimax/i2400m/usb.c: * and will move the reset code to use a last-resort bus-based reset.
drivers/net/wimax/i2400m/usb.c: * Alloc a net device, initialize the bus-specific details and then
drivers/net/wimax/i2400m/usb.c: * calls the bus-generic initialization routine. That will register
drivers/net/wireless/ath/ath9k/pci.c:	parent = pdev->bus->self;
drivers/net/wireless/b43/bus.c:	dev->board_vendor = core->bus->boardinfo.vendor;
drivers/net/wireless/b43/bus.c:	dev->board_type = core->bus->boardinfo.type;
drivers/net/wireless/b43/bus.c:	dev->board_rev = core->bus->sprom.board_rev;
drivers/net/wireless/b43/bus.c:	dev->chip_id = core->bus->chipinfo.id;
drivers/net/wireless/b43/bus.c:	dev->chip_rev = core->bus->chipinfo.rev;
drivers/net/wireless/b43/bus.c:	dev->chip_pkg = core->bus->chipinfo.pkg;
drivers/net/wireless/b43/bus.c:	dev->bus_sprom = &core->bus->sprom;
drivers/net/wireless/b43/bus.c:	dev->board_vendor = sdev->bus->boardinfo.vendor;
drivers/net/wireless/b43/bus.c:	dev->board_type = sdev->bus->boardinfo.type;
drivers/net/wireless/b43/bus.c:	dev->board_rev = sdev->bus->sprom.board_rev;
drivers/net/wireless/b43/bus.c:	dev->chip_id = sdev->bus->chip_id;
drivers/net/wireless/b43/bus.c:	dev->chip_rev = sdev->bus->chip_rev;
drivers/net/wireless/b43/bus.c:	dev->chip_pkg = sdev->bus->chip_package;
drivers/net/wireless/b43/bus.c:	dev->bus_sprom = &sdev->bus->sprom;
drivers/net/wireless/b43/bus.h:		dev->sdev->bus->bustype == SSB_BUSTYPE_PCMCIA);
drivers/net/wireless/b43/bus.h:		dev->sdev->bus->bustype == SSB_BUSTYPE_SDIO);
drivers/net/wireless/b43/dma.c:	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
drivers/net/wireless/b43/dma.c:	    !(pci_is_pcie(dev->dev->sdev->bus->host_pci) &&
drivers/net/wireless/b43/dma.h:	/* DMA base bus-address of the descriptor buffer. */
drivers/net/wireless/b43/dma.h:	/* (Unadjusted) DMA base bus-address of the ring memory. */
drivers/net/wireless/b43/main.c:	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
drivers/net/wireless/b43/main.c:	return bus->chipco.dev;
drivers/net/wireless/b43/main.c:		bcma_chipco_gpio_control(&dev->dev->bdev->bus->drv_cc, mask, set);
drivers/net/wireless/b43/main.c:		bcma_chipco_gpio_control(&dev->dev->bdev->bus->drv_cc, ~0, 0);
drivers/net/wireless/b43/main.c:			    dev->dev->sdev->bus->chipco.fast_pwrup_delay);
drivers/net/wireless/b43/main.c:	if ((bus->chip_id == 0x4311 && bus->chip_rev == 2) ||
drivers/net/wireless/b43/main.c:	    (bus->chip_id == 0x4312)) {
drivers/net/wireless/b43/main.c:		bcma_core_pci_irq_ctl(&dev->dev->bdev->bus->drv_pci[0],
drivers/net/wireless/b43/main.c:		ssb_pcicore_dev_irqvecs_enable(&dev->dev->sdev->bus->pcicore,
drivers/net/wireless/b43/main.c:	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
drivers/net/wireless/b43/main.c:	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
drivers/net/wireless/b43/main.c:	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI)
drivers/net/wireless/b43/main.c:		pdev = dev->dev->sdev->bus->host_pci;
drivers/net/wireless/b43/main.c:	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL &&
drivers/net/wireless/b43/main.c:	    bus->chip_id == 0x4301 && bus->sprom.board_rev == 0x74)
drivers/net/wireless/b43/main.c:		bus->sprom.boardflags_lo |= B43_BFL_BTCOEXIST;
drivers/net/wireless/b43/main.c:	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
drivers/net/wireless/b43/main.c:	    bus->boardinfo.type == 0x4E && bus->sprom.board_rev > 0x40)
drivers/net/wireless/b43/main.c:		bus->sprom.boardflags_lo |= B43_BFL_PACTRL;
drivers/net/wireless/b43/main.c:	if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/net/wireless/b43/main.c:		pdev = bus->host_pci;
drivers/net/wireless/b43/main.c:			bus->sprom.boardflags_lo &= ~B43_BFL_BTCOEXIST;
drivers/net/wireless/b43/phy_ht.c:	bcma_pmu_spuravoid_pllupdate(&core->bus->drv_cc, spuravoid);
drivers/net/wireless/b43/phy_lcn.c:	struct bcma_drv_cc *cc = &dev->dev->bdev->bus->drv_cc;
drivers/net/wireless/b43/phy_lcn.c:	struct bcma_drv_cc *cc = &dev->dev->bdev->bus->drv_cc;
drivers/net/wireless/b43/phy_lp.c:		ssb_pmu_set_ldo_voltage(&bus->chipco, LDO_PAREF, 0x28);
drivers/net/wireless/b43/phy_lp.c:		ssb_pmu_set_ldo_paref(&bus->chipco, true);
drivers/net/wireless/b43/phy_lp.c:		ssb_pmu_set_ldo_paref(&bus->chipco, false);
drivers/net/wireless/b43/phy_lp.c:	crystalfreq = bus->chipco.pmu.crystalfreq * 1000;
drivers/net/wireless/b43/phy_lp.c:	B43_WARN_ON(!(bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU));
drivers/net/wireless/b43/phy_lp.c:	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
drivers/net/wireless/b43/phy_lp.c:	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
drivers/net/wireless/b43/phy_lp.c:	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
drivers/net/wireless/b43/phy_n.c:			bcma_chipco_gpio_control(&dev->dev->bdev->bus->drv_cc,
drivers/net/wireless/b43/phy_n.c:			ssb_chipco_gpio_control(&dev->dev->sdev->bus->chipco,
drivers/net/wireless/b43/phy_n.c:			bcma_cc_set32(&dev->dev->bdev->bus->drv_cc,
drivers/net/wireless/b43/phy_n.c:			chipco_set32(&dev->dev->sdev->bus->chipco,
drivers/net/wireless/b43/phy_n.c:		bcma_pmu_spuravoid_pllupdate(&dev->dev->bdev->bus->drv_cc,
drivers/net/wireless/b43/phy_n.c:		ssb_pmu_spuravoid_pllupdate(&dev->dev->sdev->bus->chipco,
drivers/net/wireless/b43/phy_n.c:			    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI) {
drivers/net/wireless/b43/phy_n.c:					dev->dev->sdev->bus->host_pci;
drivers/net/wireless/b43/sdio.c:	struct sdio_func *func = bus->host_sdio;
drivers/net/wireless/b43/sdio.c:	struct sdio_func *func = bus->host_sdio;
drivers/net/wireless/b43legacy/b43legacy.h:	return  (dev->dev->bus->boardinfo.vendor == PCI_VENDOR_ID_BROADCOM);
drivers/net/wireless/b43legacy/dma.h:	/* DMA base bus-address of the descriptor buffer. */
drivers/net/wireless/b43legacy/dma.h:	/* (Unadjusted) DMA base bus-address of the ring memory. */
drivers/net/wireless/b43legacy/leds.c:	sprom[0] = bus->sprom.gpio0;
drivers/net/wireless/b43legacy/leds.c:	sprom[1] = bus->sprom.gpio1;
drivers/net/wireless/b43legacy/leds.c:	sprom[2] = bus->sprom.gpio2;
drivers/net/wireless/b43legacy/leds.c:	sprom[3] = bus->sprom.gpio3;
drivers/net/wireless/b43legacy/leds.c:				if (bus->boardinfo.vendor == PCI_VENDOR_ID_COMPAQ)
drivers/net/wireless/b43legacy/leds.c:				if (bus->boardinfo.vendor == PCI_VENDOR_ID_ASUSTEK)
drivers/net/wireless/b43legacy/main.c:	if (dev->dev->bus->chip_id == 0x4301) {
drivers/net/wireless/b43legacy/main.c:	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL) {
drivers/net/wireless/b43legacy/main.c:	pcidev = bus->pcicore.dev;
drivers/net/wireless/b43legacy/main.c:	gpiodev = bus->chipco.dev ? : pcidev;
drivers/net/wireless/b43legacy/main.c:	pcidev = bus->pcicore.dev;
drivers/net/wireless/b43legacy/main.c:	gpiodev = bus->chipco.dev ? : pcidev;
drivers/net/wireless/b43legacy/main.c:		if (dev->dev->bus->chip_id == 0x4306 &&
drivers/net/wireless/b43legacy/main.c:		    dev->dev->bus->chip_rev == 3)
drivers/net/wireless/b43legacy/main.c:			  dev->dev->bus->chipco.fast_pwrup_delay);
drivers/net/wireless/b43legacy/main.c:	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
drivers/net/wireless/b43legacy/main.c:	if (dev->dev->bus->chip_id == 0x4317) {
drivers/net/wireless/b43legacy/main.c:		if (dev->dev->bus->chip_rev == 0)
drivers/net/wireless/b43legacy/main.c:		else if (dev->dev->bus->chip_rev == 1)
drivers/net/wireless/b43legacy/main.c:	struct ssb_sprom *sprom = &dev->dev->bus->sprom;
drivers/net/wireless/b43legacy/main.c:	ssb_pcicore_dev_irqvecs_enable(&bus->pcicore, dev->dev);
drivers/net/wireless/b43legacy/main.c:	struct pci_dev *pdev = (bus->bustype == SSB_BUSTYPE_PCI) ? bus->host_pci : NULL;
drivers/net/wireless/b43legacy/main.c:	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
drivers/net/wireless/b43legacy/main.c:	    bus->boardinfo.type == 0x4E &&
drivers/net/wireless/b43legacy/main.c:	    bus->sprom.board_rev > 0x40)
drivers/net/wireless/b43legacy/main.c:		bus->sprom.boardflags_lo |= B43legacy_BFL_PACTRL;
drivers/net/wireless/b43legacy/main.c:	struct ssb_sprom *sprom = &dev->bus->sprom;
drivers/net/wireless/b43legacy/main.c:		      dev->bus->chip_id, dev->id.revision);
drivers/net/wireless/b43legacy/phy.c:	    (dev->dev->bus->boardinfo.type == 0x0416))
drivers/net/wireless/b43legacy/phy.c:		    (dev->dev->bus->boardinfo.type == 0x0416) &&
drivers/net/wireless/b43legacy/phy.c:		    (dev->dev->bus->sprom.board_rev == 0x0017))
drivers/net/wireless/b43legacy/phy.c:		    (dev->dev->bus->boardinfo.type == 0x0416) &&
drivers/net/wireless/b43legacy/phy.c:		    (dev->dev->bus->sprom.board_rev == 0x0017))
drivers/net/wireless/b43legacy/phy.c:	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL)
drivers/net/wireless/b43legacy/phy.c:	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
drivers/net/wireless/b43legacy/phy.c:	    (dev->dev->bus->boardinfo.type != 0x0416)) {
drivers/net/wireless/b43legacy/phy.c:		if (dev->dev->bus->sprom.boardflags_lo & 0x8000) {
drivers/net/wireless/b43legacy/phy.c:		if (dev->dev->bus->sprom.boardflags_lo &
drivers/net/wireless/b43legacy/phy.c:	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_EXTLNA) {
drivers/net/wireless/b43legacy/phy.c:		if (dev->dev->bus->sprom.boardflags_lo &
drivers/net/wireless/b43legacy/phy.c:	if (!(dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI)) {
drivers/net/wireless/b43legacy/phy.c:	if (dev->dev->bus->chip_id == 0x4306
drivers/net/wireless/b43legacy/phy.c:	    && dev->dev->bus->chip_package == 2) {
drivers/net/wireless/b43legacy/phy.c:	if ((dev->dev->bus->boardinfo.type == 0x0416) &&
drivers/net/wireless/b43legacy/phy.c:	max_pwr = dev->dev->bus->sprom.maxpwr_bg;
drivers/net/wireless/b43legacy/phy.c:	if ((dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/b43legacy/phy.c:		dev->dev->bus->sprom.maxpwr_bg = max_pwr;
drivers/net/wireless/b43legacy/phy.c:		      - dev->dev->bus->sprom.antenna_gain.a0
drivers/net/wireless/b43legacy/phy.c:			} else if (dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/b43legacy/phy.c:	pab0 = (s16)(dev->dev->bus->sprom.pa0b0);
drivers/net/wireless/b43legacy/phy.c:	pab1 = (s16)(dev->dev->bus->sprom.pa0b1);
drivers/net/wireless/b43legacy/phy.c:	pab2 = (s16)(dev->dev->bus->sprom.pa0b2);
drivers/net/wireless/b43legacy/phy.c:	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
drivers/net/wireless/b43legacy/phy.c:		if ((s8)dev->dev->bus->sprom.itssi_bg != 0 &&
drivers/net/wireless/b43legacy/phy.c:		    (s8)dev->dev->bus->sprom.itssi_bg != -1)
drivers/net/wireless/b43legacy/phy.c:			phy->idle_tssi = (s8)(dev->dev->bus->sprom.
drivers/net/wireless/b43legacy/radio.c:		if (!(dev->dev->bus->sprom.boardflags_lo &
drivers/net/wireless/b43legacy/radio.c:		    !(dev->dev->bus->sprom.boardflags_lo &
drivers/net/wireless/b43legacy/radio.c:		if (phy->rev < 7 || !(dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/b43legacy/radio.c:		if (phy->rev >= 7 && dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/b43legacy/radio.c:			    !(dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/b43legacy/radio.c:		if (dev->dev->bus->sprom.country_code == 5)   /* JAPAN) */
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->boardinfo.type == 0x421 &&
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->sprom.board_rev >= 30)
drivers/net/wireless/b43legacy/radio.c:					 dev->dev->bus->boardinfo.type == 0x416)
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->boardinfo.type == 0x421 &&
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->sprom.board_rev >= 30)
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->boardinfo.type == 0x421 &&
drivers/net/wireless/b43legacy/radio.c:				    dev->dev->bus->sprom.board_rev >= 30)
drivers/net/wireless/b43legacy/radio.c:					 dev->dev->bus->boardinfo.type ==
drivers/net/wireless/b43legacy/radio.c:				else if (dev->dev->bus->chip_id == 0x4320)
drivers/net/wireless/b43legacy/radio.c:	    dev->dev->bus->boardinfo.type == 0x421) {
drivers/net/wireless/b43legacy/radio.c:		if (dev->dev->bus->sprom.board_rev < 0x43)
drivers/net/wireless/b43legacy/radio.c:		else if (dev->dev->bus->sprom.board_rev < 0x51)
drivers/net/wireless/b43legacy/xmit.c:			if (dev->dev->bus->sprom.boardflags_lo
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	return bus->ops->init(bus->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	bus->ops->stop(bus->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	return bus->ops->txdata(bus->dev, skb);
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	return bus->ops->txctl(bus->dev, msg, len);
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	return bus->ops->rxctl(bus->dev, msg, len);
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	if (!bus->ops->gettxq)
drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h:	return bus->ops->gettxq(bus->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_linux.c:	return bus->chip << 4 | bus->chiprev;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (brcmf_fwname_data[i].chipid == bus->ci->chip &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    brcmf_fwname_data[i].revmsk & BIT(bus->ci->chiprev)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		  bus->ci->chip, bus->ci->chiprev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	err = request_firmware(&fw, name, &bus->sdiodev->func[2]->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	return (u8)(bus->tx_max - bus->tx_seq) != 0 &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	       ((u8)(bus->tx_max - bus->tx_seq) & 0x80) == 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	u8 idx = brcmf_sdio_chip_getinfidx(bus->ci, BCMA_CORE_SDIO_DEV);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	*regvar = brcmf_sdio_regrl(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				   bus->ci->c_inf[idx].base + offset, &ret);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	u8 idx = brcmf_sdio_chip_getinfidx(bus->ci, BCMA_CORE_SDIO_DEV);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwl(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			 bus->ci->c_inf[idx].base + reg_offset,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		rd_val = brcmf_sdio_regrb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sr_enabled) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->clkstate = (on ? CLK_AVAIL : CLK_SDONLY);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    bus->alp_only ? SBSDIO_ALP_AVAIL_REQ : SBSDIO_HT_AVAIL_REQ;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		clkctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			devctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdio_regwb(bus->sdiodev, SBSDIO_DEVICE_CTL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->clkstate = CLK_PENDING;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		} else if (bus->clkstate == CLK_PENDING) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			devctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdio_regwb(bus->sdiodev, SBSDIO_DEVICE_CTL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		while (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			clkctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->clkstate = CLK_AVAIL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->alp_only) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->activity = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->clkstate == CLK_PENDING) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			devctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdio_regwb(bus->sdiodev, SBSDIO_DEVICE_CTL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->clkstate = CLK_SDONLY;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->clkstate = CLK_SDONLY;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->clkstate = CLK_NONE;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	uint oldstate = bus->clkstate;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->clkstate == target) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->activity = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->clkstate == CLK_NONE)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->activity = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->clkstate == CLK_NONE)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		else if (bus->clkstate == CLK_AVAIL)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				  bus->clkstate, target);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->clkstate == CLK_AVAIL)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_dbg(SDIO, "%d -> %d\n", oldstate, bus->clkstate);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		  (bus->sleeping ? "SLEEP" : "WAKE"));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sr_enabled) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (sleep == bus->sleeping)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (atomic_read(&bus->intstatus) ||
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			    atomic_read(&bus->ipend) > 0 ||
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			    (!atomic_read(&bus->fcstate) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			    brcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->idlecount = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sleeping = sleep;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->sr_enabled)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			  bus->rx_seq);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->rxskip)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->rxskip = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdpcm_ver =
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->sdpcm_ver != SDPCM_PROT_VERSION)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				  bus->sdpcm_ver, SDPCM_PROT_VERSION);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				  bus->sdpcm_ver);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (fcbits & ~bus->flowcontrol)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.fc_xoff++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->flowcontrol & ~fcbits)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.fc_xon++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.fc_rcvd++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->flowcontrol = fcbits;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdcard_abort(bus->sdiodev, SDIO_FUNC_2);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_FRAMECTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		hi = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		lo = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rxrtx++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->rxskip = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->cur_read.len = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	skb_queue_walk(&bus->glom, p)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	skb_queue_walk_safe(&bus->glom, cur, next) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		skb_unlink(cur, &bus->glom);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->rxpending = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_badhdr++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    (roundup(len, bus->blocksize) != rd->len)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_toolong++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_badhdr++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_badseq++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->flowcontrol != fc) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (~bus->flowcontrol & fc)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.fc_xoff++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->flowcontrol & ~fc)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.fc_xon++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.fc_rcvd++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->flowcontrol = fc;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((u8)(tx_seq_max - bus->tx_seq) > 0x40) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		tx_seq_max = bus->tx_seq + 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->tx_max = tx_seq_max;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sw_header = bus->tx_seq;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		  bus->glomd, skb_peek(&bus->glom));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->pdata)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		align = bus->sdiodev->pdata->sd_sgentry_align;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->glomd) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		dlen = (u16) (bus->glomd->len);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		dptr = bus->glomd->data;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				    (roundup(totlen, bus->blocksize) - totlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				totlen = roundup(totlen, bus->blocksize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			skb_queue_tail(&bus->glom, pnext);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (BRCMF_GLOM_ON() && bus->cur_read.len &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			    totlen != bus->cur_read.len) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:					  bus->cur_read.len, totlen, rxseq);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmu_pkt_buf_free_skb(bus->glomd);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->glomd = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->cur_read.len = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!skb_queue_empty(&bus->glom)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			skb_queue_walk(&bus->glom, pnext) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		pfirst = skb_peek(&bus->glom);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		errcode = brcmf_sdcard_recv_chain(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				SDIO_FUNC_2, F2SYNC, &bus->glom, dlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f2rxdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (bus->glomerr++ < 3) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->glomerr = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdcnt.rxglomfail++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->cur_read.len = rd_new.len_nxtfrm << 4;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		skb_queue_walk(&bus->glom, pnext) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (bus->glomerr++ < 3) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->glomerr = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdcnt.rxglomfail++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->cur_read.len = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		skb_queue_walk_safe(&bus->glom, pfirst, pnext) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				skb_unlink(pfirst, &bus->glom);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:					   bus->glom.qlen, pfirst, pfirst->data,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			skb_unlink(pfirst, &bus->glom);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_rx_frame(bus->sdiodev->dev, pfirst);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.rxglompkts++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rxglomframes++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	add_wait_queue(&bus->dcmd_resp_wait, &wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	remove_wait_queue(&bus->dcmd_resp_wait, &wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (waitqueue_active(&bus->dcmd_resp_wait))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		wake_up_interruptible(&bus->dcmd_resp_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->rxblen)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		buf = vzalloc(bus->rxblen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rbuf = bus->rxbuf;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		pad = bus->blocksize - (rdlen % bus->blocksize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    ((len + pad) < bus->sdiodev->bus_if->maxctl))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((rdlen + BRCMF_FIRSTREAD) > bus->sdiodev->bus_if->maxctl) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			  rdlen, bus->sdiodev->bus_if->maxctl);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((len - doff) > bus->sdiodev->bus_if->maxctl) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			  len, len - doff, bus->sdiodev->bus_if->maxctl);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_toolong++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdret = brcmf_sdcard_recv_buf(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.f2rxdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rxc_errors++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->rxctl) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		spin_unlock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxctl = buf + doff;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxctl_orig = buf;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxlen = len - doff;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_unlock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->roundup && bus->blocksize && *rdlen > bus->blocksize) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		*pad = bus->blocksize - (*rdlen % bus->blocksize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (*pad <= bus->roundup && *pad < bus->blocksize &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct brcmf_sdio_hdrinfo *rd = &bus->cur_read, rd_new;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxpending = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	for (rd->seq_num = bus->rx_seq, rxleft = maxframes;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	     !bus->rxskip && rxleft &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	     bus->sdiodev->bus_if->state != BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->glomd || !skb_queue_empty(&bus->glom)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				  bus->glomd, skb_peek(&bus->glom));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			ret = brcmf_sdcard_recv_buf(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:						      bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:						      bus->rxhdr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.f2rxhdrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdcnt.rx_hdrfail++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:					   bus->rxhdr, SDPCM_HDRLEN,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (brcmf_sdio_hdparse(bus, bus->rxhdr, rd,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				if (!bus->rxpending)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				brcmf_sdbrcm_read_control(bus, bus->rxhdr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		ret = brcmf_sdcard_recv_pkt(bus->sdiodev, bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f2rxdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			memcpy(pkt->data, bus->rxhdr, head_read);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			memcpy(bus->rxhdr, pkt->data, SDPCM_HDRLEN);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (brcmf_sdio_hdparse(bus, bus->rxhdr, &rd_new,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.rx_readahead_cnt++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:					   bus->rxhdr, SDPCM_HDRLEN,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (SDPCM_GLOMDESC(&bus->rxhdr[SDPCM_HWHDR_LEN])) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->glomd = pkt;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_rx_frame(bus->sdiodev->dev, pkt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->rxskip)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rx_seq = rd->seq_num;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (waitqueue_active(&bus->ctrl_wait))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		wake_up_interruptible(&bus->ctrl_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->pdata && bus->sdiodev->pdata->sd_head_align > 4)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		head_align = bus->sdiodev->pdata->sd_head_align;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdiodev->bus_if->tx_realloc++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		memset(dat_buf, 0, head_pad + bus->tx_hdrlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->sg_support && pktq->qlen > 1) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		err = brcmf_sdio_txpkt_prep_sg(bus->sdiodev, pktq,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	hd_info.dat_offset = head_pad + bus->tx_hdrlen;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_dbg_hex_dump(true, pkt_next, head_pad + bus->tx_hdrlen,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	ret = brcmf_sdcard_send_pkt(bus->sdiodev, bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.f2txdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.tx_sderrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdcard_abort(bus->sdiodev, SDIO_FUNC_2);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_FRAMECTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			hi = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			lo = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQ_WRAP;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_txcomplete(bus->sdiodev->dev, pkt, ret == 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	tx_prec_map = ~bus->flowcontrol;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		spin_lock_bh(&bus->txqlock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		pkt = brcmu_pktq_mdeq(&bus->txq, tx_prec_map, &prec_out);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			spin_unlock_bh(&bus->txqlock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		spin_unlock_bh(&bus->txqlock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->intr && cnt) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.f2txdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (intstatus & bus->hostintmask)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				atomic_set(&bus->ipend, 1);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->sdiodev->bus_if->state == BRCMF_BUS_DATA) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    bus->txoff && (pktq_len(&bus->txq) < TXLOW)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->txoff = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_txflowblock(bus->sdiodev->dev, false);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->watchdog_tsk) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		send_sig(SIGTERM, bus->watchdog_tsk, 1);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		kthread_stop(bus->watchdog_tsk);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->watchdog_tsk = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	local_hostintmask = bus->hostintmask;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->hostintmask = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	saveclk = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SDIO_CCCR_IOEx, SDIO_FUNC_ENABLE_1,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmu_pktq_flush(&bus->txq, true, NULL, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->glomd)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmu_pkt_buf_free_skb(bus->glomd);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxlen = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_unlock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxskip = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->tx_seq = bus->rx_seq = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->oob_irq_requested) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		spin_lock_irqsave(&bus->sdiodev->irq_en_lock, flags);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->sdiodev->irq_en && !atomic_read(&bus->ipend)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			enable_irq(bus->sdiodev->pdata->oob_irq_nr);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdiodev->irq_en = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		spin_unlock_irqrestore(&bus->sdiodev->irq_en_lock, flags);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	idx = brcmf_sdio_chip_getinfidx(bus->ci, BCMA_CORE_SDIO_DEV);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	addr = bus->ci->c_inf[idx].base +
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	ret = brcmf_sdio_regrw_helper(bus->sdiodev, addr, &val, false);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	val &= bus->hostintmask;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	atomic_set(&bus->fcstate, !!(val & I_HMB_FC_STATE));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		ret = brcmf_sdio_regrw_helper(bus->sdiodev, addr, &val, true);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_set(&bus->intstatus, 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			set_bit(n, (unsigned long *)&bus->intstatus.counter);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	uint rxlimit = bus->rxbound;	/* Rx frames to read before resched */
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	uint txlimit = bus->txbound;	/* Tx frames to send before resched */
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!bus->sr_enabled && bus->clkstate == CLK_PENDING) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		devctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		clkctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			devctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdio_regwb(bus->sdiodev, SBSDIO_DEVICE_CTL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->clkstate = CLK_AVAIL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (atomic_read(&bus->ipend) > 0) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_set(&bus->ipend, 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	intstatus = atomic_xchg(&bus->intstatus, 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_set(&bus->fcstate,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		intstatus |= (newstatus & bus->hostintmask);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->rxskip)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (PKT_AVAILABLE() && bus->clkstate == CLK_AVAIL) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->rxpending)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			set_bit(n, (unsigned long *)&bus->intstatus.counter);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (data_ok(bus) && bus->ctrl_frame_stat &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		(bus->clkstate == CLK_AVAIL)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		err = brcmf_sdcard_send_buf(bus->sdiodev, bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			SDIO_FUNC_2, F2SYNC, bus->ctrl_frame_buf,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			(u32) bus->ctrl_frame_len);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.tx_sderrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdcard_abort(bus->sdiodev, SDIO_FUNC_2);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_FRAMECTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				hi = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				lo = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQ_WRAP;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->ctrl_frame_stat = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	else if ((bus->clkstate == CLK_AVAIL) && !atomic_read(&bus->fcstate) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		 brcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		framecnt = bus->rxpending ? min(txlimit, bus->txminmax) :
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->sdiodev->bus_if->state == BRCMF_BUS_DOWN) || (err != 0)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_set(&bus->intstatus, 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	} else if (atomic_read(&bus->intstatus) ||
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		   atomic_read(&bus->ipend) > 0 ||
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		   (!atomic_read(&bus->fcstate) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    brcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_inc(&bus->dpc_tskcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->clkstate != CLK_PENDING)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    && bus->idletime == BRCMF_IDLE_IMMEDIATE) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->activity = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	return &bus->txq;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	skb_push(pkt, bus->tx_hdrlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_dbg(TRACE, "deferring pktq len %d\n", pktq_len(&bus->txq));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.fcqueued++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_irqsave(&bus->txqlock, flags);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!brcmf_c_prec_enq(bus->sdiodev->dev, &bus->txq, pkt, prec)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		skb_pull(pkt, bus->tx_hdrlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_err("out of bus->txq !!!\n");
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (pktq_len(&bus->txq) >= TXHI) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->txoff = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_txflowblock(bus->sdiodev->dev, true);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_unlock_irqrestore(&bus->txqlock, flags);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (pktq_plen(&bus->txq, prec) > qcount[prec])
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		qcount[prec] = pktq_plen(&bus->txq, prec);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (atomic_read(&bus->dpc_tskcnt) == 0) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_inc(&bus->dpc_tskcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		queue_work(bus->brcmf_wq, &bus->datawork);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct brcmf_console *c = &bus->console;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->console_addr == 0)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	addr = bus->console_addr + offsetof(struct rte_console, log_le);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr, (u8 *)&c->log_le,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr, c->buf, c->bufsize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->ctrl_frame_stat = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	ret = brcmf_sdcard_send_buf(bus->sdiodev, bus->sdiodev->sbwad,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.tx_sderrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdcard_abort(bus->sdiodev, SDIO_FUNC_2);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_FRAMECTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.f1regdata++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			hi = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			lo = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.f1regdata += 2;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQ_WRAP;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	frame = msg - bus->tx_hdrlen;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	len = (msglen += bus->tx_hdrlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		memset(frame, 0, doff + bus->tx_hdrlen);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	doff += bus->tx_hdrlen;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		u16 pad = bus->blocksize - (len % bus->blocksize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if ((pad <= bus->roundup) && (pad < bus->blocksize))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_dbg(INFO, "No bus credit bus->tx_max %d, bus->tx_seq %d\n",
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			  bus->tx_max, bus->tx_seq);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->ctrl_frame_stat = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->ctrl_frame_buf = frame;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->ctrl_frame_len = len;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		wait_event_interruptible_timeout(bus->ctrl_wait,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:						 !bus->ctrl_frame_stat,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->ctrl_frame_stat) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->idletime == BRCMF_IDLE_IMMEDIATE) &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    atomic_read(&bus->dpc_tskcnt) == 0) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->activity = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.tx_ctlerrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.tx_ctlpkts++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	shaddr = bus->ci->rambase + bus->ramsize - 4;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, shaddr, (u8 *)&addr_le, 4);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr, (u8 *)&sh_le,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, addr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rv = brcmf_sdio_ramrw(bus->sdiodev, false, console_ptr, (u8 *)conbuf,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	error = brcmf_sdio_ramrw(bus->sdiodev, false, sh->trap_addr, (u8 *)&tr,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		error = brcmf_sdio_ramrw(bus->sdiodev, false,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		error = brcmf_sdio_ramrw(bus->sdiodev, false,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct brcmf_pub *drvr = bus->sdiodev->bus_if->drvr;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_debugfs_create_sdio_count(drvr, &bus->sdcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	timeleft = brcmf_sdbrcm_dcmd_resp_wait(bus, &bus->rxlen, &pending);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	rxlen = bus->rxlen;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	memcpy(msg, bus->rxctl, min(msglen, rxlen));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxctl = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	buf = bus->rxctl_orig;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxctl_orig = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxlen = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_unlock_bh(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_ctlpkts++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.rx_ctlerrs++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct chip_info *ci = bus->ci;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->alp_only = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_chip_enter_download(bus->sdiodev, ci);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!brcmf_sdio_chip_exit_download(bus->sdiodev, ci, bus->vars,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:						   bus->varsz))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->alp_only = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdiodev->bus_if->state = BRCMF_BUS_LOAD;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (brcmf_sdio_chip_getinfidx(bus->ci, BCMA_CORE_ARM_CR4) !=
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		memcpy(&bus->ci->rst_vec, fw->data, sizeof(bus->ci->rst_vec));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	address = bus->ci->rambase;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		err = brcmf_sdio_ramrw(bus->sdiodev, true, address,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	kfree(bus->vars);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->varsz = roundup(buf_len + 1, 4);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->vars = kmalloc(bus->varsz, GFP_KERNEL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->vars == NULL) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->varsz = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	memcpy(bus->vars, varbuf, buf_len);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->vars[buf_len] = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->ci->pmurev < 17)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	addr = CORE_CC_REG(bus->ci->c_inf[0].base, chipcontrol_addr);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwl(bus->sdiodev, addr, 3, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	addr = CORE_CC_REG(bus->ci->c_inf[0].base, chipcontrol_data);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	reg = brcmf_sdio_regrl(bus->sdiodev, addr, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	val = brcmf_sdio_regrb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SDIO_CCCR_BRCM_CARDCAP,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sr_enabled = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->ci->c_inf[1].rev < 12)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	val = brcmf_sdio_regrb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!bus->sdiodev->bus_if->drvr)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.tickcnt = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->clkstate != CLK_AVAIL)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	saveclk = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SDIO_CCCR_IOEx, enable, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		ready = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->hostintmask = HOSTINTMASK;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		w_sdreg32(bus, bus->hostintmask,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_WATERMARK, 8, &err);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SDIO_CCCR_IOEx, enable, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		ret = brcmf_sdio_intr_register(bus->sdiodev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->bus_if->state == BRCMF_BUS_DOWN) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdcnt.intrcount++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_set(&bus->ipend, 1);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!bus->intr)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	atomic_inc(&bus->dpc_tskcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	queue_work(bus->brcmf_wq, &bus->datawork);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct brcmf_bus *bus_if = dev_get_drvdata(bus->sdiodev->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!bus->sr_enabled &&
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    bus->poll && (++bus->polltick >= bus->pollrate)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->polltick = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!bus->intr ||
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    (bus->sdcnt.intrcount == bus->sdcnt.lastintrs)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (atomic_read(&bus->dpc_tskcnt) == 0) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				devpend = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->sdcnt.pollcnt++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				atomic_set(&bus->ipend, 1);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				atomic_inc(&bus->dpc_tskcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				queue_work(bus->brcmf_wq, &bus->datawork);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->sdcnt.lastintrs = bus->sdcnt.intrcount;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	    bus->console_interval != 0) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->console.count += BRCMF_WD_POLL_MS;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->console.count >= bus->console_interval) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->console.count -= bus->console_interval;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->console_interval = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->idletime > 0) && (bus->clkstate == CLK_AVAIL)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (++bus->idlecount >= bus->idletime) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->idlecount = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (bus->activity) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				bus->activity = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	return (atomic_read(&bus->ipend) > 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	while (atomic_read(&bus->dpc_tskcnt)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		atomic_dec(&bus->dpc_tskcnt);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	kfree(bus->rxbuf);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxctl = bus->rxbuf = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxlen = 0;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->bus_if->maxctl) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->rxblen =
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		    roundup((bus->sdiodev->bus_if->maxctl + SDPCM_HDRLEN),
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->rxbuf = kmalloc(bus->rxblen, GFP_ATOMIC);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!(bus->rxbuf))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->alp_only = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		 brcmf_sdio_regrl(bus->sdiodev, SI_ENUM_BASE, NULL));
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		clkctl = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (brcmf_sdio_chip_attach(bus->sdiodev, &bus->ci, regsva)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if ((bus->sdiodev->pdata) && (bus->sdiodev->pdata->drive_strength))
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		drivestrength = bus->sdiodev->pdata->drive_strength;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_chip_drivestrengthinit(bus->sdiodev, bus->ci, drivestrength);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->ramsize = bus->ci->ramsize;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!(bus->ramsize)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	reg_val = brcmf_sdio_regrb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	reg_addr = CORE_CC_REG(bus->ci->c_inf[0].base,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	reg_val = brcmf_sdio_regrl(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwl(bus->sdiodev,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmu_pktq_init(&bus->txq, (PRIOMASK + 1), TXQLEN);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxhdr = (u8 *) roundup((unsigned long)&bus->hdrbuf[0],
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->intr = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->poll = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->poll)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->pollrate = 1;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SDIO_CCCR_IOEx,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxflow = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	brcmf_sdio_regwb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, 0, NULL);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->clkstate = CLK_SDONLY;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->idletime = BRCMF_IDLE_INTERVAL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->idleclock = BRCMF_IDLE_ACTIVE;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->blocksize = bus->sdiodev->func[2]->cur_blksize;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->roundup = min(max_roundup, bus->blocksize);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sleeping = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sr_enabled = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (!wait_for_completion_interruptible(&bus->watchdog_wait)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->sdcnt.tickcnt++;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->watchdog_tsk) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		complete(&bus->watchdog_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->wd_timer_valid)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			mod_timer(&bus->timer,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->ci) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_claim_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		sdio_release_host(bus->sdiodev->func[1]);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_chip_detach(&bus->ci);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->vars && bus->varsz)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			kfree(bus->vars);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->vars = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		brcmf_sdio_intr_unregister(bus->sdiodev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		cancel_work_sync(&bus->datawork);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->brcmf_wq)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			destroy_workqueue(bus->brcmf_wq);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->sdiodev->bus_if->drvr) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			brcmf_detach(bus->sdiodev->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev = sdiodev;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	skb_queue_head_init(&bus->glom);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->txbound = BRCMF_TXBOUND;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->rxbound = BRCMF_RXBOUND;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->txminmax = BRCMF_TXMINMAX;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->tx_seq = SDPCM_SEQ_WRAP - 1;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	INIT_WORK(&bus->datawork, brcmf_sdio_dataworker);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->brcmf_wq = create_singlethread_workqueue("brcmf_wq");
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->brcmf_wq == NULL) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_init(&bus->rxctl_lock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	spin_lock_init(&bus->txqlock);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	init_waitqueue_head(&bus->ctrl_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	init_waitqueue_head(&bus->dcmd_resp_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	init_timer(&bus->timer);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->timer.data = (unsigned long)bus;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->timer.function = brcmf_sdbrcm_watchdog;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	init_completion(&bus->watchdog_wait);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->watchdog_tsk = kthread_run(brcmf_sdbrcm_watchdog_thread,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (IS_ERR(bus->watchdog_tsk)) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->watchdog_tsk = NULL;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	atomic_set(&bus->dpc_tskcnt, 0);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->dev = bus->sdiodev->dev;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->ops = &brcmf_sdio_bus_ops;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->chip = bus->ci->chip;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->sdiodev->bus_if->chiprev = bus->ci->chiprev;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	bus->tx_hdrlen = SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	ret = brcmf_attach(bus->tx_hdrlen, bus->sdiodev->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	idx = brcmf_sdio_chip_getinfidx(bus->ci, BCMA_CORE_SDIO_DEV);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->ci->c_inf[idx].rev < 12) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		list_add(&dlst->list, &bus->sdiodev->bus_if->dcmd_list);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	ret = brcmf_bus_start(bus->sdiodev->dev);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (!wdtick && bus->wd_timer_valid) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		del_timer_sync(&bus->timer);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->wd_timer_valid = false;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->save_ms = wdtick;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	if (bus->sdiodev->bus_if->state == BRCMF_BUS_DOWN)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		if (bus->save_ms != BRCMF_WD_POLL_MS) {
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			if (bus->wd_timer_valid)
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:				del_timer_sync(&bus->timer);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			bus->timer.expires =
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			add_timer(&bus->timer);
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:			mod_timer(&bus->timer,
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->wd_timer_valid = true;
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:		bus->save_ms = wdtick;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:		bcmf_bus->state = BRCMF_BUS_DOWN;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:		bcmf_bus->state = BRCMF_BUS_DATA;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:	bus->dev = dev;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:	bus->bus_priv.usb = bus_pub;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:	bus->ops = &brcmf_usb_bus_ops;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:	bus->chip = bus_pub->devid;
drivers/net/wireless/brcm80211/brcmfmac/usb.c:	bus->chiprev = bus_pub->chiprev;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	if (cc->bus->nr_cores == 0)
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sii->pcibus = pbus->host_pci;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = pbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sih->chip = pbus->chipinfo.id;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sih->chiprev = pbus->chipinfo.rev;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sih->chippkg = pbus->chipinfo.pkg;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sih->boardvendor = pbus->boardinfo.vendor;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	sih->boardtype = pbus->boardinfo.type;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	cc = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/aiutils.c:	if (sii->icbus->hosttype != BCMA_HOSTTYPE_PCI)
drivers/net/wireless/brcm80211/brcmsmac/antsel.c:	struct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/channel.c:	struct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/debug.c:		drvr->wlc->hw->d11core->bus->boardinfo.vendor,
drivers/net/wireless/brcm80211/brcmsmac/debug.c:		drvr->wlc->hw->d11core->bus->boardinfo.type,
drivers/net/wireless/brcm80211/brcmsmac/dma.c:	if (sii->icbus->hosttype == BCMA_HOSTTYPE_PCI) {
drivers/net/wireless/brcm80211/brcmsmac/led.c:	struct bcma_drv_cc *cc_drv  = &wl->wlc->hw->d11core->bus->drv_cc;
drivers/net/wireless/brcm80211/brcmsmac/led.c:	struct ssb_sprom *sprom = &wl->wlc->hw->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct ssb_sprom *sprom = &wlc_hw->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	bcma_chipco_gpio_control(&wlc_hw->d11core->bus->drv_cc, gm, gc);
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct pci_dev *pcidev = core->bus->host_pci;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct ssb_sprom *sprom = &core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI)
drivers/net/wireless/brcm80211/brcmsmac/main.c:			       core->bus->boardinfo.vendor,
drivers/net/wireless/brcm80211/brcmsmac/main.c:			       core->bus->boardinfo.type);
drivers/net/wireless/brcm80211/brcmsmac/main.c:	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
drivers/net/wireless/brcm80211/brcmsmac/main.c:		wlc_hw->vendorid = core->bus->boardinfo.vendor;
drivers/net/wireless/brcm80211/brcmsmac/main.c:		wlc_hw->deviceid = core->bus->boardinfo.type;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	bcma_core_pci_irq_ctl(&wlc_hw->d11core->bus->drv_pci[0], wlc_hw->d11core,
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct pci_dev *pcidev = core->bus->host_pci;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	struct bcma_chipinfo *chipinfo = &core->bus->chipinfo;
drivers/net/wireless/brcm80211/brcmsmac/main.c:	switch (core->bus->hosttype) {
drivers/net/wireless/brcm80211/brcmsmac/main.c:		pr_err("unknown host type: %i\n", core->bus->hosttype);
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:	if ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:	if ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_cmn.c:			bcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_write(&pi->d11core->bus->drv_cc, 0x2,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_maskset(&pi->d11core->bus->drv_cc, 0x3,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_write(&pi->d11core->bus->drv_cc, 0x4,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_cc_set32(&pi->d11core->bus->drv_cc, BCMA_CC_PMU_CTL,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_write(&pi->d11core->bus->drv_cc, 0x2,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_maskset(&pi->d11core->bus->drv_cc, 0x3,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_chipco_pll_write(&pi->d11core->bus->drv_cc, 0x4,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:		bcma_cc_set32(&pi->d11core->bus->drv_cc, BCMA_CC_PMU_CTL,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:	bcma_chipco_regctl_maskset(&pi->d11core->bus->drv_cc, 0, ~0xf, 0x9);
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:	bcma_chipco_chipctl_maskset(&pi->d11core->bus->drv_cc, 0, 0x0,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:	struct ssb_sprom *sprom = &pi->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c:	pi->xtalfreq = bcma_chipco_get_alp_clock(&pi->d11core->bus->drv_cc);
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:	struct ssb_sprom *sprom = &pi->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:	struct ssb_sprom *sprom = &pi->d11core->bus->sprom;
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:			bcma_cc_set32(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:		bcma_chipco_chipctl_maskset(&pi->d11core->bus->drv_cc, 1,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:			bcma_pmu_spuravoid_pllupdate(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:			bcma_pmu_spuravoid_pllupdate(&pi->d11core->bus->drv_cc,
drivers/net/wireless/brcm80211/brcmsmac/phy/phy_n.c:		bcma_chipco_gpio_control(&pi->d11core->bus->drv_cc, mask, mask);
drivers/net/wireless/brcm80211/brcmsmac/pmu.c:	core = sii->icbus->drv_cc.core;
drivers/net/wireless/brcm80211/brcmsmac/stf.c:	struct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;
drivers/net/wireless/iwlegacy/3945-mac.c: * Copy into buffers for card to fetch via bus-mastering
drivers/net/wireless/iwlegacy/3945-mac.c:	/* Allocate ucode buffers for card's bus-master loading ... */
drivers/net/wireless/iwlegacy/3945-mac.c:	/* Copy images into buffers for card's bus-master reads ... */
drivers/net/wireless/iwlegacy/3945-mac.c:	/* fetch ucode file from disk, alloc and copy to bus-master buffers ...
drivers/net/wireless/iwlegacy/4965-mac.c:	/* Allocate ucode buffers for card's bus-master loading ... */
drivers/net/wireless/iwlegacy/4965-mac.c:	/* Copy images into buffers for card's bus-master reads ... */
drivers/net/wireless/iwlwifi/iwl-drv.c:	/* Allocate ucode buffers for card's bus-master loading ... */
drivers/net/wireless/libertas/README:bus-info:
drivers/net/wireless/prism54/islpci_hotplug.c:	/* enable PCI bus-mastering */
drivers/net/wireless/rtlwifi/pci.c:	struct pci_dev *bridge_pdev = pdev->bus->self;
drivers/net/wireless/rtlwifi/pci.c:	pcipriv->ndis_adapter.busnumber = pdev->bus->number;
drivers/net/wireless/rtlwifi/pci.c:		    bridge_pdev->bus->number;
drivers/of/address.c:	if (strcmp(bus->name, "pci")) {
drivers/of/address.c:	bus->count_cells(dev, &na, &ns);
drivers/of/address.c:	prop = of_get_property(dev, bus->addresses, &psize);
drivers/of/address.c:				*flags = bus->get_flags(prop);
drivers/of/address.c:		offset = bus->map(addr, ranges, na, ns, pna);
drivers/of/address.c:	return pbus->translate(addr, offset, pna);
drivers/of/address.c:	bus->count_cells(dev, &na, &ns);
drivers/of/address.c:	    bus->name, na, ns, of_node_full_name(parent));
drivers/of/address.c:		pbus->count_cells(dev, &pna, &pns);
drivers/of/address.c:		    pbus->name, pna, pns, of_node_full_name(parent));
drivers/of/address.c:	bus->count_cells(dev, &na, &ns);
drivers/of/address.c:	bus->count_cells(dev, &na, &ns);
drivers/of/address.c:	prop = of_get_property(dev, bus->addresses, &psize);
drivers/of/address.c:				*flags = bus->get_flags(prop);
drivers/of/of_mtd.c:	if (of_property_read_u32(np, "nand-bus-width", &val))
drivers/of/of_pci.c: * of_pci_parse_bus_range() - parse the bus-range property of a PCI device
drivers/of/of_pci.c: * @res: address to a struct resource to return the bus-range
drivers/of/of_pci.c:	values = of_get_property(node, "bus-range", &len);
drivers/of/of_pci_irq.c:		ppdev = pdev->bus->self;
drivers/of/of_pci_irq.c:	laddr[0] = cpu_to_be32((pdev->bus->number << 16) | (pdev->devfn << 8));
drivers/of/platform.c:			 __func__, bus->full_name);
drivers/parisc/dino.c:	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/dino.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/dino.c:	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/dino.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/dino.c:	struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/dino.c:			 dev_name(bus->bridge));
drivers/parisc/dino.c:		       dev_name(bus->bridge));
drivers/parisc/dino.c:		list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
drivers/parisc/dino.c:	bus->resource[1] = res;
drivers/parisc/dino.c:	bus->resource[0] = &(dino_dev->hba.io_space);
drivers/parisc/dino.c:        struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/dino.c:	    __func__, bus, bus->busn_res.start,
drivers/parisc/dino.c:	    bus->bridge->platform_data);
drivers/parisc/dino.c:	} else if (bus->parent) {
drivers/parisc/dino.c:			if((bus->self->resource[i].flags & 
drivers/parisc/dino.c:			if(bus->self->resource[i].flags & IORESOURCE_MEM) {
drivers/parisc/dino.c:				bus->self->resource[i].end = bus->self->resource[i].end - bus->self->resource[i].start + DINO_BRIDGE_ALIGN;
drivers/parisc/dino.c:				bus->self->resource[i].start = DINO_BRIDGE_ALIGN;
drivers/parisc/dino.c:			    dev_name(&bus->self->dev), i,
drivers/parisc/dino.c:			    &bus->self->resource[i]);
drivers/parisc/dino.c:			WARN_ON(pci_assign_resource(bus->self, i));
drivers/parisc/dino.c:			    dev_name(&bus->self->dev), i,
drivers/parisc/dino.c:			    &bus->self->resource[i]);
drivers/parisc/dino.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/parisc/iosapic.c:	if (pcidev->bus->parent) {
drivers/parisc/iosapic.c:			pcidev->bus->busn_res.start, intr_slot, intr_pin);
drivers/parisc/lba_pci.c:	u8 first_bus = d->hba.hba_bus->busn_res.start;
drivers/parisc/lba_pci.c:	u8 last_sub_bus = d->hba.hba_bus->busn_res.end;
drivers/parisc/lba_pci.c:	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/lba_pci.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/lba_pci.c:	if (LBA_SKIP_PROBE(d) && !lba_device_present(bus->busn_res.start, devfn, d)) {
drivers/parisc/lba_pci.c:	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/lba_pci.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/lba_pci.c:	if (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->busn_res.start, devfn, d))) {
drivers/parisc/lba_pci.c:	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/lba_pci.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/lba_pci.c:	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/lba_pci.c:	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
drivers/parisc/lba_pci.c:	struct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));
drivers/parisc/lba_pci.c:		bus, (int)bus->busn_res.start, bus->bridge->platform_data);
drivers/parisc/lba_pci.c:	if (bus->parent) {
drivers/parisc/lba_pci.c:			pci_claim_resource(bus->self, i);
drivers/parisc/lba_pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/parisc/lba_pci.c:		bus->bridge_ctl &= ~(status & PCI_STATUS_FAST_BACK);
drivers/parisc/lba_pci.c:		if (bus->parent) {
drivers/parisc/lba_pci.c:			(void) pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &control);
drivers/parisc/lba_pci.c:			(void) pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, control | PCI_STATUS_FAST_BACK);
drivers/parisc/lba_pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/parisc/lba_pci.c:	** represents bus->secondary and the second byte represents
drivers/parisc/lba_pci.c:	** bus->subsidiary (i.e. highest PPB programmed by firmware).
drivers/pci/access.c:	res = bus->ops->read(bus, devfn, pos, len, &data);		\
drivers/pci/access.c:	res = bus->ops->write(bus, devfn, pos, len, value);		\
drivers/pci/access.c:	old_ops = bus->ops;
drivers/pci/access.c:	bus->ops = ops;
drivers/pci/access.c:	ret = dev->bus->ops->read(dev->bus, dev->devfn,			\
drivers/pci/access.c:	ret = dev->bus->ops->write(dev->bus, dev->devfn,		\
drivers/pci/bus.c:		dev_err(&bus->dev, "can't add %pR resource\n", res);
drivers/pci/bus.c:	list_add_tail(&bus_res->list, &bus->resources);
drivers/pci/bus.c:		return bus->resource[n];
drivers/pci/bus.c:	list_for_each_entry(bus_res, &bus->resources, list) {
drivers/pci/bus.c:		bus->resource[i] = NULL;
drivers/pci/bus.c:	list_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {
drivers/pci/bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/bus.c:		if (next == &bus->devices) {
drivers/pci/bus.c:			next = bus->self->bus_list.next;
drivers/pci/bus.c:			bus = bus->self->bus;
drivers/pci/bus.c:		get_device(&bus->dev);
drivers/pci/bus.c:		put_device(&bus->dev);
drivers/pci/host-bridge.c:	while (bus->parent)
drivers/pci/host-bridge.c:		bus = bus->parent;
drivers/pci/host-bridge.c:	return to_pci_host_bridge(bus->bridge);
drivers/pci/host/pci-mvebu.c:	mvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),
drivers/pci/host/pci-mvebu.c:	mvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),
drivers/pci/host/pci-mvebu.c:		if (bus->number == 0 && port->devfn == devfn)
drivers/pci/host/pci-mvebu.c:		if (bus->number != 0 &&
drivers/pci/host/pci-mvebu.c:		    bus->number >= port->bridge.secondary_bus &&
drivers/pci/host/pci-mvebu.c:		    bus->number <= port->bridge.subordinate_bus)
drivers/pci/host/pci-mvebu.c:	struct mvebu_pcie *pcie = sys_to_pcie(bus->sysdata);
drivers/pci/host/pci-mvebu.c:	if (bus->number == 0)
drivers/pci/host/pci-mvebu.c:	if (bus->number == port->bridge.secondary_bus &&
drivers/pci/host/pci-mvebu.c:	struct mvebu_pcie *pcie = sys_to_pcie(bus->sysdata);
drivers/pci/host/pci-mvebu.c:	if (bus->number == 0)
drivers/pci/host/pci-mvebu.c:	if (bus->number == port->bridge.secondary_bus &&
drivers/pci/host/pci-mvebu.c:	struct mvebu_pcie *pcie = sys_to_pcie(bus->sysdata);
drivers/pci/host/pci-mvebu.c:	bus->msi = pcie->msi;
drivers/pci/host/pci-mvebu.c:	if (dev->bus->number != 0)
drivers/pci/host/pci-mvebu.c:		dev_err(&pdev->dev, "failed to parse bus-range property: %d\n",
drivers/pci/host/pci-rcar-gen2.c:	struct pci_sys_data *sys = bus->sysdata;
drivers/pci/host/pci-rcar-gen2.c:	if (sys->busnr != bus->number || PCI_FUNC(devfn))
drivers/pci/host/pci-rcar-gen2.c:	struct pci_sys_data *sys = dev->bus->sysdata;
drivers/pci/host/pci-tegra.c:	INIT_LIST_HEAD(&bus->list);
drivers/pci/host/pci-tegra.c:	bus->nr = busnr;
drivers/pci/host/pci-tegra.c:	bus->area = get_vm_area(SZ_1M, VM_IOREMAP);
drivers/pci/host/pci-tegra.c:	if (!bus->area) {
drivers/pci/host/pci-tegra.c:		unsigned long virt = (unsigned long)bus->area->addr +
drivers/pci/host/pci-tegra.c:	vunmap(bus->area->addr);
drivers/pci/host/pci-tegra.c:		if (bus->nr == busnr)
drivers/pci/host/pci-tegra.c:			return (void __iomem *)bus->area->addr;
drivers/pci/host/pci-tegra.c:	list_add_tail(&bus->list, &pcie->buses);
drivers/pci/host/pci-tegra.c:	return (void __iomem *)bus->area->addr;
drivers/pci/host/pci-tegra.c:	struct tegra_pcie *pcie = sys_to_pcie(bus->sysdata);
drivers/pci/host/pci-tegra.c:	if (bus->number == 0) {
drivers/pci/host/pci-tegra.c:		addr = tegra_pcie_bus_map(pcie, bus->number);
drivers/pci/host/pci-tegra.c:				bus->number);
drivers/pci/host/pci-tegra.c:	struct tegra_pcie *pcie = sys_to_pcie(pdev->bus->sysdata);
drivers/pci/host/pci-tegra.c:		struct tegra_pcie *pcie = sys_to_pcie(bus->sysdata);
drivers/pci/host/pci-tegra.c:		bus->msi = &pcie->msi.chip;
drivers/pci/host/pcie-designware.c:	struct pcie_port *pp = sys_to_pcie(desc->dev->bus->sysdata);
drivers/pci/host/pcie-designware.c:	pp = sys_to_pcie(msi->dev->bus->sysdata);
drivers/pci/host/pcie-designware.c:	struct pcie_port *pp = sys_to_pcie(pdev->bus->sysdata);
drivers/pci/host/pcie-designware.c:	busdev = PCIE_ATU_BUS(bus->number) | PCIE_ATU_DEV(PCI_SLOT(devfn)) |
drivers/pci/host/pcie-designware.c:	if (bus->parent->number == pp->root_bus_nr) {
drivers/pci/host/pcie-designware.c:	busdev = PCIE_ATU_BUS(bus->number) | PCIE_ATU_DEV(PCI_SLOT(devfn)) |
drivers/pci/host/pcie-designware.c:	if (bus->parent->number == pp->root_bus_nr) {
drivers/pci/host/pcie-designware.c:	if (bus->number != pp->root_bus_nr) {
drivers/pci/host/pcie-designware.c:	if (bus->number == pp->root_bus_nr && dev > 0)
drivers/pci/host/pcie-designware.c:	if (bus->primary == pp->root_bus_nr && dev > 0)
drivers/pci/host/pcie-designware.c:	struct pcie_port *pp = sys_to_pcie(bus->sysdata);
drivers/pci/host/pcie-designware.c:	if (bus->number != pp->root_bus_nr)
drivers/pci/host/pcie-designware.c:	struct pcie_port *pp = sys_to_pcie(bus->sysdata);
drivers/pci/host/pcie-designware.c:	if (bus->number != pp->root_bus_nr)
drivers/pci/host/pcie-designware.c:	struct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);
drivers/pci/host/pcie-designware.c:		struct pcie_port *pp = sys_to_pcie(bus->sysdata);
drivers/pci/host/pcie-designware.c:		bus->msi = &dw_pcie_msi_chip;
drivers/pci/hotplug/acpi_pcihp.c:	for (pbus = dev->bus; pbus; pbus = pbus->parent) {
drivers/pci/hotplug/acpi_pcihp.c:		for (pbus = pdev->bus; pbus; pbus = pbus->parent) {
drivers/pci/hotplug/acpiphp_glue.c:	put_device(&bridge->pci_bus->dev);
drivers/pci/hotplug/acpiphp_glue.c:	if (!bus->self)
drivers/pci/hotplug/acpiphp_glue.c:	pci_read_config_dword(bus->self,
drivers/pci/hotplug/acpiphp_glue.c:	if (((buses >> 8) & 0xff) != bus->busn_res.start) {
drivers/pci/hotplug/acpiphp_glue.c:			| ((unsigned int)(bus->primary)     <<  0)
drivers/pci/hotplug/acpiphp_glue.c:			| ((unsigned int)(bus->busn_res.start)   <<  8)
drivers/pci/hotplug/acpiphp_glue.c:			| ((unsigned int)(bus->busn_res.end) << 16);
drivers/pci/hotplug/acpiphp_glue.c:		pci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);
drivers/pci/hotplug/acpiphp_glue.c:		    sun, pci_domain_nr(pbus), pbus->number, device);
drivers/pci/hotplug/acpiphp_glue.c:	 * that is equivalent to the bus->subordinate
drivers/pci/hotplug/acpiphp_glue.c:	 * bus->subordinate value because it could have
drivers/pci/hotplug/acpiphp_glue.c:	max = bus->busn_res.start;
drivers/pci/hotplug/acpiphp_glue.c:	list_for_each(tmp, &bus->children) {
drivers/pci/hotplug/acpiphp_glue.c:		list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/hotplug/acpiphp_glue.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/hotplug/acpiphp_glue.c:	list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pci/hotplug/acpiphp_glue.c:		list_for_each_entry_safe(child, tmp, &bus->devices, bus_list)
drivers/pci/hotplug/acpiphp_glue.c:			list_for_each_entry_safe(dev, tmp, &bus->devices,
drivers/pci/hotplug/acpiphp_glue.c:	list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pci/hotplug/acpiphp_glue.c:	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
drivers/pci/hotplug/acpiphp_glue.c:	handle = ACPI_HANDLE(bus->bridge);
drivers/pci/hotplug/acpiphp_glue.c:	bridge->pci_dev = pci_dev_get(bus->self);
drivers/pci/hotplug/acpiphp_glue.c:	get_device(&bus->dev);
drivers/pci/hotplug/acpiphp_glue.c:			put_device(&bus->dev);
drivers/pci/hotplug/cpci_hotplug_core.c:		snprintf(name, SLOT_NAME_SIZE, "%02x:%02x", bus->number, i);
drivers/pci/hotplug/cpci_hotplug_pci.c:		    slot->bus->number, PCI_SLOT(slot->devfn), PCI_FUNC(slot->devfn));
drivers/pci/hotplug/cpci_hotplug_pci.c:	list_for_each_entry_safe(dev, temp, &slot->bus->devices, bus_list) {
drivers/pci/hotplug/cpqphp_core.c:			bus->number = tbus;
drivers/pci/hotplug/cpqphp_core.c:		if (bus->cur_bus_speed == PCI_SPEED_66MHz)
drivers/pci/hotplug/cpqphp_core.c:				bus->max_bus_speed = PCI_SPEED_133MHz_PCIX;
drivers/pci/hotplug/cpqphp_core.c:				bus->max_bus_speed = PCI_SPEED_100MHz_PCIX;
drivers/pci/hotplug/cpqphp_core.c:				bus->max_bus_speed = PCI_SPEED_66MHz_PCIX;
drivers/pci/hotplug/cpqphp_core.c:				bus->max_bus_speed = PCI_SPEED_66MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_33MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_33MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_33MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_66MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_100MHz_PCIX;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_66MHz;
drivers/pci/hotplug/cpqphp_core.c:			bus->max_bus_speed = PCI_SPEED_33MHz;
drivers/pci/hotplug/cpqphp_core.c:					pdev->bus->number);
drivers/pci/hotplug/cpqphp_core.c:	dbg("    speed_capability       %d\n", bus->max_bus_speed);
drivers/pci/hotplug/cpqphp_core.c:	ctrl->bus = pdev->bus->number;
drivers/pci/hotplug/cpqphp_core.c:	bus->cur_bus_speed = get_controller_speed(ctrl);
drivers/pci/hotplug/cpqphp_core.c:	rc = get_slot_mapping(ctrl->pci_bus, pdev->bus->number,
drivers/pci/hotplug/cpqphp_ctrl.c:	if (bus->cur_bus_speed == adapter_speed)
drivers/pci/hotplug/cpqphp_ctrl.c:		if (bus->cur_bus_speed < adapter_speed)
drivers/pci/hotplug/cpqphp_ctrl.c:	if ((bus->cur_bus_speed > adapter_speed) && (!ctrl->pcix_speed_capability))
drivers/pci/hotplug/cpqphp_ctrl.c:	if ((bus->cur_bus_speed < adapter_speed) && (!ctrl->pcix_speed_capability))
drivers/pci/hotplug/cpqphp_ctrl.c:	if (bus->max_bus_speed < adapter_speed) {
drivers/pci/hotplug/cpqphp_ctrl.c:		if (bus->cur_bus_speed == bus->max_bus_speed)
drivers/pci/hotplug/cpqphp_ctrl.c:		adapter_speed = bus->max_bus_speed;
drivers/pci/hotplug/cpqphp_ctrl.c:	if (((bus->cur_bus_speed == PCI_SPEED_66MHz) && (adapter_speed == PCI_SPEED_66MHz_PCIX)) ||
drivers/pci/hotplug/cpqphp_ctrl.c:		((bus->cur_bus_speed == PCI_SPEED_66MHz_PCIX) && (adapter_speed == PCI_SPEED_66MHz)))
drivers/pci/hotplug/cpqphp_ctrl.c:	bus->cur_bus_speed = adapter_speed;
drivers/pci/hotplug/cpqphp_ctrl.c:		if (bus->cur_bus_speed != adapter_speed)
drivers/pci/hotplug/cpqphp_ctrl.c:	if (bus->cur_bus_speed != adapter_speed)
drivers/pci/hotplug/cpqphp_ctrl.c:		ctrl->pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_ctrl.c:		pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_ctrl.c:	ctrl->pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_ctrl.c:	pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_ctrl.c:			pci_bus->number = hold_bus_node->base;
drivers/pci/hotplug/cpqphp_ctrl.c:			pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_ctrl.c:			dbg("CND: bus=%d, devfn=%d, offset=%d\n", pci_bus->number, devfn, cloop);
drivers/pci/hotplug/cpqphp_nvram.c:		while (numbus--) {
drivers/pci/hotplug/cpqphp_pci.c:		fakebus->number = bus_num;
drivers/pci/hotplug/cpqphp_pci.c:	ctrl->pci_bus->number = bus_num;
drivers/pci/hotplug/cpqphp_pci.c:			ctrl->pci_bus->number = tbus;
drivers/pci/hotplug/cpqphp_pci.c:	ctrl->pci_bus->number = busnumber;
drivers/pci/hotplug/cpqphp_pci.c:					ctrl->pci_bus->number = busnumber;
drivers/pci/hotplug/cpqphp_pci.c:	ctrl->pci_bus->number = new_slot->bus;
drivers/pci/hotplug/cpqphp_pci.c:			ctrl->pci_bus->number = new_slot->bus;
drivers/pci/hotplug/cpqphp_pci.c:		pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_pci.c:			pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_pci.c:		pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_pci.c:		pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_pci.c:		pci_bus->number = func->bus;
drivers/pci/hotplug/cpqphp_pci.c:		ctrl->pci_bus->number = primary_bus;
drivers/pci/hotplug/ibmphp_core.c:		bus->max_bus_speed = speed;
drivers/pci/hotplug/ibmphp_core.c:	bus->cur_bus_speed = bus_speed;
drivers/pci/hotplug/ibmphp_core.c:	bus->number = busno;
drivers/pci/hotplug/ibmphp_core.c:	bus->ops = ibmphp_pci_bus->ops;
drivers/pci/hotplug/ibmphp_core.c:			pci_scan_bus(busno, ibmphp_pci_bus->ops, NULL);
drivers/pci/hotplug/ibmphp_ebda.c:			if ((dev->devfn == ctrl->u.pci_ctlr.dev_fun) && (dev->bus->number == ctrl->u.pci_ctlr.bus)) {
drivers/pci/hotplug/ibmphp_pci.c:		ibmphp_pci_bus->number = cur_func->busno;
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = func->busno;
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = func->busno;
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = func->busno;
drivers/pci/hotplug/ibmphp_pci.c:			bus->busno = sec_number;
drivers/pci/hotplug/ibmphp_pci.c:		} else if (!(bus->rangeIO) && !(bus->rangeMem) && !(bus->rangePFMem))
drivers/pci/hotplug/ibmphp_pci.c:		if (bus->noIORanges) {
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_BASE, 0x00 | bus->rangeIO->start >> 8);
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_LIMIT, 0x00 | bus->rangeIO->end >> 8);
drivers/pci/hotplug/ibmphp_pci.c:		if (bus->noMemRanges) {
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, 0x0000 | bus->rangeMem->start >> 16);
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, 0x0000 | bus->rangeMem->end >> 16);
drivers/pci/hotplug/ibmphp_pci.c:		if (bus->noPFMemRanges) {
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, 0x0000 | bus->rangePFMem->start >> 16);
drivers/pci/hotplug/ibmphp_pci.c:			pci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, 0x0000 | bus->rangePFMem->end >> 16);
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = busno;
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = busno;
drivers/pci/hotplug/ibmphp_pci.c:	ibmphp_pci_bus->number = busno;
drivers/pci/hotplug/ibmphp_pci.c:	debug("bus->busno is %x\n", bus->busno);
drivers/pci/hotplug/ibmphp_pci.c:		ibmphp_pci_bus->number = busno;
drivers/pci/hotplug/ibmphp_pci.c:		list_add (&bus->bus_list, &cur_bus->bus_list);
drivers/pci/hotplug/ibmphp_pci.c:		bus->noIORanges = 1;
drivers/pci/hotplug/ibmphp_pci.c:		bus->rangeIO = io_range;
drivers/pci/hotplug/ibmphp_pci.c:		bus->noMemRanges = 1;
drivers/pci/hotplug/ibmphp_pci.c:		bus->rangeMem = mem_range;
drivers/pci/hotplug/ibmphp_pci.c:		bus->noPFMemRanges = 1;
drivers/pci/hotplug/ibmphp_pci.c:		bus->rangePFMem = pfmem_range;
drivers/pci/hotplug/ibmphp_pci.c:	max = bus->slot_max;
drivers/pci/hotplug/ibmphp_pci.c:	min = bus->slot_min;
drivers/pci/hotplug/ibmphp_res.c:		newbus->busno = busno;
drivers/pci/hotplug/ibmphp_res.c:		newbus->busno = curr->bus_num;
drivers/pci/hotplug/ibmphp_res.c:	list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:		newbus->busno = curr->bus_num;
drivers/pci/hotplug/ibmphp_res.c:				num_ranges = newbus->noMemRanges;
drivers/pci/hotplug/ibmphp_res.c:				num_ranges = newbus->noPFMemRanges;
drivers/pci/hotplug/ibmphp_res.c:				num_ranges = newbus->noIORanges;
drivers/pci/hotplug/ibmphp_res.c:		debug ("%d resource Primary Bus inserted on bus %x [%x - %x]\n", flag, newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:			newbus->rangeMem = newrange;
drivers/pci/hotplug/ibmphp_res.c:				newbus->noMemRanges = 1;
drivers/pci/hotplug/ibmphp_res.c:				debug ("First Memory Primary on bus %x, [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:				++newbus->noMemRanges;
drivers/pci/hotplug/ibmphp_res.c:			newbus->rangeIO = newrange;
drivers/pci/hotplug/ibmphp_res.c:				newbus->noIORanges = 1;
drivers/pci/hotplug/ibmphp_res.c:				debug ("First IO Primary on bus %x, [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:				++newbus->noIORanges;
drivers/pci/hotplug/ibmphp_res.c:			newbus->rangePFMem = newrange;
drivers/pci/hotplug/ibmphp_res.c:				newbus->noPFMemRanges = 1;
drivers/pci/hotplug/ibmphp_res.c:				debug ("1st PFMemory Primary on Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:				++newbus->noPFMemRanges;
drivers/pci/hotplug/ibmphp_res.c:					list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:					debug ("gbuses = NULL, Memory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:						list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:						debug ("New Bus, Memory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:					list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:					debug ("gbuses = NULL, PFMemory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:						list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:						debug ("1st Bus, PFMemory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:					list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:					debug ("gbuses = NULL, IO Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:						list_add_tail (&newbus->bus_list, &gbuses);
drivers/pci/hotplug/ibmphp_res.c:						debug ("1st Bus, IO Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);
drivers/pci/hotplug/ibmphp_res.c:					newbus->firstMem = new_mem;
drivers/pci/hotplug/ibmphp_res.c:					++newbus->needMemUpdate;
drivers/pci/hotplug/ibmphp_res.c:					newbus->firstPFMem = new_pfmem;
drivers/pci/hotplug/ibmphp_res.c:					++newbus->needPFMemUpdate;
drivers/pci/hotplug/ibmphp_res.c:					newbus->firstIO = new_io;
drivers/pci/hotplug/ibmphp_res.c:					++newbus->needIOUpdate;
drivers/pci/hotplug/ibmphp_res.c:	debug ("In ibmphp_remove_bus... prev_bus->busno is %x\n", prev_bus->busno);
drivers/pci/hotplug/ibmphp_res.c:	if (bus->firstIO) {
drivers/pci/hotplug/ibmphp_res.c:		res_cur = bus->firstIO;
drivers/pci/hotplug/ibmphp_res.c:		bus->firstIO = NULL;
drivers/pci/hotplug/ibmphp_res.c:	if (bus->firstMem) {
drivers/pci/hotplug/ibmphp_res.c:		res_cur = bus->firstMem;
drivers/pci/hotplug/ibmphp_res.c:		bus->firstMem = NULL;
drivers/pci/hotplug/ibmphp_res.c:	if (bus->firstPFMem) {
drivers/pci/hotplug/ibmphp_res.c:		res_cur = bus->firstPFMem;
drivers/pci/hotplug/ibmphp_res.c:		bus->firstPFMem = NULL;
drivers/pci/hotplug/ibmphp_res.c:	if (bus->firstPFMemFromMem) {
drivers/pci/hotplug/ibmphp_res.c:		res_cur = bus->firstPFMemFromMem;
drivers/pci/hotplug/ibmphp_res.c:		bus->firstPFMemFromMem = NULL;
drivers/pci/hotplug/ibmphp_res.c:	list_del (&bus->bus_list);
drivers/pci/hotplug/ibmphp_res.c:			res_cur = bus->firstIO;
drivers/pci/hotplug/ibmphp_res.c:			res_cur = bus->firstMem;
drivers/pci/hotplug/ibmphp_res.c:			res_cur = bus->firstPFMem;
drivers/pci/hotplug/ibmphp_res.c:			res_cur = bus->firstPFMemFromMem;
drivers/pci/hotplug/ibmphp_res.c:	ibmphp_pci_bus->number = bus_cur->busno;
drivers/pci/hotplug/pciehp_hpc.c:			pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
drivers/pci/hotplug/pciehp_pci.c:	 * which will update the bus->devices list and confuse the
drivers/pci/hotplug/rpadlpar_core.c:	/* Add EADS device to PHB bus, adding new entry to bus->devices */
drivers/pci/hotplug/rpadlpar_core.c:		 bus->self ? pci_name(bus->self) : "<!PHB!>");
drivers/pci/hotplug/rpadlpar_core.c:			 pci_domain_nr(bus), bus->number);
drivers/pci/hotplug/rpadlpar_core.c:	BUG_ON(!bus->self);
drivers/pci/hotplug/rpadlpar_core.c:	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
drivers/pci/hotplug/rpadlpar_core.c:	pci_stop_and_remove_bus_device(bus->self);
drivers/pci/hotplug/rpaphp_core.c:	slot->bus->max_bus_speed = get_max_bus_speed(slot);
drivers/pci/hotplug/rpaphp_pci.c:	slot->pci_devs = &bus->devices;
drivers/pci/hotplug/rpaphp_pci.c:		if (list_empty(&bus->devices))
drivers/pci/hotplug/rpaphp_pci.c:		if (!list_empty(&bus->devices)) {
drivers/pci/hotplug/rpaphp_pci.c:			list_for_each_entry (dev, &bus->devices, bus_list)
drivers/pci/hotplug/sgi_hotplug.c:		list_for_each_entry(child, &subordinate_bus->devices, bus_list)
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev, "is already active\n");
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev, "Slot %s already inactive\n", slot->physical_path);
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev, "remove successful\n");
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,"remove failed rc = %d\n", rc);
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev, "no device in slot\n");
drivers/pci/hotplug/sgi_hotplug.c:	list_for_each_entry(dev, &slot->pci_bus->devices, bus_list) {
drivers/pci/hotplug/sgi_hotplug.c:			dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&slot->pci_bus->self->dev,
drivers/pci/hotplug/sgi_hotplug.c:	list_for_each_entry_safe(dev, temp, &slot->pci_bus->devices, bus_list) {
drivers/pci/hotplug/sgi_hotplug.c:	dev_dbg(&pci_bus->self->dev, "Registered bus with hotplug\n");
drivers/pci/hotplug/sgi_hotplug.c:	dev_dbg(&pci_bus->self->dev, "bus failed to register with err = %d\n",
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&pci_bus->self->dev, "Memory allocation error\n");
drivers/pci/hotplug/sgi_hotplug.c:		if (!pci_bus->sysdata)
drivers/pci/hotplug/sgi_hotplug.c:			dev_dbg(&pci_bus->self->dev, "not a valid hotplug bus\n");
drivers/pci/hotplug/sgi_hotplug.c:		dev_dbg(&pci_bus->self->dev, "valid hotplug bus\n");
drivers/pci/hotplug/shpchp_ctrl.c:	bsp = ctrl->pci_dev->bus->cur_bus_speed;
drivers/pci/hotplug/shpchp_ctrl.c:	msp = ctrl->pci_dev->bus->max_bus_speed;
drivers/pci/hotplug/shpchp_hpc.c:	bus->cur_bus_speed = bus_speed;
drivers/pci/hotplug/shpchp_hpc.c:	bus->max_bus_speed = bus_speed;
drivers/pci/hotplug/shpchp_sysfs.c:	for (busnr = bus->busn_res.start; busnr <= bus->busn_res.end; busnr++) {
drivers/pci/hotplug/shpchp_sysfs.c:	if (busnr < bus->busn_res.end)
drivers/pci/hotplug/shpchp_sysfs.c:				busnr, (int)(bus->busn_res.end - busnr));
drivers/pci/iov.c:	return dev->bus->number + ((dev->devfn + dev->sriov->offset +
drivers/pci/iov.c:	if (bus->number == busnr)
drivers/pci/iov.c:	if (physbus != virtbus && list_empty(&virtbus->devices))
drivers/pci/iov.c:	if (virtfn_bus(dev, nr_virtfn - 1) > dev->bus->busn_res.end) {
drivers/pci/iov.c:	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
drivers/pci/iov.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/iov.c:	return max ? max - bus->number : 0;
drivers/pci/msi.c:	struct msi_chip *chip = dev->bus->msi;
drivers/pci/msi.c:	struct msi_chip *chip = dev->bus->msi;
drivers/pci/msi.c:	for (bus = dev->bus; bus; bus = bus->parent)
drivers/pci/msi.c:		if (bus->bus_flags & PCI_BUS_FLAGS_NO_MSI)
drivers/pci/of.c:	if (!dev->bus->dev.of_node)
drivers/pci/of.c:	dev->dev.of_node = of_pci_find_child_device(dev->bus->dev.of_node,
drivers/pci/of.c:	if (bus->self == NULL)
drivers/pci/of.c:		bus->dev.of_node = pcibios_get_phb_of_node(bus);
drivers/pci/of.c:		bus->dev.of_node = of_node_get(bus->self->dev.of_node);
drivers/pci/of.c:	of_node_put(bus->dev.of_node);
drivers/pci/of.c:	bus->dev.of_node = NULL;
drivers/pci/of.c:	if (WARN_ON(bus->self || bus->parent))
drivers/pci/of.c:	if (bus->bridge->of_node)
drivers/pci/of.c:		return of_node_get(bus->bridge->of_node);
drivers/pci/of.c:	if (bus->bridge->parent && bus->bridge->parent->of_node)
drivers/pci/of.c:		return of_node_get(bus->bridge->parent->of_node);
drivers/pci/pci-acpi.c:	while (bus->parent) {
drivers/pci/pci-acpi.c:		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
drivers/pci/pci-acpi.c:		bus = bus->parent;
drivers/pci/pci-acpi.c:	if (bus->bridge)
drivers/pci/pci-acpi.c:		acpi_pm_device_sleep_wake(bus->bridge, enable);
drivers/pci/pci-acpi.c:	while (bus->parent) {
drivers/pci/pci-acpi.c:		struct pci_dev *bridge = bus->self;
drivers/pci/pci-acpi.c:		bus = bus->parent;
drivers/pci/pci-acpi.c:	if (bus->bridge)
drivers/pci/pci-acpi.c:		acpi_pm_device_run_wake(bus->bridge, enable);
drivers/pci/pci-acpi.c:	if (acpi_pci_disabled || !bus->bridge)
drivers/pci/pci-acpi.c:	if (acpi_pci_disabled || !bus->bridge)
drivers/pci/pci-label.c:	bus = pdev->bus->number;
drivers/pci/pci-sysfs.c:		if (!pci_is_root_bus(bus) && list_empty(&bus->devices))
drivers/pci/pci-sysfs.c:			pci_rescan_bus_bridge_resize(bus->self);
drivers/pci/pci.c:	max = bus->busn_res.end;
drivers/pci/pci.c:	list_for_each(tmp, &bus->children) {
drivers/pci/pci.c:	if (dev->bus->self)
drivers/pci/pci.c:		pcie_aspm_pm_state_change(dev->bus->self);
drivers/pci/pci.c:	if (!error && dev->bus->self)
drivers/pci/pci.c:		pcie_aspm_powersave_config_link(dev->bus->self);
drivers/pci/pci.c: * anymore.  This only involves disabling PCI bus-mastering, if active.
drivers/pci/pci.c:				bridge = pme_dev->dev->bus->self;
drivers/pci/pci.c:	while (bus->parent) {
drivers/pci/pci.c:		struct pci_dev *bridge = bus->self;
drivers/pci/pci.c:		bus = bus->parent;
drivers/pci/pci.c:	if (bus->bridge)
drivers/pci/pci.c:		return device_run_wake(bus->bridge);
drivers/pci/pci.c:	bridge = dev->bus->self;
drivers/pci/pci.c:	if (dev->bus->self) {
drivers/pci/pci.c:		ret = pci_enable_obff(dev->bus->self, type);
drivers/pci/pci.c:	if (dev->bus->self) {
drivers/pci/pci.c:		ret = pci_enable_ltr(dev->bus->self);
drivers/pci/pci.c:		parent = pdev->bus->self;
drivers/pci/pci.c:		dev = dev->bus->self;
drivers/pci/pci.c:		dev = dev->bus->self;
drivers/pci/pci.c: * pcibios_set_master - enable PCI bus-mastering for device dev
drivers/pci/pci.c: * Enables PCI bus-mastering for the device.  This is the default
drivers/pci/pci.c: * pci_set_master - enables bus-mastering for device dev
drivers/pci/pci.c: * Enables bus-mastering on the device and calls pcibios_set_master()
drivers/pci/pci.c: * pci_clear_master - disables bus-mastering for device dev
drivers/pci/pci.c:	bus->ops->read(bus, dev->devfn, PCI_COMMAND, 4, &cmd_status_dword);
drivers/pci/pci.c:		bus->ops->write(bus, dev->devfn, PCI_COMMAND, 2, newcmd);
drivers/pci/pci.c:	if (pci_is_root_bus(dev->bus) || dev->subordinate || !dev->bus->self)
drivers/pci/pci.c:	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
drivers/pci/pci.c:	pci_reset_bridge_secondary_bus(dev->bus->self);
drivers/pci/pci.c:	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
drivers/pci/pci.c:	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
drivers/pci/pci.c:	if (!bus->self)
drivers/pci/pci.c:	pci_reset_bridge_secondary_bus(bus->self);
drivers/pci/pci.c:		if (v > o && (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_MMRBC))
drivers/pci/pci.c:		dev = dev->bus->self;
drivers/pci/pci.c:		bridge = bus->self;
drivers/pci/pci.c:		bus = bus->parent;
drivers/pci/pci.c:			bus == dev->bus->number &&
drivers/pci/pci.h:	if (dev->bus->self)
drivers/pci/pci.h:		parent_dstates = dev->bus->self->no_d1d2;
drivers/pci/pci.h:	return bus->self && bus->self->ari_enabled;
drivers/pci/pcie/aer/aer_inject.c:	return __find_aer_error((u16)domain, dev->bus->number, dev->devfn);
drivers/pci/pcie/aer/aer_inject.c:	err = __find_aer_error((u16)domain, bus->number, devfn);
drivers/pci/pcie/aer/aer_inject.c:	err = __find_aer_error((u16)domain, bus->number, devfn);
drivers/pci/pcie/aer/aer_inject.c:		if (!dev->bus->self)
drivers/pci/pcie/aer/aer_inject.c:		dev = dev->bus->self;
drivers/pci/pcie/aer/aer_inject.c:			       rpdev->bus->number, rpdev->devfn,
drivers/pci/pcie/aer/aerdrv_acpi.c:		 p->bus      == pci->bus->number &&
drivers/pci/pcie/aer/aerdrv_core.c:		if (e_info->id == ((dev->bus->number << 8) | dev->devfn))
drivers/pci/pcie/aer/aerdrv_core.c:		udev = dev->bus->self;
drivers/pci/pcie/aer/aerdrv_errprint.c:	int id = ((dev->bus->number << 8) | dev->devfn);
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	child = list_entry(linkbus->devices.next, struct pci_dev, bus_list);
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list)
drivers/pci/pcie/aspm.c:	link = endpoint->bus->self->link_state;
drivers/pci/pcie/aspm.c:	child = list_entry(linkbus->devices.next, struct pci_dev, bus_list);
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &linkbus->devices, bus_list)
drivers/pci/pcie/aspm.c:		parent = pdev->bus->parent->self->link_state;
drivers/pci/pcie/aspm.c:	    pdev->bus->self)
drivers/pci/pcie/aspm.c:		list_for_each_entry(child, &linkbus->devices, bus_list) {
drivers/pci/pcie/aspm.c:	struct pci_dev *parent = pdev->bus->self;
drivers/pci/pcie/aspm.c:	struct pci_dev *parent = pdev->bus->self;
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &bus->devices, bus_list) {
drivers/pci/pcie/pme.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pcie/pme.c:	dev = pci_dev_get(bus->self);
drivers/pci/pcie/pme.c:	if (port->devfn == devfn && port->bus->number == busnr) {
drivers/pci/pcie/pme.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/pcie/pme.c:		list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pci/probe.c:	if (pci_bus->bridge)
drivers/pci/probe.c:		put_device(pci_bus->bridge);
drivers/pci/probe.c:	bus->cur_bus_speed = pcie_link_speed[linksta & PCI_EXP_LNKSTA_CLS];
drivers/pci/probe.c:	struct pci_dev *bridge = bus->self;
drivers/pci/probe.c:		bus->max_bus_speed = agp_speed(agpstat & 8, agpstat & 7);
drivers/pci/probe.c:		bus->cur_bus_speed = agp_speed(agpstat & 8, agpcmd & 7);
drivers/pci/probe.c:		bus->max_bus_speed = max;
drivers/pci/probe.c:		bus->cur_bus_speed = pcix_bus_speed[
drivers/pci/probe.c:		bus->max_bus_speed = pcie_link_speed[linkcap & PCI_EXP_LNKCAP_SLS];
drivers/pci/probe.c:	if (!primary && (primary != bus->number) && secondary && subordinate) {
drivers/pci/probe.c:		primary = bus->number;
drivers/pci/probe.c:	    (primary != bus->number || secondary <= bus->number ||
drivers/pci/probe.c:	while (bus->parent) {
drivers/pci/probe.c:		if ((child->busn_res.end > bus->busn_res.end) ||
drivers/pci/probe.c:		    (child->number > bus->busn_res.end) ||
drivers/pci/probe.c:		    (child->number < bus->number) ||
drivers/pci/probe.c:		    (child->busn_res.end < bus->number)) {
drivers/pci/probe.c:				(bus->number > child->busn_res.end &&
drivers/pci/probe.c:				 bus->busn_res.end < child->number) ?
drivers/pci/probe.c:				bus->self->transparent ? " transparent" : "",
drivers/pci/probe.c:				dev_name(&bus->dev),
drivers/pci/probe.c:				&bus->busn_res);
drivers/pci/probe.c:		bus = bus->parent;
drivers/pci/probe.c:	dev->sysdata = dev->bus->sysdata;
drivers/pci/probe.c:	dev->dev.parent = dev->bus->bridge;
drivers/pci/probe.c:	list_for_each_entry(slot, &dev->bus->slots, list)
drivers/pci/probe.c:		     dev->bus->number, PCI_SLOT(dev->devfn),
drivers/pci/probe.c:					bus->number, PCI_SLOT(devfn),
drivers/pci/probe.c:	list_add_tail(&dev->bus_list, &bus->devices);
drivers/pci/probe.c:	struct pci_dev *parent = bus->self;
drivers/pci/probe.c: * discovered devices to the @bus->devices list.  New devices
drivers/pci/probe.c:	if (bus->self && nr)
drivers/pci/probe.c:		pcie_aspm_init_link_state(bus->self);
drivers/pci/probe.c:		    dev->bus->self)
drivers/pci/probe.c:			mps = min(mps, pcie_get_mps(dev->bus->self));
drivers/pci/probe.c:	struct pci_dev *bridge = dev->bus->self;
drivers/pci/probe.c:	if (!bus->self)
drivers/pci/probe.c:	if (!pci_is_pcie(bus->self))
drivers/pci/probe.c:		smpss = bus->self->pcie_mpss;
drivers/pci/probe.c:		pcie_find_smpss(bus->self, &smpss);
drivers/pci/probe.c:	pcie_bus_configure_set(bus->self, &smpss);
drivers/pci/probe.c:	unsigned int devfn, pass, max = bus->busn_res.start;
drivers/pci/probe.c:	dev_dbg(&bus->dev, "scanning bus\n");
drivers/pci/probe.c:	if (!bus->is_added) {
drivers/pci/probe.c:		dev_dbg(&bus->dev, "fixups for bus\n");
drivers/pci/probe.c:		bus->is_added = 1;
drivers/pci/probe.c:		list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/probe.c:	dev_dbg(&bus->dev, "bus scan returning with max=%02x\n", max);
drivers/pci/probe.c:	if      (a->bus->number < b->bus->number) return -1;
drivers/pci/probe.c:	else if (a->bus->number > b->bus->number) return  1;
drivers/pci/proc.c:			dev->bus->number,
drivers/pci/proc.c:	if (!bus->procdir) {
drivers/pci/proc.c:					bus->number);
drivers/pci/proc.c:			sprintf(name, "%02x", bus->number);
drivers/pci/proc.c:		bus->procdir = proc_mkdir(name, proc_bus_pci_dir);
drivers/pci/proc.c:		if (!bus->procdir)
drivers/pci/proc.c:	e = proc_create_data(name, S_IFREG | S_IRUGO | S_IWUSR, bus->procdir,
drivers/pci/proc.c:	proc_remove(bus->procdir);
drivers/pci/quirks.c:	if (dev->devfn == 0 && dev->bus->number == 0)
drivers/pci/quirks.c:	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) > via_vlink_dev_hi ||
drivers/pci/remove.c:	if (dev->bus->self)
drivers/pci/remove.c:	list_del(&bus->node);
drivers/pci/remove.c:	device_unregister(&bus->dev);
drivers/pci/remove.c:	 * which will update the bus->devices list and confuse the
drivers/pci/remove.c:						 &bus->devices, bus_list)
drivers/pci/remove.c:					 &bus->devices, bus_list)
drivers/pci/remove.c:	host_bridge = to_pci_host_bridge(bus->bridge);
drivers/pci/remove.c:					 &bus->devices, bus_list)
drivers/pci/remove.c:	host_bridge = to_pci_host_bridge(bus->bridge);
drivers/pci/remove.c:				 &bus->devices, bus_list)
drivers/pci/search.c:		pdev = pdev->bus->self;
drivers/pci/search.c:	if(bus->number == busnr)
drivers/pci/search.c:	list_for_each(tmp, &bus->children) {
drivers/pci/search.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/search.c:		    (dev->bus->number == bus && dev->devfn == devfn))
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:		 &bus->busn_res);
drivers/pci/setup-bus.c:	res = bus->resource[0];
drivers/pci/setup-bus.c:	res = bus->resource[1];
drivers/pci/setup-bus.c:	res = bus->resource[2];
drivers/pci/setup-bus.c:	res = bus->resource[3];
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:	res = bus->resource[0];
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:	res = bus->resource[1];
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:	res = bus->resource[2];
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:		 &bus->busn_res);
drivers/pci/setup-bus.c:	pci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:		if (bus->self->io_window_1k)
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:			dev_info(&bus->self->dev, "disabling bridge window "
drivers/pci/setup-bus.c:				 &bus->busn_res);
drivers/pci/setup-bus.c:		add_to_list(realloc_head, bus->self, b_res, size1-size0,
drivers/pci/setup-bus.c:		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
drivers/pci/setup-bus.c:				 &bus->busn_res,
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:			dev_info(&bus->self->dev, "disabling bridge window "
drivers/pci/setup-bus.c:				 &bus->busn_res);
drivers/pci/setup-bus.c:		add_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);
drivers/pci/setup-bus.c:		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
drivers/pci/setup-bus.c:				 &bus->busn_res, (unsigned long long)size1-size0);
drivers/pci/setup-bus.c:	struct pci_dev *bridge = bus->self;
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:	switch (bus->self->class >> 8) {
drivers/pci/setup-bus.c:		if (bus->self->is_hotplug_bridge) {
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:	dev = bus->self;
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:	if ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)
drivers/pci/setup-bus.c:		dev_printk(KERN_DEBUG, &bus->dev, "resource %d %pR\n", i, res);
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pci/setup-bus.c:	list_for_each_entry(child_bus, &bus->children, node){
drivers/pci/setup-bus.c:		dev_printk(KERN_DEBUG, &bus->dev,
drivers/pci/setup-bus.c:			dev_info(&bus->dev, "Some PCI device resources are unassigned, try booting with pci=realloc\n");
drivers/pci/setup-bus.c:			dev_info(&bus->dev, "Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\n");
drivers/pci/setup-bus.c:	dev_printk(KERN_DEBUG, &bus->dev,
drivers/pci/setup-bus.c:	list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pci/setup-res.c:		if (!bus->parent || !bus->self->transparent)
drivers/pci/setup-res.c:		bus = bus->parent;
drivers/pci/slot.c:				slot->bus->number);
drivers/pci/slot.c:				slot->bus->number,
drivers/pci/slot.c:	return bus_speed_read(slot->bus->max_bus_speed, buf);
drivers/pci/slot.c:	return bus_speed_read(slot->bus->cur_bus_speed, buf);
drivers/pci/slot.c:	dev_dbg(&slot->bus->dev, "dev %02x, released physical slot %s\n",
drivers/pci/slot.c:	list_for_each_entry(dev, &slot->bus->devices, bus_list)
drivers/pci/slot.c:	list_for_each_entry(tmp, &slot->bus->slots, list) {
drivers/pci/slot.c:	dev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",
drivers/pci/slot.c:		dev_err(&pci_slot->bus->dev, "Error creating sysfs link (%d)\n",
drivers/pci/xen-pcifront.c:		.bus    = bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = bus->sysdata;
drivers/pci/xen-pcifront.c:			 pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
drivers/pci/xen-pcifront.c:		.bus    = bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = bus->sysdata;
drivers/pci/xen-pcifront.c:			 pci_domain_nr(bus), bus->number,
drivers/pci/xen-pcifront.c:		.bus = dev->bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = dev->bus->sysdata;
drivers/pci/xen-pcifront.c:		.bus = dev->bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = dev->bus->sysdata;
drivers/pci/xen-pcifront.c:		.bus = dev->bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = dev->bus->sysdata;
drivers/pci/xen-pcifront.c:		.bus = dev->bus->number,
drivers/pci/xen-pcifront.c:	struct pcifront_sd *sd = dev->bus->sysdata;
drivers/pci/xen-pcifront.c:	while (!list_empty(&bus->devices)) {
drivers/pci/xen-pcifront.c:		dev = container_of(bus->devices.next, struct pci_dev,
drivers/pci/xen-pcifront.c:		kfree(bus_entry->bus->sysdata);
drivers/pci/xen-pcifront.c:		device_unregister(bus_entry->bus->bridge);
drivers/pcmcia/cardbus.c:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pcmcia/cardbus.c:	max = bus->busn_res.start;
drivers/pcmcia/cardbus.c:		list_for_each_entry(dev, &bus->devices, bus_list)
drivers/pcmcia/cardbus.c:	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list)
drivers/pcmcia/rsrc_nonstatic.c:	if (s->cb_dev->bus->number == 0)
drivers/pcmcia/rsrc_nonstatic.c:		res = s->cb_dev->bus->resource[i];
drivers/pcmcia/ti113x.h:	list_for_each_entry(dev, &bus->devices, bus_list) {
drivers/pinctrl/pinconf-generic.c:	{ "bias-bus-hold", PIN_CONFIG_BIAS_BUS_HOLD, 0 },
drivers/pnp/isapnp/proc.c:	if (!(de = bus->procdir)) {
drivers/pnp/isapnp/proc.c:		sprintf(name, "%02x", bus->number);
drivers/pnp/isapnp/proc.c:		de = bus->procdir = proc_mkdir(name, isapnp_proc_bus_dir);
drivers/pnp/pnpbios/core.c:	/* extensible set of named bus-specific parameters,
drivers/pwm/core.c:		   chip->dev->bus ? chip->dev->bus->name : "no-bus",
drivers/rpmsg/virtio_rpmsg_bus.c:/* for more info, see Documentation/ABI/testing/sysfs-bus-rpmsg */
drivers/scsi/BusLogic.c:		bus = pci_device->bus->number;
drivers/scsi/BusLogic.c:		bus = pci_device->bus->number;
drivers/scsi/BusLogic.c:		bus = pci_device->bus->number;
drivers/scsi/a2091.c:	/* FIXME perform bus-specific reset */
drivers/scsi/a3000.c:	/* FIXME perform bus-specific reset */
drivers/scsi/aacraid/commctrl.c:	pci_info.bus = dev->pdev->bus->number;
drivers/scsi/aic7xxx/aic79xx_osm.h:	return (pci->bus->number);
drivers/scsi/aic7xxx/aic7xxx_osm.h:	return (pci->bus->number);
drivers/scsi/aic7xxx_old.c:          temp_p->pci_bus = pdev->bus->number;
drivers/scsi/arcmsr/arcmsr_hba.c:	bus = pdev->bus->number;
drivers/scsi/arm/fas216.c:	/* load bus-id and timeout */
drivers/scsi/arm/fas216.c:	/* load bus-id and timeout */
drivers/scsi/bnx2fc/bnx2fc_hwi.c:					(u8)hba->pcidev->bus->number);
drivers/scsi/bnx2i/bnx2i_hwi.c:						 (u8)hba->pcidev->bus->number,
drivers/scsi/csiostor/csio_hw.h:#define CSIO_PCI_BUS(hw)		((hw)->pdev->bus->number)
drivers/scsi/dpt_i2o.c:		HbaInfo.pciBusNum =  pHba->pDev->bus->number;
drivers/scsi/eata.c:		       driver_name, dev->bus->number, dev->devfn, addr);
drivers/scsi/eata.c:		       driver_name, dev->bus->number, dev->devfn);
drivers/scsi/eata.c:			     driver_name, dev->bus->number, dev->devfn);
drivers/scsi/eata.c:			     driver_name, dev->bus->number, dev->devfn);
drivers/scsi/eata.c:		       driver_name, k, dev->bus->number, dev->devfn, addr);
drivers/scsi/esas2r/esas2r_flash.c:	n->sas_addr[6] = a->pcid->bus->number;
drivers/scsi/esas2r/esas2r_ioctl.c:		gcc->pci_addr.bus_num = a->pcid->bus->number;
drivers/scsi/esas2r/esas2r_ioctl.c:		gai->pci.bus_num = a->pcid->bus->number;
drivers/scsi/esas2r/esas2r_ioctl.c:		ioctl->data.chaninfo.pci_bus = a->pcid->bus->number;
drivers/scsi/esas2r/esas2r_log.c:				 (dev->bus ? dev->bus->name : "unknown"),
drivers/scsi/esas2r/esas2r_main.c:			   pcid->bus->number,
drivers/scsi/esas2r/esas2r_main.c:		a->pcid->bus->number, a->pcid->devfn, a->pcid->irq,
drivers/scsi/esas2r/esas2r_main.c:		ae->bus_number = a->pcid->bus->number;
drivers/scsi/esp_scsi.c:			/* We should always see exactly a bus-service
drivers/scsi/fdomain.c:	   pdev->bus->number,
drivers/scsi/gdth.c:		gdth_pcistr.pdev->bus->number,
drivers/scsi/gdth.c:    ha->brd_phys = (pdev->bus->number << 8) | (pdev->devfn & 0xf8);
drivers/scsi/gdth.c:		pdev->bus->number,
drivers/scsi/gvp11.c:	/* FIXME perform bus-specific reset */
drivers/scsi/hpsa.c: * complaining.  Doing a host- or bus-reset can't do anything good here.
drivers/scsi/hpsa.c:	pciinfo.bus = h->pdev->bus->number;
drivers/scsi/hptiop.c:		pcidev->bus->number, pcidev->devfn >> 3, pcidev->devfn & 7,
drivers/scsi/in2000.c: *          device chooses), or as a "SCSI-bus-hog".
drivers/scsi/ipr.c:		if (bus->flags & IPR_SCSI_ATTR_NO_TERM_PWR) {
drivers/scsi/ipr.c:				bus->res_addr.bus);
drivers/scsi/ipr.c:		if (bus->res_addr.bus > IPR_MAX_NUM_BUSES) {
drivers/scsi/ipr.c:				IPR_GET_PHYS_LOC(bus->res_addr));
drivers/scsi/ipr.c:		bus->extended_reset_delay = IPR_EXTENDED_RESET_DELAY;
drivers/scsi/ipr.c:		bus->bus_width = bus_attr->bus_width;
drivers/scsi/ipr.c:		bus->max_xfer_rate = cpu_to_be32(bus_attr->max_xfer_rate);
drivers/scsi/ipr.c:		bus->flags &= ~IPR_SCSI_ATTR_QAS_MASK;
drivers/scsi/ipr.c:			bus->flags |= IPR_SCSI_ATTR_ENABLE_QAS;
drivers/scsi/ipr.c:			bus->flags |= IPR_SCSI_ATTR_DISABLE_QAS;
drivers/scsi/ips.c:	bus = pci_dev->bus->number;
drivers/scsi/lpfc/lpfc_scsi.c:			phba->pcidev->bus->number,
drivers/scsi/megaraid.c:	pci_bus = pdev->bus->number;
drivers/scsi/megaraid/megaraid_mbox.c:	con_log(CL_ANN, ("bus %d:slot %d:func %d\n", pdev->bus->number,
drivers/scsi/megaraid/megaraid_mbox.c:	// Enable bus-mastering on this controller
drivers/scsi/megaraid/megaraid_mbox.c:	adapter->unique_id	= pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_bus		= adapter->pdev->bus->number;
drivers/scsi/megaraid/megaraid_sas_base.c:	       pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/scsi/megaraid/megaraid_sas_base.c:	instance->unique_id = pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/mesh.c:	switch (mdev->bus->chip->type) {
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_information.u.bits.bus = ioc->pdev->bus->number;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_information.u.bits.bus = ioc->pdev->bus->number;
drivers/scsi/mvme147.c:	/* FIXME perform bus-specific reset */
drivers/scsi/mvumi.c:	mhba->unique_id = pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/pmcraid.c:	u32 adapter_id = (pinstance->pdev->bus->number << 8) |
drivers/scsi/qla1280.c:	       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));
drivers/scsi/qla2xxx/qla_os.c:		    ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/qla4xxx/ql4_os.c:	 * As per RISC alignment requirements -- the bus-address must be a
drivers/scsi/qla4xxx/ql4_os.c:		ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/qla4xxx/ql4_os.c:		    ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/sgiwd93.c:	/* FIXME perform bus-specific reset */
drivers/scsi/stex.c:	p->bus = hba->pdev->bus->number;
drivers/scsi/stex.c:	pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &pci_bctl);
drivers/scsi/stex.c:	pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, pci_bctl);
drivers/scsi/stex.c:	pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, pci_bctl);
drivers/scsi/wd33c93.c: *          device chooses), or as a "SCSI-bus-hog".
drivers/sh/superhyway/superhyway.c:	for (bus = superhyway_channels; bus->ops; bus++)
drivers/spi/spi-fsl-dspi.c:	ret = of_property_read_u32(np, "bus-num", &bus_num);
drivers/spi/spi-fsl-dspi.c:		dev_err(&pdev->dev, "can't get bus-num\n");
drivers/spi/spi-topcliff-pch.c:	dma_dev = pci_get_bus_and_slot(data->board_dat->pdev->bus->number,
drivers/spi/spi.c:		if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
drivers/spi/spi.c:					"spi-tx-bus-width %d not supported\n",
drivers/spi/spi.c:		if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
drivers/spi/spi.c:					"spi-rx-bus-width %d not supported\n",
drivers/ssb/driver_chipcommon.c:		if (bus->bustype == SSB_BUSTYPE_SSB ||
drivers/ssb/driver_chipcommon.c:		    bus->bustype == SSB_BUSTYPE_PCMCIA)
drivers/ssb/driver_chipcommon.c:		if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/ssb/driver_chipcommon.c:			pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);
drivers/ssb/driver_chipcommon.c:	if (bus->chip_id == 0x4321) {
drivers/ssb/driver_chipcommon.c:		if (bus->chip_rev == 0)
drivers/ssb/driver_chipcommon.c:		else if (bus->chip_rev == 1)
drivers/ssb/driver_chipcommon.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon.c:	if (bus->bustype != SSB_BUSTYPE_PCI)
drivers/ssb/driver_chipcommon.c:	if (cc->dev->bus->bustype != SSB_BUSTYPE_SSB)
drivers/ssb/driver_chipcommon.c:	if (cc->dev->bus->bustype != SSB_BUSTYPE_SSB)
drivers/ssb/driver_chipcommon.c:	if (cc->dev->bus->bustype == SSB_BUSTYPE_SSB) {
drivers/ssb/driver_chipcommon.c:		if (cc->dev->bus->chip_id != 0x5365) {
drivers/ssb/driver_chipcommon.c:	if ((bus->chip_id == 0x5365) ||
drivers/ssb/driver_chipcommon.c:	if ((bus->chip_id == 0x5365) ||
drivers/ssb/driver_chipcommon.c:	    ((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))
drivers/ssb/driver_chipcommon.c:	if (bus->chip_id == 0x5350) {
drivers/ssb/driver_chipcommon.c:		cc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:	if (bus->chip_id == 0x4312) {
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:	if (bus->bustype == SSB_BUSTYPE_SSB) {
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			bus->chip_id);
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			bus->chip_id);
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			bus->chip_id);
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			bus->chip_id);
drivers/ssb/driver_chipcommon_pmu.c:	switch (bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			bus->chip_id);
drivers/ssb/driver_chipcommon_pmu.c:	switch (cc->dev->bus->chip_id) {
drivers/ssb/driver_chipcommon_pmu.c:			   cc->dev->bus->chip_id);
drivers/ssb/driver_chipcommon_sflash.c:	struct ssb_sflash *sflash = &cc->dev->bus->mipscore.sflash;
drivers/ssb/driver_gige.c:	struct ssb_gige *dev = container_of(bus->ops, struct ssb_gige, pci_ops);
drivers/ssb/driver_gige.c:	struct ssb_gige *dev = container_of(bus->ops, struct ssb_gige, pci_ops);
drivers/ssb/driver_gige.c:	if (pdev->bus->ops != &dev->pci_ops) {
drivers/ssb/driver_gige.c:	if (pdev->bus->ops != &dev->pci_ops) {
drivers/ssb/driver_gpio.c:	return !!ssb_chipco_gpio_in(&bus->chipco, 1 << gpio);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_out(&bus->chipco, 1 << gpio, value ? 1 << gpio : 0);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_outen(&bus->chipco, 1 << gpio, 0);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_outen(&bus->chipco, 1 << gpio, 1 << gpio);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_out(&bus->chipco, 1 << gpio, value ? 1 << gpio : 0);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_control(&bus->chipco, 1 << gpio, 0);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_pulldown(&bus->chipco, 1 << gpio, 0);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_pullup(&bus->chipco, 1 << gpio, 1 << gpio);
drivers/ssb/driver_gpio.c:	ssb_chipco_gpio_pullup(&bus->chipco, 1 << gpio, 0);
drivers/ssb/driver_gpio.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/driver_gpio.c:		return ssb_mips_irq(bus->chipco.dev) + 2;
drivers/ssb/driver_gpio.c:	struct gpio_chip *chip = &bus->gpio;
drivers/ssb/driver_gpio.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/driver_gpio.c:	return !!ssb_extif_gpio_in(&bus->extif, 1 << gpio);
drivers/ssb/driver_gpio.c:	ssb_extif_gpio_out(&bus->extif, 1 << gpio, value ? 1 << gpio : 0);
drivers/ssb/driver_gpio.c:	ssb_extif_gpio_outen(&bus->extif, 1 << gpio, 0);
drivers/ssb/driver_gpio.c:	ssb_extif_gpio_outen(&bus->extif, 1 << gpio, 1 << gpio);
drivers/ssb/driver_gpio.c:	ssb_extif_gpio_out(&bus->extif, 1 << gpio, value ? 1 << gpio : 0);
drivers/ssb/driver_gpio.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/driver_gpio.c:		return ssb_mips_irq(bus->extif.dev) + 2;
drivers/ssb/driver_gpio.c:	struct gpio_chip *chip = &bus->gpio;
drivers/ssb/driver_gpio.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/driver_gpio.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/driver_gpio.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/driver_gpio.c:	if (ssb_chipco_available(&bus->chipco) ||
drivers/ssb/driver_gpio.c:	    ssb_extif_available(&bus->extif)) {
drivers/ssb/driver_gpio.c:		return gpiochip_remove(&bus->gpio);
drivers/ssb/driver_mipscore.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/driver_mipscore.c:		dev = &(bus->devices[i]);
drivers/ssb/driver_mipscore.c:	struct ssb_device *mdev = bus->mipscore.dev;
drivers/ssb/driver_mipscore.c:	ipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);
drivers/ssb/driver_mipscore.c:	struct ssb_device *dev = bus->mipscore.dev;
drivers/ssb/driver_mipscore.c:	struct ssb_device *mdev = bus->mipscore.dev;
drivers/ssb/driver_mipscore.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/driver_mipscore.c:		dev = &(bus->devices[i]);
drivers/ssb/driver_mipscore.c:	if (ssb_extif_available(&bus->extif))
drivers/ssb/driver_mipscore.c:		mcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);
drivers/ssb/driver_mipscore.c:	else if (ssb_chipco_available(&bus->chipco))
drivers/ssb/driver_mipscore.c:		mcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);
drivers/ssb/driver_mipscore.c:	if (!ssb_chipco_available(&bus->chipco)) {
drivers/ssb/driver_mipscore.c:	switch (bus->chipco.capabilities & SSB_CHIPCO_CAP_FLASHT) {
drivers/ssb/driver_mipscore.c:		ssb_sflash_init(&bus->chipco);
drivers/ssb/driver_mipscore.c:		if ((ssb_read32(bus->chipco.dev, SSB_CHIPCO_FLASH_CFG)
drivers/ssb/driver_mipscore.c:	if (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU)
drivers/ssb/driver_mipscore.c:		return ssb_pmu_get_cpu_clock(&bus->chipco);
drivers/ssb/driver_mipscore.c:	if (ssb_extif_available(&bus->extif)) {
drivers/ssb/driver_mipscore.c:		ssb_extif_get_clockcontrol(&bus->extif, &pll_type, &n, &m);
drivers/ssb/driver_mipscore.c:	} else if (ssb_chipco_available(&bus->chipco)) {
drivers/ssb/driver_mipscore.c:		ssb_chipco_get_clockcpu(&bus->chipco, &pll_type, &n, &m);
drivers/ssb/driver_mipscore.c:	if ((pll_type == SSB_PLLTYPE_5) || (bus->chip_id == 0x5365)) {
drivers/ssb/driver_mipscore.c:	if (ssb_extif_available(&bus->extif))
drivers/ssb/driver_mipscore.c:		ssb_extif_timing_init(&bus->extif, ns);
drivers/ssb/driver_mipscore.c:	else if (ssb_chipco_available(&bus->chipco))
drivers/ssb/driver_mipscore.c:		ssb_chipco_timing_init(&bus->chipco, ns);
drivers/ssb/driver_mipscore.c:	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
drivers/ssb/driver_mipscore.c:		dev = &(bus->devices[i]);
drivers/ssb/driver_mipscore.c:			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
drivers/ssb/driver_pcicore.c:	err = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),
drivers/ssb/driver_pcicore.c:	err = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),
drivers/ssb/driver_pcicore.c:	if (d->bus->ops != &ssb_pcicore_pciops) {
drivers/ssb/driver_pcicore.c:	if (dev->bus->ops != &ssb_pcicore_pciops) {
drivers/ssb/driver_pcicore.c:	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)
drivers/ssb/driver_pcicore.c:	if (dev->bus->ops != &ssb_pcicore_pciops) {
drivers/ssb/driver_pcicore.c:	if (pc->dev->bus->has_cardbus_slot) {
drivers/ssb/driver_pcicore.c:	chipid_top = (bus->chip_id & 0xFF00);
drivers/ssb/driver_pcicore.c:	if (bus->sprom.boardflags_lo & SSB_PCICORE_BFL_NOPCI)
drivers/ssb/driver_pcicore.c:	if (bus->chip_id == 0x4712) {
drivers/ssb/driver_pcicore.c:		if (bus->chip_package == SSB_CHIPPACK_BCM4712S)
drivers/ssb/driver_pcicore.c:		if (bus->chip_package == SSB_CHIPPACK_BCM4712M)
drivers/ssb/driver_pcicore.c:	if (bus->chip_id == 0x5350)
drivers/ssb/driver_pcicore.c:	return !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
drivers/ssb/driver_pcicore.c:	if (bus->bustype == SSB_BUSTYPE_PCI)
drivers/ssb/driver_pcicore.c:	if (dev->bus->bustype != SSB_BUSTYPE_PCI) {
drivers/ssb/driver_pcicore.c:		SSB_WARN_ON(bus->bustype != SSB_BUSTYPE_PCI);
drivers/ssb/driver_pcicore.c:		err = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);
drivers/ssb/driver_pcicore.c:		err = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco)) {
drivers/ssb/embedded.c:		ssb_chipco_watchdog_timer_set(&bus->chipco, ticks);
drivers/ssb/embedded.c:	if (ssb_extif_available(&bus->extif)) {
drivers/ssb/embedded.c:		ssb_extif_watchdog_timer_set(&bus->extif, ticks);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco)) {
drivers/ssb/embedded.c:		wdt.driver_data = &bus->chipco;
drivers/ssb/embedded.c:		wdt.max_timer_ms = bus->chipco.max_timer_ms;
drivers/ssb/embedded.c:	} else if (ssb_extif_available(&bus->extif)) {
drivers/ssb/embedded.c:		wdt.driver_data = &bus->extif;
drivers/ssb/embedded.c:					     bus->busnumber, &wdt,
drivers/ssb/embedded.c:	bus->watchdog = pdev;
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_in(&bus->chipco, mask);
drivers/ssb/embedded.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/embedded.c:		res = ssb_extif_gpio_in(&bus->extif, mask);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_out(&bus->chipco, mask, value);
drivers/ssb/embedded.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/embedded.c:		res = ssb_extif_gpio_out(&bus->extif, mask, value);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_outen(&bus->chipco, mask, value);
drivers/ssb/embedded.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/embedded.c:		res = ssb_extif_gpio_outen(&bus->extif, mask, value);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_control(&bus->chipco, mask, value);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_intmask(&bus->chipco, mask, value);
drivers/ssb/embedded.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/embedded.c:		res = ssb_extif_gpio_intmask(&bus->extif, mask, value);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	spin_lock_irqsave(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	if (ssb_chipco_available(&bus->chipco))
drivers/ssb/embedded.c:		res = ssb_chipco_gpio_polarity(&bus->chipco, mask, value);
drivers/ssb/embedded.c:	else if (ssb_extif_available(&bus->extif))
drivers/ssb/embedded.c:		res = ssb_extif_gpio_polarity(&bus->extif, mask, value);
drivers/ssb/embedded.c:	spin_unlock_irqrestore(&bus->gpio_lock, flags);
drivers/ssb/embedded.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/embedded.c:		dev = &(bus->devices[i]);
drivers/ssb/embedded.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/embedded.c:		dev = &(bus->devices[i]);
drivers/ssb/main.c:		if (bus->bustype == SSB_BUSTYPE_PCI &&
drivers/ssb/main.c:		    bus->host_pci == pdev)
drivers/ssb/main.c:		if (bus->bustype == SSB_BUSTYPE_PCMCIA &&
drivers/ssb/main.c:		    bus->host_pcmcia == pdev)
drivers/ssb/main.c:		if (bus->bustype == SSB_BUSTYPE_SDIO &&
drivers/ssb/main.c:		    bus->host_sdio == func)
drivers/ssb/main.c:	bus->mapped_device = NULL;
drivers/ssb/main.c:	bus->pcicore.setup_done = 0;
drivers/ssb/main.c:	ssb_chipco_resume(&bus->chipco);
drivers/ssb/main.c:	ssb_chipco_suspend(&bus->chipco);
drivers/ssb/main.c:	SSB_WARN_ON(bus->nr_devices > ARRAY_SIZE(ctx->device_frozen));
drivers/ssb/main.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/main.c:		sdev = ssb_device_get(&bus->devices[i]);
drivers/ssb/main.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/main.c:		sdev = &bus->devices[i];
drivers/ssb/main.c:	for (i = bus->nr_devices - 1; i >= 0; i--) {
drivers/ssb/main.c:		sdev = &(bus->devices[i]);
drivers/ssb/main.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/main.c:		platform_device_unregister(bus->watchdog);
drivers/ssb/main.c:	list_del(&bus->list);
drivers/ssb/main.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/main.c:		sdev = &(bus->devices[i]);
drivers/ssb/main.c:		dev_set_name(dev, "ssb%u:%d", bus->busnumber, dev_idx);
drivers/ssb/main.c:		switch (bus->bustype) {
drivers/ssb/main.c:			sdev->irq = bus->host_pci->irq;
drivers/ssb/main.c:			dev->parent = &bus->host_pci->dev;
drivers/ssb/main.c:			sdev->irq = bus->host_pcmcia->irq;
drivers/ssb/main.c:			dev->parent = &bus->host_pcmcia->dev;
drivers/ssb/main.c:			dev->parent = &bus->host_sdio->dev;
drivers/ssb/main.c:	if (bus->mipscore.pflash.present) {
drivers/ssb/main.c:	if (bus->mipscore.sflash.present) {
drivers/ssb/main.c:			list_del(&bus->list);
drivers/ssb/main.c:		ssb_pcicore_init(&bus->pcicore);
drivers/ssb/main.c:		if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/main.c:			list_del(&bus->list);
drivers/ssb/main.c:		list_move_tail(&bus->list, &buses);
drivers/ssb/main.c:	return readb(bus->mmio + offset);
drivers/ssb/main.c:	return readw(bus->mmio + offset);
drivers/ssb/main.c:	return readl(bus->mmio + offset);
drivers/ssb/main.c:	addr = bus->mmio + offset;
drivers/ssb/main.c:	writeb(value, bus->mmio + offset);
drivers/ssb/main.c:	writew(value, bus->mmio + offset);
drivers/ssb/main.c:	writel(value, bus->mmio + offset);
drivers/ssb/main.c:	addr = bus->mmio + offset;
drivers/ssb/main.c:	memcpy(&bus->boardinfo, &iv.boardinfo, sizeof(iv.boardinfo));
drivers/ssb/main.c:	memcpy(&bus->sprom, &iv.sprom, sizeof(iv.sprom));
drivers/ssb/main.c:	bus->has_cardbus_slot = iv.has_cardbus_slot;
drivers/ssb/main.c:	spin_lock_init(&bus->bar_lock);
drivers/ssb/main.c:	INIT_LIST_HEAD(&bus->list);
drivers/ssb/main.c:	spin_lock_init(&bus->gpio_lock);
drivers/ssb/main.c:	bus->busnumber = next_busnumber;
drivers/ssb/main.c:	ssb_chipcommon_init(&bus->chipco);
drivers/ssb/main.c:	ssb_extif_init(&bus->extif);
drivers/ssb/main.c:	ssb_mipscore_init(&bus->mipscore);
drivers/ssb/main.c:	list_add_tail(&bus->list, &attach_queue);
drivers/ssb/main.c:	list_del(&bus->list);
drivers/ssb/main.c:	bus->bustype = SSB_BUSTYPE_PCI;
drivers/ssb/main.c:	bus->host_pci = host_pci;
drivers/ssb/main.c:	bus->ops = &ssb_pci_ops;
drivers/ssb/main.c:	bus->bustype = SSB_BUSTYPE_PCMCIA;
drivers/ssb/main.c:	bus->host_pcmcia = pcmcia_dev;
drivers/ssb/main.c:	bus->ops = &ssb_pcmcia_ops;
drivers/ssb/main.c:	bus->bustype = SSB_BUSTYPE_SDIO;
drivers/ssb/main.c:	bus->host_sdio = func;
drivers/ssb/main.c:	bus->ops = &ssb_sdio_ops;
drivers/ssb/main.c:	bus->quirks = quirks;
drivers/ssb/main.c:	bus->bustype = SSB_BUSTYPE_SSB;
drivers/ssb/main.c:	bus->ops = &ssb_ssb_ops;
drivers/ssb/main.c:	for (i = 0; i < bus->nr_devices; i++) {
drivers/ssb/main.c:		ent = &(bus->devices[i]);
drivers/ssb/main.c:	if (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU)
drivers/ssb/main.c:		return ssb_pmu_get_controlclock(&bus->chipco);
drivers/ssb/main.c:	if (ssb_extif_available(&bus->extif))
drivers/ssb/main.c:		ssb_extif_get_clockcontrol(&bus->extif, &plltype,
drivers/ssb/main.c:	else if (bus->chipco.dev)
drivers/ssb/main.c:		ssb_chipco_get_clockcontrol(&bus->chipco, &plltype,
drivers/ssb/main.c:	if (bus->chip_id == 0x5365) {
drivers/ssb/main.c:	u16 chip_id = dev->bus->chip_id;
drivers/ssb/main.c:	switch (dev->bus->bustype) {
drivers/ssb/main.c:		if (pci_is_pcie(dev->bus->host_pci) &&
drivers/ssb/main.c:	if (bus->bustype == SSB_BUSTYPE_SSB)
drivers/ssb/main.c:	cc = &bus->chipco;
drivers/ssb/main.c:	bus->powered_up = 0;
drivers/ssb/main.c:	bus->powered_up = 1;
drivers/ssb/main.c:	ssb_chipco_set_clockmode(&bus->chipco, mode);
drivers/ssb/main.c:	dev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;
drivers/ssb/main.c:	dev = bus->chipco.dev;
drivers/ssb/pci.c:		err = pci_write_config_dword(bus->host_pci, SSB_BAR0_WIN,
drivers/ssb/pci.c:		err = pci_read_config_dword(bus->host_pci, SSB_BAR0_WIN,
drivers/ssb/pci.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pci.c:		bus->mapped_device = dev;
drivers/ssb/pci.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pci.c:	if (bus->bustype != SSB_BUSTYPE_PCI)
drivers/ssb/pci.c:	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_IN, &in);
drivers/ssb/pci.c:	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &out);
drivers/ssb/pci.c:	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, &outenable);
drivers/ssb/pci.c:				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
drivers/ssb/pci.c:				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE,
drivers/ssb/pci.c:				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
drivers/ssb/pci.c:		err = pci_read_config_word(bus->host_pci, PCI_STATUS, &pci_status);
drivers/ssb/pci.c:		err = pci_write_config_word(bus->host_pci, PCI_STATUS, pci_status);
drivers/ssb/pci.c:		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
drivers/ssb/pci.c:		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, outenable);
drivers/ssb/pci.c:	for (i = 0; i < bus->sprom_size; i++)
drivers/ssb/pci.c:		sprom[i] = ioread16(bus->mmio + bus->sprom_offset + (i * 2));
drivers/ssb/pci.c:	struct pci_dev *pdev = bus->host_pci;
drivers/ssb/pci.c:	u16 size = bus->sprom_size;
drivers/ssb/pci.c:		writew(sprom[i], bus->mmio + bus->sprom_offset + (i * 2));
drivers/ssb/pci.c:	if ((bus->chip_id & 0xFF00) == 0x4400) {
drivers/ssb/pci.c:	if (bus->chipco.dev) {	/* can be unavailable! */
drivers/ssb/pci.c:		if (bus->chipco.dev->id.revision >= 31)
drivers/ssb/pci.c:			bus->sprom_offset = SSB_SPROM_BASE31;
drivers/ssb/pci.c:		else if (bus->chip_id == 0x4312 &&
drivers/ssb/pci.c:			 (bus->chipco.status & 0x03) == 2)
drivers/ssb/pci.c:			bus->sprom_offset = SSB_SPROM_BASE31;
drivers/ssb/pci.c:			bus->sprom_offset = SSB_SPROM_BASE1;
drivers/ssb/pci.c:		bus->sprom_offset = SSB_SPROM_BASE1;
drivers/ssb/pci.c:	ssb_dbg("SPROM offset is 0x%x\n", bus->sprom_offset);
drivers/ssb/pci.c:	bus->sprom_size = SSB_SPROMSIZE_WORDS_R123;
drivers/ssb/pci.c:	err = sprom_check_crc(buf, bus->sprom_size);
drivers/ssb/pci.c:		bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
drivers/ssb/pci.c:		err = sprom_check_crc(buf, bus->sprom_size);
drivers/ssb/pci.c:	err = sprom_extract(bus, sprom, buf, bus->sprom_size);
drivers/ssb/pci.c:	bi->vendor = bus->host_pci->subsystem_vendor;
drivers/ssb/pci.c:	bi->type = bus->host_pci->subsystem_device;
drivers/ssb/pci.c:	if (likely(bus->powered_up))
drivers/ssb/pci.c:	if (bus->power_warn_count <= 10) {
drivers/ssb/pci.c:		bus->power_warn_count++;
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	return ioread8(bus->mmio + offset);
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	return ioread16(bus->mmio + offset);
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	return ioread32(bus->mmio + offset);
drivers/ssb/pci.c:	void __iomem *addr = bus->mmio + offset;
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	iowrite8(value, bus->mmio + offset);
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	iowrite16(value, bus->mmio + offset);
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	iowrite32(value, bus->mmio + offset);
drivers/ssb/pci.c:	void __iomem *addr = bus->mmio + offset;
drivers/ssb/pci.c:	if (unlikely(bus->mapped_device != dev)) {
drivers/ssb/pci.c:	if (bus->bustype != SSB_BUSTYPE_PCI)
drivers/ssb/pci.c:	pdev = bus->host_pci;
drivers/ssb/pci.c:	if (bus->bustype != SSB_BUSTYPE_PCI)
drivers/ssb/pci.c:	pdev = bus->host_pci;
drivers/ssb/pci.c:	mutex_init(&bus->sprom_mutex);
drivers/ssb/pcmcia.c:	res = pcmcia_write_config_byte(bus->host_pcmcia, offset, value);
drivers/ssb/pcmcia.c:	res = pcmcia_read_config_byte(bus->host_pcmcia, offset, value);
drivers/ssb/pcmcia.c:		bus->mapped_device = dev;
drivers/ssb/pcmcia.c:	bus->mapped_pcmcia_seg = seg;
drivers/ssb/pcmcia.c:	if (unlikely(dev != bus->mapped_device)) {
drivers/ssb/pcmcia.c:	if (unlikely(need_segment != bus->mapped_pcmcia_seg)) {
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		value = readb(bus->mmio + offset);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		value = readw(bus->mmio + offset);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		lo = readw(bus->mmio + offset);
drivers/ssb/pcmcia.c:		hi = readw(bus->mmio + offset + 2);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	void __iomem *addr = bus->mmio + offset;
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		writeb(value, bus->mmio + offset);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		writew(value, bus->mmio + offset);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:		writew((value & 0x0000FFFF), bus->mmio + offset);
drivers/ssb/pcmcia.c:		writew(((value & 0xFFFF0000) >> 16), bus->mmio + offset + 2);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	void __iomem *addr = bus->mmio + offset;
drivers/ssb/pcmcia.c:	spin_lock_irqsave(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	spin_unlock_irqrestore(&bus->bar_lock, flags);
drivers/ssb/pcmcia.c:	res = pcmcia_loop_tuple(bus->host_pcmcia, CISTPL_FUNCE,
drivers/ssb/pcmcia.c:	res = pcmcia_loop_tuple(bus->host_pcmcia, SSB_PCMCIA_CIS,
drivers/ssb/pcmcia.c:	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
drivers/ssb/pcmcia.c:	 * bus->mapped_pcmcia_seg with hardware state. */
drivers/ssb/pcmcia.c:	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
drivers/ssb/pcmcia.c:	device_remove_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);
drivers/ssb/pcmcia.c:	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
drivers/ssb/pcmcia.c:	bus->sprom_size = SSB_PCMCIA_SPROM_SIZE;
drivers/ssb/pcmcia.c:	mutex_init(&bus->sprom_mutex);
drivers/ssb/pcmcia.c:	err = device_create_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);
drivers/ssb/scan.c:	switch (bus->bustype) {
drivers/ssb/scan.c:		lo = readw(bus->mmio + offset);
drivers/ssb/scan.c:		hi = readw(bus->mmio + offset + 2);
drivers/ssb/scan.c:	return readl(bus->mmio + offset);
drivers/ssb/scan.c:	switch (bus->bustype) {
drivers/ssb/scan.c:	switch (bus->bustype) {
drivers/ssb/scan.c:		iounmap(bus->mmio);
drivers/ssb/scan.c:		pci_iounmap(bus->host_pci, bus->mmio);
drivers/ssb/scan.c:	bus->mmio = NULL;
drivers/ssb/scan.c:	bus->mapped_device = NULL;
drivers/ssb/scan.c:	switch (bus->bustype) {
drivers/ssb/scan.c:		mmio = pci_iomap(bus->host_pci, 0, ~0UL);
drivers/ssb/scan.c:	if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/ssb/scan.c:		if (bus->host_pci->vendor == PCI_VENDOR_ID_BROADCOM &&
drivers/ssb/scan.c:		    ((bus->host_pci->device == 0x4313) ||
drivers/ssb/scan.c:		     (bus->host_pci->device == 0x431A) ||
drivers/ssb/scan.c:		     (bus->host_pci->device == 0x4321) ||
drivers/ssb/scan.c:		     (bus->host_pci->device == 0x4324)))
drivers/ssb/scan.c:	bus->mmio = mmio;
drivers/ssb/scan.c:	bus->nr_devices = 0;
drivers/ssb/scan.c:		bus->chip_id = (tmp & SSB_CHIPCO_IDMASK);
drivers/ssb/scan.c:		bus->chip_rev = (tmp & SSB_CHIPCO_REVMASK) >>
drivers/ssb/scan.c:		bus->chip_package = (tmp & SSB_CHIPCO_PACKMASK) >>
drivers/ssb/scan.c:			bus->nr_devices = (tmp & SSB_CHIPCO_NRCORESMASK) >>
drivers/ssb/scan.c:		bus->chipco.capabilities = tmp;
drivers/ssb/scan.c:		if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/ssb/scan.c:			bus->chip_id = pcidev_to_chipid(bus->host_pci);
drivers/ssb/scan.c:			bus->chip_rev = bus->host_pci->revision;
drivers/ssb/scan.c:			bus->chip_package = 0;
drivers/ssb/scan.c:			bus->chip_id = 0x4710;
drivers/ssb/scan.c:			bus->chip_rev = 0;
drivers/ssb/scan.c:			bus->chip_package = 0;
drivers/ssb/scan.c:		 bus->chip_id, bus->chip_rev, bus->chip_package);
drivers/ssb/scan.c:	if (!bus->nr_devices)
drivers/ssb/scan.c:		bus->nr_devices = chipid_to_nrcores(bus->chip_id);
drivers/ssb/scan.c:	if (bus->nr_devices > ARRAY_SIZE(bus->devices)) {
drivers/ssb/scan.c:			SSB_MAX_NR_CORES, bus->nr_devices);
drivers/ssb/scan.c:	if (bus->bustype == SSB_BUSTYPE_SSB) {
drivers/ssb/scan.c:		mmio = ioremap(baseaddr, SSB_CORE_SIZE * bus->nr_devices);
drivers/ssb/scan.c:		bus->mmio = mmio;
drivers/ssb/scan.c:	for (i = 0, dev_i = 0; i < bus->nr_devices; i++) {
drivers/ssb/scan.c:		dev = &(bus->devices[dev_i]);
drivers/ssb/scan.c:		dev->ops = bus->ops;
drivers/ssb/scan.c:			if (bus->extif.dev) {
drivers/ssb/scan.c:			bus->extif.dev = dev;
drivers/ssb/scan.c:			if (bus->chipco.dev) {
drivers/ssb/scan.c:			bus->chipco.dev = dev;
drivers/ssb/scan.c:			if (bus->mipscore.dev) {
drivers/ssb/scan.c:			bus->mipscore.dev = dev;
drivers/ssb/scan.c:			if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/ssb/scan.c:					if (pci_is_pcie(bus->host_pci))
drivers/ssb/scan.c:					if (!pci_is_pcie(bus->host_pci))
drivers/ssb/scan.c:			if (bus->pcicore.dev) {
drivers/ssb/scan.c:			bus->pcicore.dev = dev;
drivers/ssb/scan.c:			if (bus->bustype == SSB_BUSTYPE_PCI) {
drivers/ssb/scan.c:				if (bus->host_pci->vendor == PCI_VENDOR_ID_BROADCOM &&
drivers/ssb/scan.c:				    (bus->host_pci->device & 0xFF00) == 0x4300) {
drivers/ssb/scan.c:	bus->nr_devices = dev_i;
drivers/ssb/sdio.c:	return &bus->host_sdio->dev;
drivers/ssb/sdio.c:	sdio_writeb(bus->host_sdio, val, addr, &error);
drivers/ssb/sdio.c:	val = sdio_readb(bus->host_sdio, addr, &error);
drivers/ssb/sdio.c:	bus->sdio_sbaddr = address;
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	val = sdio_readl(bus->host_sdio, offset, &error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	if (unlikely(bus->sdio_sbaddr != sbaddr)) {
drivers/ssb/sdio.c:		bus->mapped_device = dev;
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	val = sdio_readb(bus->host_sdio, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	val = sdio_readw(bus->host_sdio, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	val = sdio_readl(bus->host_sdio, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:		error = sdio_readsb(bus->host_sdio, buffer, offset, count);
drivers/ssb/sdio.c:		error = sdio_readsb(bus->host_sdio, buffer, offset, count);
drivers/ssb/sdio.c:		error = sdio_readsb(bus->host_sdio, buffer, offset, count);
drivers/ssb/sdio.c:		bus->sdio_sbaddr >> 16, offset, reg_width, saved_count, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	sdio_writeb(bus->host_sdio, val, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	sdio_writew(bus->host_sdio, val, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:	sdio_writel(bus->host_sdio, val, offset, &error);
drivers/ssb/sdio.c:			bus->sdio_sbaddr >> 16, offset, val, error);
drivers/ssb/sdio.c:	if (bus->quirks & SSB_QUIRK_SDIO_READ_AFTER_WRITE32)
drivers/ssb/sdio.c:		sdio_readl(bus->host_sdio, 0, &error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	sdio_claim_host(bus->host_sdio);
drivers/ssb/sdio.c:	offset |= bus->sdio_sbaddr & 0xffff;
drivers/ssb/sdio.c:		error = sdio_writesb(bus->host_sdio, offset,
drivers/ssb/sdio.c:		error = sdio_writesb(bus->host_sdio, offset,
drivers/ssb/sdio.c:		error = sdio_writesb(bus->host_sdio, offset,
drivers/ssb/sdio.c:		bus->sdio_sbaddr >> 16, offset, reg_width, saved_count, error);
drivers/ssb/sdio.c:	sdio_release_host(bus->host_sdio);
drivers/ssb/sdio.c:	tuple = bus->host_sdio->tuples;
drivers/ssb/sdio.c:	if (bus->bustype != SSB_BUSTYPE_SDIO)
drivers/ssb/sdio.c:	if (bus->bustype != SSB_BUSTYPE_SDIO)
drivers/ssb/sdio.c:	bus->sdio_sbaddr = ~0;
drivers/ssb/sprom.c:	size_t sprom_size_words = bus->sprom_size;
drivers/ssb/sprom.c:	if (mutex_lock_interruptible(&bus->sprom_mutex))
drivers/ssb/sprom.c:	mutex_unlock(&bus->sprom_mutex);
drivers/ssb/sprom.c:	size_t sprom_size_words = bus->sprom_size;
drivers/ssb/sprom.c:	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
drivers/ssb/sprom.c:	if (mutex_lock_interruptible(&bus->sprom_mutex))
drivers/ssb/sprom.c:	mutex_unlock(&bus->sprom_mutex);
drivers/ssb/sprom.c:	if (bus->bustype == SSB_BUSTYPE_PCI &&
drivers/ssb/sprom.c:	    bus->chipco.dev &&	/* can be unavailable! */
drivers/ssb/sprom.c:	    bus->chipco.dev->id.revision >= 31)
drivers/ssb/sprom.c:		return bus->chipco.capabilities & SSB_CHIPCO_CAP_SPROM;
drivers/staging/bcm/Bcmnet.c:			 net->name, xdev->bus->bus_name, xdev->devpath,
drivers/staging/bcm/Bcmnet.c:			 net->name, xdev->bus->bus_name, xdev->devpath);
drivers/staging/comedi/drivers/adl_pci9118.c:			if (pcidev->bus->number != bus ||
drivers/staging/comedi/drivers/amplc_pc236.c:			if (bus != pci_dev->bus->number ||
drivers/staging/comedi/drivers/amplc_pci224.c:			if (bus != pci_dev->bus->number ||
drivers/staging/comedi/drivers/amplc_pci230.c:		    (bus != pci_dev->bus->number ||
drivers/staging/comedi/drivers/dt3000.c:   bus-mastering DMA, which eliminates them from serious work.
drivers/staging/crystalhd/crystalhd_lnx.c:		 pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/staging/cxt1e1/hwprobe.c:        busno = pdev->bus->number;
drivers/staging/cxt1e1/hwprobe.c:        hi->pci_busno = pdev->bus->number;
drivers/staging/dgap/dgap_driver.c:	brd->pci_bus = pdev->bus->number;
drivers/staging/dgnc/dgnc_driver.c:	brd->pci_bus = pdev->bus->number;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_allocated += bw / urb->interval;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_isoc_reqs++;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_int_reqs++;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_allocated -= bw / urb->interval;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_isoc_reqs--;
drivers/staging/dwc2/hcd.c:		bus->bandwidth_int_reqs--;
drivers/staging/dwc2/hcd.c:	if (bus->root_hub) {
drivers/staging/et131x/et131x.c:	struct net_device *netdev = bus->priv;
drivers/staging/et131x/et131x.c:	struct net_device *netdev = bus->priv;
drivers/staging/et131x/et131x.c:	struct net_device *netdev = bus->priv;
drivers/staging/et131x/et131x.c:	kfree(adapter->mii_bus->irq);
drivers/staging/et131x/et131x.c:	/* Map the bus-relative registers to system virtual memory */
drivers/staging/et131x/et131x.c:	adapter->mii_bus->name = "et131x_eth_mii";
drivers/staging/et131x/et131x.c:	snprintf(adapter->mii_bus->id, MII_BUS_ID_SIZE, "%x",
drivers/staging/et131x/et131x.c:		(adapter->pdev->bus->number << 8) | adapter->pdev->devfn);
drivers/staging/et131x/et131x.c:	adapter->mii_bus->priv = netdev;
drivers/staging/et131x/et131x.c:	adapter->mii_bus->read = et131x_mdio_read;
drivers/staging/et131x/et131x.c:	adapter->mii_bus->write = et131x_mdio_write;
drivers/staging/et131x/et131x.c:	adapter->mii_bus->reset = et131x_mdio_reset;
drivers/staging/et131x/et131x.c:	adapter->mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int),
drivers/staging/et131x/et131x.c:	if (!adapter->mii_bus->irq)
drivers/staging/et131x/et131x.c:		adapter->mii_bus->irq[ii] = PHY_POLL;
drivers/staging/et131x/et131x.c:	kfree(adapter->mii_bus->irq);
drivers/staging/iio/Documentation/overview.txt:sysfs-bus-iio - abi documentation file.
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	switch (mbus->code) {
drivers/staging/media/lirc/lirc_igorplugusb.c:	       dev->bus->busnum, devnum);
drivers/staging/media/lirc/lirc_imon.c:		 usbdev->bus->busnum, usbdev->devnum);
drivers/staging/media/lirc/lirc_sasem.c:		 __func__, dev->bus->busnum, dev->devnum);
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct xlr_net_priv *priv = bus->priv;
drivers/staging/netlogic/xlr_net.c:	struct xlr_net_priv *priv = bus->priv;
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	struct phy_device *phydev = priv->mii_bus->phy_map[priv->phy_addr];
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->priv = priv;
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->name = "xlr-mdio";
drivers/staging/netlogic/xlr_net.c:	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%d",
drivers/staging/netlogic/xlr_net.c:			priv->mii_bus->name, priv->port_id);
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->read = xlr_mii_read;
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->write = xlr_mii_write;
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->parent = &pdev->dev;
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->irq[priv->phy_addr] = priv->ndev->irq;
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->phy_mask = ~(1 << priv->phy_addr);
drivers/staging/netlogic/xlr_net.c:	pr_info("Registered mdio bus id : %s\n", priv->mii_bus->id);
drivers/staging/octeon/ethernet-rgmii.c:		mutex_lock(&priv->phydev->bus->mdio_lock);
drivers/staging/octeon/ethernet-rgmii.c:			mutex_unlock(&priv->phydev->bus->mdio_lock);
drivers/staging/octeon/ethernet-rgmii.c:		mutex_unlock(&priv->phydev->bus->mdio_lock);
drivers/staging/silicom/bpctl_mod.c:	dev->bus = pdev1->bus->number;
drivers/staging/slicoss/slicoss.c:	adapter->busnumber = pcidev->bus->number;
drivers/staging/usbip/stub_dev.c:	if (!strcmp(udev->bus->bus_name, "vhci_hcd")) {
drivers/staging/usbip/stub_dev.c:			udev->bus->busnum, udev->devnum,
drivers/staging/usbip/stub_dev.c:		udev->bus->busnum, udev->devnum,
drivers/staging/usbip/usbip_common.h:	return udev->bus->busnum;
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->pcibus = pdev->bus->number;
drivers/staging/xillybus/xillybus_of.c:	{ .compatible = "xlnx,xillybus-1.00.a", },
drivers/tc/tc.c:	resource_size_t slotsize = tbus->info.slot_size << 20;
drivers/tc/tc.c:	resource_size_t extslotsize = tbus->ext_slot_size;
drivers/tc/tc.c:	for (slot = 0; slot < tbus->num_tcslots; slot++) {
drivers/tc/tc.c:		slotaddr = tbus->slot_base + slot * slotsize;
drivers/tc/tc.c:		extslotaddr = tbus->ext_slot_base + slot * extslotsize;
drivers/tc/tc.c:		tdev->dev.parent = &tbus->dev;
drivers/tc/tc.c:		list_add_tail(&tdev->node, &tbus->devices);
drivers/tty/mxser.c:		pdev->bus->number, PCI_SLOT(pdev->devfn));
drivers/tty/serial/8250/8250_pnp.c: *     - dev->name or dev->bus->name must contain "modem" substring;
drivers/tty/serial/ioc3_serial.c:		the_port->iobase = (pdev->bus->number << 16) |  ii;
drivers/tty/serial/ioc3_serial.c:			       __func__, the_port->line, pdev->bus->number);
drivers/tty/serial/ioc3_serial.c:		          the_port->line, the_port->irq, pdev->bus->number));
drivers/tty/serial/ioc4_serial.c:		the_port->iobase = (pdev->bus->number << 16) |  port_num;
drivers/tty/serial/ioc4_serial.c:			       __func__, the_port->line, pdev->bus->number);
drivers/tty/serial/ioc4_serial.c:			       the_port->line, the_port->irq, pdev->bus->number));
drivers/tty/serial/pch_uart.c:	dma_dev = pci_get_bus_and_slot(priv->pdev->bus->number,
drivers/tty/serial/ucc_uart.c:		iprop = of_get_property(np, "bus-frequency", NULL);
drivers/tty/serial/ucc_uart.c:				"missing QE bus-frequency in device tree\n");
drivers/tty/serial/ucc_uart.c:				"invalid QE bus-frequency in device tree\n");
drivers/usb/chipidea/ci_hdrc_imx.c:	if (of_find_property(np, "external-vbus-divider", NULL))
drivers/usb/class/usblp.c:			twoints[0] = usblp->dev->bus->busnum;
drivers/usb/core/buffer.c:	if (!bus->controller->dma_mask &&
drivers/usb/core/buffer.c:	if (!bus->controller->dma_mask &&
drivers/usb/core/devices.c:			bus->busnum, level, parent_devnum,
drivers/usb/core/devices.c:				bus->bandwidth_allocated, max,
drivers/usb/core/devices.c:				(100 * bus->bandwidth_allocated + max / 2)
drivers/usb/core/devices.c:				bus->bandwidth_int_reqs,
drivers/usb/core/devices.c:				bus->bandwidth_isoc_reqs);
drivers/usb/core/devices.c:		usb_lock_device(bus->root_hub);
drivers/usb/core/devices.c:				      bus->root_hub, bus, 0, 0, 0);
drivers/usb/core/devices.c:		usb_unlock_device(bus->root_hub);
drivers/usb/core/devio.c:		if (num_sgs == 1 || num_sgs > ps->dev->bus->sg_tablesize)
drivers/usb/core/devio.c:	if (!ps->dev->bus->no_stop_on_short)
drivers/usb/core/devio.c:	if (ps->dev->bus->sg_tablesize)
drivers/usb/core/driver.c:	if (!PMSG_IS_AUTO(msg) && udev->parent && udev->bus->hs_companion)
drivers/usb/core/driver.c:				&udev->bus->hs_companion->root_hub->dev);
drivers/usb/core/generic.c:		 * HP's USB bus-powered keyboard has only one configuration
drivers/usb/core/generic.c:		/* Rule out self-powered configs for a bus-powered device */
drivers/usb/core/generic.c:		 * to be self-powered when they are really bus-powered.
drivers/usb/core/hcd.c:	memset (&bus->devmap, 0, sizeof(struct usb_devmap));
drivers/usb/core/hcd.c:	bus->devnum_next = 1;
drivers/usb/core/hcd.c:	bus->root_hub = NULL;
drivers/usb/core/hcd.c:	bus->busnum = -1;
drivers/usb/core/hcd.c:	bus->bandwidth_allocated = 0;
drivers/usb/core/hcd.c:	bus->bandwidth_int_reqs  = 0;
drivers/usb/core/hcd.c:	bus->bandwidth_isoc_reqs = 0;
drivers/usb/core/hcd.c:	INIT_LIST_HEAD (&bus->bus_list);
drivers/usb/core/hcd.c:	bus->busnum = busnum;
drivers/usb/core/hcd.c:	list_add (&bus->bus_list, &usb_bus_list);
drivers/usb/core/hcd.c:	dev_info (bus->controller, "new USB bus registered, assigned bus "
drivers/usb/core/hcd.c:		  "number %d\n", bus->busnum);
drivers/usb/core/hcd.c:	dev_info (bus->controller, "USB bus %d deregistered\n", bus->busnum);
drivers/usb/core/hcd.c:	list_del (&bus->bus_list);
drivers/usb/core/hcd.c:	clear_bit(bus->busnum, busmap);
drivers/usb/core/hcd.c:	usb_dev->bus->devnum_next = devnum + 1;
drivers/usb/core/hcd.c:	memset (&usb_dev->bus->devmap.devicemap, 0,
drivers/usb/core/hcd.c:			sizeof usb_dev->bus->devmap.devicemap);
drivers/usb/core/hcd.c:	set_bit (devnum, usb_dev->bus->devmap.devicemap);
drivers/usb/core/hcd.c:	if (!(bus->resuming_ports & bit)) {
drivers/usb/core/hcd.c:		bus->resuming_ports |= bit;
drivers/usb/core/hcd.c:		pm_runtime_get_noresume(&bus->root_hub->dev);
drivers/usb/core/hcd.c:	if (bus->resuming_ports & bit) {
drivers/usb/core/hcd.c:		bus->resuming_ports &= ~bit;
drivers/usb/core/hcd.c:		pm_runtime_put_noidle(&bus->root_hub->dev);
drivers/usb/core/hcd.c: * @port_num: 1-based number of port; usually bus->otg_port
drivers/usb/core/hub.c:	/* power budgeting mostly matters with bus-powered hubs,
drivers/usb/core/hub.c:	if (hdev == hdev->bus->root_hub) {
drivers/usb/core/hub.c:		BUG_ON(test_bit(devnum, bus->devmap.devicemap));
drivers/usb/core/hub.c:		 * bus->devnum_next. */
drivers/usb/core/hub.c:		devnum = find_next_zero_bit(bus->devmap.devicemap, 128,
drivers/usb/core/hub.c:					    bus->devnum_next);
drivers/usb/core/hub.c:			devnum = find_next_zero_bit(bus->devmap.devicemap,
drivers/usb/core/hub.c:		bus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);
drivers/usb/core/hub.c:		set_bit(devnum, bus->devmap.devicemap);
drivers/usb/core/hub.c:		clear_bit(udev->devnum, udev->bus->devmap.devicemap);
drivers/usb/core/hub.c:	if (!udev->bus->is_b_host
drivers/usb/core/hub.c:			&& udev->parent == udev->bus->root_hub) {
drivers/usb/core/hub.c:					(port1 == bus->otg_port)
drivers/usb/core/hub.c:				if (port1 == bus->otg_port)
drivers/usb/core/hub.c:					bus->b_hnp_enable = 1;
drivers/usb/core/hub.c:					bus->b_hnp_enable
drivers/usb/core/hub.c:					bus->b_hnp_enable = 0;
drivers/usb/core/hub.c:		if (udev->bus->b_hnp_enable || udev->bus->is_b_host) {
drivers/usb/core/hub.c:			udev->devnum, udev->bus->busnum,
drivers/usb/core/hub.c:			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
drivers/usb/core/hub.c:			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
drivers/usb/core/hub.c:		if (port1 == hdev->bus->otg_port)
drivers/usb/core/hub.c:			hdev->bus->b_hnp_enable = 0;
drivers/usb/core/hub.c:				devnum, udev->bus->controller->driver->name);
drivers/usb/core/hub.c:						devnum, udev->bus->controller->driver->name);
drivers/usb/core/hub.c:		else if (port1 != udev->bus->otg_port || hdev->parent)
drivers/usb/core/hub.c:	if (hdev->bus->is_b_host)
drivers/usb/core/hub.c:		/* consecutive bus-powered hubs aren't reliable; they can
drivers/usb/core/hub.c:					"can't connect bus-powered hub "
drivers/usb/core/message.c:		dev_err(io->dev->bus->controller,
drivers/usb/core/message.c:	if (dev->bus->sg_tablesize > 0) {
drivers/usb/core/message.c:			dev->bus->busnum, dev->devpath,
drivers/usb/core/otg_whitelist.h:	if (!dev->bus->otg_port)
drivers/usb/core/sysfs.c:	return sprintf(buf, "%d\n", udev->bus->busnum);
drivers/usb/core/urb.c:	} else if (urb->num_sgs && !urb->dev->bus->no_sg_constraint &&
drivers/usb/core/urb.c:	 * FIXME want bus->{intr,iso}_sched_horizon values here.  Each HC
drivers/usb/core/usb.c:	if (add_uevent_var(env, "BUSNUM=%03d", usb_dev->bus->busnum))
drivers/usb/core/usb.c:			 usb_dev->bus->busnum, usb_dev->devnum);
drivers/usb/core/usb.c:	dev->dev.dma_mask = bus->controller->dma_mask;
drivers/usb/core/usb.c:	set_dev_node(&dev->dev, dev_to_node(bus->controller));
drivers/usb/core/usb.c:	 * as stable:  bus->busnum changes easily from modprobe order,
drivers/usb/core/usb.c:		dev->dev.parent = bus->controller;
drivers/usb/core/usb.c:		dev_set_name(&dev->dev, "usb%d", bus->busnum);
drivers/usb/core/usb.c:		dev_set_name(&dev->dev, "%d-%s", bus->busnum, dev->devpath);
drivers/usb/core/usb.c: * bus-snooping caches, these buffers are uncached.
drivers/usb/core/usb.c:			|| !(controller = bus->controller))
drivers/usb/core/usb.c:			|| !(controller = bus->controller))
drivers/usb/core/usb.c:			|| !(controller = bus->controller))
drivers/usb/core/usb.c:			|| !(controller = bus->controller)
drivers/usb/core/usb.c:			|| !(controller = bus->controller)
drivers/usb/core/usb.c:			|| !(controller = bus->controller)
drivers/usb/dwc3/dwc3-omap.c:	if (of_property_read_bool(node, "vbus-supply")) {
drivers/usb/gadget/at91_udc.c:	if (of_property_read_u32(np, "atmel,vbus-polled", &val) == 0)
drivers/usb/gadget/at91_udc.c:	board->vbus_pin = of_get_named_gpio_flags(np, "atmel,vbus-gpio", 0,
drivers/usb/gadget/atmel_usba_udc.c:	udc->vbus_pin = of_get_named_gpio_flags(np, "atmel,vbus-gpio", 0,
drivers/usb/gadget/composite.c:	 * more than 100mA from USB must report itself as bus-powered in
drivers/usb/gadget/mv_udc_core.c:	vbus = udc->pdata->vbus->poll();
drivers/usb/gadget/mv_udc_core.c:				pdata->vbus->irq, NULL,
drivers/usb/gadget/mv_udc_core.c:	if (udc->pdata->vbus && udc->pdata->vbus->poll)
drivers/usb/gadget/mv_udc_core.c:		if (udc->pdata->vbus->poll() == VBUS_HIGH) {
drivers/usb/gadget/net2272.c:		dev->base_shift = iomem_bus->start;
drivers/usb/gadget/pxa25x_udc.c: * the 500uA suspend ceiling means that exclusively vbus-powered PXA designs
drivers/usb/gadget/s3c2410_udc.c:	usb_bus_clock = clk_get(NULL, "usb-bus-gadget");
drivers/usb/host/bcma-hcd.c:	if (dev->bus->chipinfo.id == 0x4716) {
drivers/usb/host/bcma-hcd.c:		tmp = bcma_cpu_clock(&dev->bus->drv_mips);
drivers/usb/host/bcma-hcd.c:	chipinfo = &dev->bus->chipinfo;
drivers/usb/host/ehci-dbg.c:			hcd->self.controller->bus->name,
drivers/usb/host/ehci-dbg.c:		hcd->self.controller->bus->name,
drivers/usb/host/ehci-dbg.c:	ehci->debug_dir = debugfs_create_dir(bus->bus_name, ehci_debug_root);
drivers/usb/host/ehci-exynos.c:	gpio = of_get_named_gpio(dev->of_node, "samsung,vbus-gpio", 0);
drivers/usb/host/ehci-hub.c:		udev->bus->root_hub->speed < USB_SPEED_HIGH;
drivers/usb/host/ehci-hub.c:	 * any notion of "global" or bus-wide suspend.  The driver has
drivers/usb/host/fotg210-hcd.c:			hcd->self.controller->bus->name,
drivers/usb/host/fotg210-hcd.c:		hcd->self.controller->bus->name,
drivers/usb/host/fotg210-hcd.c:	fotg210->debug_dir = debugfs_create_dir(bus->bus_name,
drivers/usb/host/fusbh200-hcd.c:			hcd->self.controller->bus->name,
drivers/usb/host/fusbh200-hcd.c:		hcd->self.controller->bus->name,
drivers/usb/host/fusbh200-hcd.c:	fusbh200->debug_dir = debugfs_create_dir(bus->bus_name, fusbh200_debug_root);
drivers/usb/host/isp1760-if.c:	of_property_read_u32(dp, "bus-width", &bus_width);
drivers/usb/host/ohci-at91.c:		gpio = of_get_named_gpio_flags(np, "atmel,vbus-gpio", i, &flags);
drivers/usb/host/ohci-dbg.c:		hcd->self.controller->bus->name,
drivers/usb/host/ohci-dbg.c:	ohci->debug_dir = debugfs_create_dir(bus->bus_name, ohci_debug_root);
drivers/usb/host/ohci-hcd.c: * "firmware".  this is bus-neutral, unlike shutdown() methods.
drivers/usb/host/ohci-s3c2410.c:	usb_clk = devm_clk_get(&dev->dev, "usb-bus-host");
drivers/usb/host/ohci-s3c2410.c:		dev_err(&dev->dev, "cannot get usb-bus-host clock\n");
drivers/usb/host/oxu210hp-hcd.c:	 * any notion of "global" or bus-wide suspend.  The driver has
drivers/usb/host/r8a66597-hcd.c:		if (!bus->root_hub)
drivers/usb/host/r8a66597-hcd.c:		if (bus->busnum != hcd->self.busnum)
drivers/usb/host/r8a66597-hcd.c:		collect_usb_address_map(bus->root_hub, now_map);
drivers/usb/host/r8a66597-hcd.c:		update_usb_address_map(r8a66597, bus->root_hub, now_map);
drivers/usb/host/ssb-hcd.c:	if (dev->id.revision == 2 && dev->bus->chip_id == 0x5354) {
drivers/usb/host/ssb-hcd.c:	chipid_top = (dev->bus->chip_id & 0xFF00);
drivers/usb/host/uhci-hcd.c:	 * In bus-suspend mode, we use the wakeup setting specified
drivers/usb/host/xhci.c: * Shutdown HC (not bus-specific)
drivers/usb/host/xhci.c: * Stop HC (not bus-specific)
drivers/usb/host/xhci.c: * start xHC (not bus-specific)
drivers/usb/image/mdc800.c: * Either with the dev->bus->ops->bulk... or with callback function.
drivers/usb/misc/ehset.c:		if (hub_udev != dev->bus->root_hub) {
drivers/usb/mon/mon_bin.c:	ep->busnum = urb->dev->bus->busnum;
drivers/usb/mon/mon_bin.c:	ep->busnum = urb->dev->bus->busnum;
drivers/usb/mon/mon_bin.c:	if (mbus != &mon_bus0 && mbus->u_bus == NULL) {
drivers/usb/mon/mon_bin.c:	if (mbus->nreaders <= 0) {
drivers/usb/mon/mon_bin.c:	unsigned minor = ubus? ubus->busnum: 0;
drivers/usb/mon/mon_bin.c:	dev = device_create(mon_bin_class, ubus ? ubus->controller : NULL,
drivers/usb/mon/mon_bin.c:	mbus->classdev = dev;
drivers/usb/mon/mon_bin.c:	device_destroy(mon_bin_class, mbus->classdev->devt);
drivers/usb/mon/mon_main.c: * This must be called with mon_lock taken because of mbus->ref.
drivers/usb/mon/mon_main.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	if (mbus->nreaders == 0) {
drivers/usb/mon/mon_main.c:				m1->u_bus->monitored = 1;
drivers/usb/mon/mon_main.c:			mbus->u_bus->monitored = 1;
drivers/usb/mon/mon_main.c:	mbus->nreaders++;
drivers/usb/mon/mon_main.c:	list_add_tail(&r->r_link, &mbus->r_list);
drivers/usb/mon/mon_main.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	kref_get(&mbus->ref);
drivers/usb/mon/mon_main.c: * This is called with mon_lock taken, so we can decrement mbus->ref.
drivers/usb/mon/mon_main.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	--mbus->nreaders;
drivers/usb/mon/mon_main.c:	if (mbus->nreaders == 0)
drivers/usb/mon/mon_main.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	kref_put(&mbus->ref, mon_bus_drop);
drivers/usb/mon/mon_main.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	mbus->cnt_events++;
drivers/usb/mon/mon_main.c:	list_for_each (pos, &mbus->r_list) {
drivers/usb/mon/mon_main.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	if ((mbus = ubus->mon_bus) != NULL)
drivers/usb/mon/mon_main.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	mbus->cnt_events++;
drivers/usb/mon/mon_main.c:	list_for_each (pos, &mbus->r_list) {
drivers/usb/mon/mon_main.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	if ((mbus = ubus->mon_bus) != NULL)
drivers/usb/mon/mon_main.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	mbus->cnt_events++;
drivers/usb/mon/mon_main.c:	list_for_each (pos, &mbus->r_list) {
drivers/usb/mon/mon_main.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_main.c:	if ((mbus = ubus->mon_bus) != NULL)
drivers/usb/mon/mon_main.c:			if (mbus->nreaders == 0 && (ubus = mbus->u_bus) != NULL)
drivers/usb/mon/mon_main.c:				ubus->monitored = 0;
drivers/usb/mon/mon_main.c:		if (mon_bus0.nreaders == 0 && (ubus = mbus->u_bus) != NULL) {
drivers/usb/mon/mon_main.c:			ubus->monitored = 0;
drivers/usb/mon/mon_main.c:		ubus->monitored = 1;
drivers/usb/mon/mon_main.c:	struct mon_bus *mbus = ubus->mon_bus;
drivers/usb/mon/mon_main.c:	list_del(&mbus->bus_link);
drivers/usb/mon/mon_main.c:	if (mbus->text_inited)
drivers/usb/mon/mon_main.c:	if (mbus->bin_inited)
drivers/usb/mon/mon_main.c:	kref_put(&mbus->ref, mon_bus_drop);
drivers/usb/mon/mon_main.c:	if (ubus->monitored) {
drivers/usb/mon/mon_main.c:		ubus->monitored = 0;
drivers/usb/mon/mon_main.c:	ubus->mon_bus = NULL;
drivers/usb/mon/mon_main.c:	mbus->u_bus = NULL;
drivers/usb/mon/mon_main.c:	kref_init(&mbus->ref);
drivers/usb/mon/mon_main.c:	spin_lock_init(&mbus->lock);
drivers/usb/mon/mon_main.c:	INIT_LIST_HEAD(&mbus->r_list);
drivers/usb/mon/mon_main.c:	mbus->u_bus = ubus;
drivers/usb/mon/mon_main.c:	ubus->mon_bus = mbus;
drivers/usb/mon/mon_main.c:	mbus->text_inited = mon_text_add(mbus, ubus);
drivers/usb/mon/mon_main.c:	mbus->bin_inited = mon_bin_add(mbus, ubus);
drivers/usb/mon/mon_main.c:	list_add_tail(&mbus->bus_link, &mon_buses);
drivers/usb/mon/mon_main.c:	kref_init(&mbus->ref);
drivers/usb/mon/mon_main.c:	spin_lock_init(&mbus->lock);
drivers/usb/mon/mon_main.c:	INIT_LIST_HEAD(&mbus->r_list);
drivers/usb/mon/mon_main.c:	mbus->text_inited = mon_text_add(mbus, NULL);
drivers/usb/mon/mon_main.c:	mbus->bin_inited = mon_bin_add(mbus, NULL);
drivers/usb/mon/mon_main.c:		if (mbus->u_bus->busnum == num) {
drivers/usb/mon/mon_main.c:		if (mbus->text_inited)
drivers/usb/mon/mon_main.c:		if (mbus->bin_inited)
drivers/usb/mon/mon_main.c:		if (mbus->nreaders) {
drivers/usb/mon/mon_main.c:			    mbus->nreaders, mbus->u_bus->busnum);
drivers/usb/mon/mon_main.c:			atomic_set(&mbus->ref.refcount, 2);	/* Force leak */
drivers/usb/mon/mon_main.c:		mon_dissolve(mbus, mbus->u_bus);
drivers/usb/mon/mon_main.c:		kref_put(&mbus->ref, mon_bus_drop);
drivers/usb/mon/mon_main.c:	if (mbus->text_inited)
drivers/usb/mon/mon_main.c:	if (mbus->bin_inited)
drivers/usb/mon/mon_stat.c:	    mbus->nreaders, mbus->cnt_events, mbus->cnt_text_lost);
drivers/usb/mon/mon_text.c:		rp->r.m_bus->cnt_text_lost++;
drivers/usb/mon/mon_text.c:	ep->busnum = urb->dev->bus->busnum;
drivers/usb/mon/mon_text.c:		rp->r.m_bus->cnt_text_lost++;
drivers/usb/mon/mon_text.c:	ep->busnum = urb->dev->bus->busnum;
drivers/usb/mon/mon_text.c:	spin_lock_irqsave(&mbus->lock, flags);
drivers/usb/mon/mon_text.c:		spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_text.c:	spin_unlock_irqrestore(&mbus->lock, flags);
drivers/usb/mon/mon_text.c:	if (mbus->nreaders <= 0) {
drivers/usb/mon/mon_text.c:	 * In theory, e_list is protected by mbus->lock. However,
drivers/usb/mon/mon_text.c:	/* spin_lock_irqsave(&mbus->lock, flags); */
drivers/usb/mon/mon_text.c:	/* spin_unlock_irqrestore(&mbus->lock, flags); */
drivers/usb/mon/mon_text.c:	int busnum = ubus? ubus->busnum: 0;
drivers/usb/mon/mon_text.c:		mbus->dent_t = d;
drivers/usb/mon/mon_text.c:	mbus->dent_u = d;
drivers/usb/mon/mon_text.c:	mbus->dent_s = d;
drivers/usb/mon/mon_text.c:	debugfs_remove(mbus->dent_u);
drivers/usb/mon/mon_text.c:	mbus->dent_u = NULL;
drivers/usb/mon/mon_text.c:		debugfs_remove(mbus->dent_t);
drivers/usb/mon/mon_text.c:		mbus->dent_t = NULL;
drivers/usb/mon/mon_text.c:	debugfs_remove(mbus->dent_u);
drivers/usb/mon/mon_text.c:	if (mbus->dent_t != NULL)
drivers/usb/mon/mon_text.c:		debugfs_remove(mbus->dent_t);
drivers/usb/mon/mon_text.c:	debugfs_remove(mbus->dent_s);
drivers/usb/mon/usb_mon.h:	int nreaders;			/* Under mon_lock AND mbus->lock */
drivers/usb/musb/am35x.c:			 * means it's not uncommon for bus-powered devices
drivers/usb/musb/da8xx.c:			 * means it's not uncommon for bus-powered devices
drivers/usb/musb/davinci.c:			 * means it's not uncommon for bus-powered devices
drivers/usb/musb/musb_dsps.c:			 * means it's not uncommon for bus-powered devices
drivers/usb/phy/Makefile:obj-$(CONFIG_USB_GPIO_VBUS)		+= phy-gpio-vbus-usb.o
drivers/usb/phy/phy-ab8500-usb.c:				"usb-vbus-fall", ab);
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct regulator *vbus_draw = gpio_vbus->vbus_draw;
drivers/usb/phy/phy-gpio-vbus-usb.c:	enabled = gpio_vbus->vbus_draw_enabled;
drivers/usb/phy/phy-gpio-vbus-usb.c:			gpio_vbus->vbus_draw_enabled = 1;
drivers/usb/phy/phy-gpio-vbus-usb.c:			gpio_vbus->vbus_draw_enabled = 0;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->mA = mA;
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct gpio_vbus_mach_info *pdata = dev_get_platdata(gpio_vbus->dev);
drivers/usb/phy/phy-gpio-vbus-usb.c:	if (!gpio_vbus->phy.otg->gadget)
drivers/usb/phy/phy-gpio-vbus-usb.c:	if ((vbus ^ gpio_vbus->vbus) == 0)
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->vbus = vbus;
drivers/usb/phy/phy-gpio-vbus-usb.c:		gpio_vbus->phy.state = OTG_STATE_B_PERIPHERAL;
drivers/usb/phy/phy-gpio-vbus-usb.c:		gpio_vbus->phy.last_event = status;
drivers/usb/phy/phy-gpio-vbus-usb.c:		usb_gadget_vbus_connect(gpio_vbus->phy.otg->gadget);
drivers/usb/phy/phy-gpio-vbus-usb.c:		atomic_notifier_call_chain(&gpio_vbus->phy.notifier,
drivers/usb/phy/phy-gpio-vbus-usb.c:					   status, gpio_vbus->phy.otg->gadget);
drivers/usb/phy/phy-gpio-vbus-usb.c:		usb_gadget_vbus_disconnect(gpio_vbus->phy.otg->gadget);
drivers/usb/phy/phy-gpio-vbus-usb.c:		gpio_vbus->phy.state = OTG_STATE_B_IDLE;
drivers/usb/phy/phy-gpio-vbus-usb.c:		gpio_vbus->phy.last_event = status;
drivers/usb/phy/phy-gpio-vbus-usb.c:		atomic_notifier_call_chain(&gpio_vbus->phy.notifier,
drivers/usb/phy/phy-gpio-vbus-usb.c:					   status, gpio_vbus->phy.otg->gadget);
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct usb_otg *otg = gpio_vbus->phy.otg;
drivers/usb/phy/phy-gpio-vbus-usb.c:		schedule_delayed_work(&gpio_vbus->work, msecs_to_jiffies(100));
drivers/usb/phy/phy-gpio-vbus-usb.c:	pdev = to_platform_device(gpio_vbus->dev);
drivers/usb/phy/phy-gpio-vbus-usb.c:	pdata = dev_get_platdata(gpio_vbus->dev);
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->vbus = 0; /* start with disconnected */
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus_irq(gpio_vbus->irq, pdev);
drivers/usb/phy/phy-gpio-vbus-usb.c:	return gpio_vbus_set_power(phy, suspend ? 0 : gpio_vbus->mA);
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);
drivers/usb/phy/phy-gpio-vbus-usb.c:	if (!gpio_vbus->phy.otg) {
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->dev = &pdev->dev;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.label = "gpio-vbus";
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.dev = gpio_vbus->dev;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.set_power = gpio_vbus_set_power;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.set_suspend = gpio_vbus_set_suspend;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.state = OTG_STATE_UNDEFINED;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.otg->phy = &gpio_vbus->phy;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->phy.otg->set_peripheral = gpio_vbus_set_peripheral;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->irq = irq;
drivers/usb/phy/phy-gpio-vbus-usb.c:	ATOMIC_INIT_NOTIFIER_HEAD(&gpio_vbus->phy.notifier);
drivers/usb/phy/phy-gpio-vbus-usb.c:	INIT_DELAYED_WORK(&gpio_vbus->work, gpio_vbus_work);
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->vbus_draw = regulator_get(&pdev->dev, "vbus_draw");
drivers/usb/phy/phy-gpio-vbus-usb.c:	if (IS_ERR(gpio_vbus->vbus_draw)) {
drivers/usb/phy/phy-gpio-vbus-usb.c:			PTR_ERR(gpio_vbus->vbus_draw));
drivers/usb/phy/phy-gpio-vbus-usb.c:		gpio_vbus->vbus_draw = NULL;
drivers/usb/phy/phy-gpio-vbus-usb.c:	err = usb_add_phy(&gpio_vbus->phy, USB_PHY_TYPE_USB2);
drivers/usb/phy/phy-gpio-vbus-usb.c:	regulator_put(gpio_vbus->vbus_draw);
drivers/usb/phy/phy-gpio-vbus-usb.c:	kfree(gpio_vbus->phy.otg);
drivers/usb/phy/phy-gpio-vbus-usb.c:	cancel_delayed_work_sync(&gpio_vbus->work);
drivers/usb/phy/phy-gpio-vbus-usb.c:	regulator_put(gpio_vbus->vbus_draw);
drivers/usb/phy/phy-gpio-vbus-usb.c:	usb_remove_phy(&gpio_vbus->phy);
drivers/usb/phy/phy-gpio-vbus-usb.c:	free_irq(gpio_vbus->irq, pdev);
drivers/usb/phy/phy-gpio-vbus-usb.c:	kfree(gpio_vbus->phy.otg);
drivers/usb/phy/phy-gpio-vbus-usb.c:		enable_irq_wake(gpio_vbus->irq);
drivers/usb/phy/phy-gpio-vbus-usb.c:		disable_irq_wake(gpio_vbus->irq);
drivers/usb/phy/phy-mv-usb.c:		if (mvotg->pdata->vbus->poll() == VBUS_HIGH) {
drivers/usb/phy/phy-mv-usb.c:		retval = devm_request_threaded_irq(&pdev->dev, pdata->vbus->irq,
drivers/usb/phy/phy-tegra-usb.c:	if (of_find_property(np, "vbus-supply", NULL)) {
drivers/usb/serial/ch341.c:	/* reconfigure ch341 serial port after bus-reset */
drivers/usb/storage/onetouch.c:			"retval %d\n", onetouch->udev->bus->bus_name,
drivers/usb/storage/scsiglue.c:	if (!us->pusb_dev->bus->controller->dma_mask)
drivers/usb/storage/uas.c:	urb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;
drivers/usb/storage/uas.c:	int sg_supported = udev->bus->sg_tablesize != 0;
drivers/usb/storage/uas.c:	shost->sg_tablesize = udev->bus->sg_tablesize;
drivers/usb/storage/usb.c:	if (usb_dev->bus->sg_tablesize) {
drivers/usb/storage/usb.c:		return usb_dev->bus->sg_tablesize;
drivers/uwb/lc-dev.c:		 rc ? rc->uwb_dev.dev.parent->bus->name : "n/a",
drivers/uwb/lc-dev.c:		 macbuf, devbuf, rc->uwb_dev.dev.parent->bus->name,
drivers/uwb/lc-rc.c:		 macbuf, devbuf, parent_dev->bus->name, dev_name(parent_dev));
drivers/vfio/pci/vfio_pci.c:	fill->devices[fill->cur].bus = pdev->bus->number;
drivers/vfio/pci/vfio_pci.c:	for (; pdev; pdev = pdev->bus->self)
drivers/video/cyber2000fb.c: * This probe function is common to all bus types.  The bus-specific
drivers/video/cyber2000fb.h:#define PCI_BM_CTL_ENABLE		0x01	/* enable bus-master			*/
drivers/video/intelfb/intelfbdrv.c:		pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/video/matrox/matroxfb_DAC1064.c:		if (b == minfo->pcidev->bus->number) {
drivers/video/mxsfb.c:	ret = of_property_read_u32(display_np, "bus-width", &width);
drivers/video/mxsfb.c:		dev_err(dev, "failed to get property bus-width\n");
drivers/video/mxsfb.c:		dev_err(dev, "invalid bus-width value\n");
drivers/video/sis/sis_main.c:	ivideo->pcibus = pdev->bus->number;
drivers/video/tgafb.c:			to_pci_dev(dev)->bus->number,
drivers/video/via/via_aux.c:	bus->adap = adap;
drivers/video/via/via_aux.c:	INIT_LIST_HEAD(&bus->drivers);
drivers/video/via/via_aux.c:	list_for_each_entry_safe(pos, n, &bus->drivers, chain) {
drivers/video/via/via_aux.c:	list_for_each_entry(pos, &bus->drivers, chain) {
drivers/video/via/via_aux.h:	list_add_tail(&data->chain, &data->bus->drivers);
drivers/video/via/via_aux.h:	return i2c_transfer(drv->bus->adap, msg, 2) == 2;
drivers/xen/dbgp.c:		dbgp.u.pci.bus = pdev->bus->number;
drivers/xen/pci.c:			.bus = pci_dev->bus->number,
drivers/xen/pci.c:			add.physfn.bus = physfn->bus->number;
drivers/xen/pci.c:		if (!handle && pci_dev->bus->bridge)
drivers/xen/pci.c:			handle = ACPI_HANDLE(pci_dev->bus->bridge);
drivers/xen/pci.c:			handle = ACPI_HANDLE(physfn->bus->bridge);
drivers/xen/pci.c:			.bus		= pci_dev->bus->number,
drivers/xen/pci.c:			.physfn.bus	= physfn->bus->number,
drivers/xen/pci.c:			.bus		= pci_dev->bus->number,
drivers/xen/pci.c:			.bus	= pci_dev->bus->number,
drivers/xen/pci.c:			.bus = pci_dev->bus->number,
drivers/xen/pci.c:			.bus = pci_dev->bus->number,
drivers/xen/platform-pci.c:		((uint64_t)pdev->bus->number << 16) |
drivers/xen/xen-pciback/passthrough.c:		    && bus == (unsigned int)dev_entry->dev->bus->number
drivers/xen/xen-pciback/passthrough.c:	bus = (unsigned int)dev->bus->number;
drivers/xen/xen-pciback/passthrough.c:		dev = dev_entry->dev->bus->self;
drivers/xen/xen-pciback/passthrough.c:		for (; !found && dev != NULL; dev = dev->bus->self) {
drivers/xen/xen-pciback/passthrough.c:		bus = (unsigned int)dev_entry->dev->bus->number;
drivers/xen/xen-pciback/passthrough.c:	*bus = pcidev->bus->number;
drivers/xen/xen-pciback/pci_stub.c:			.bus = dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:		    && bus == psdev->dev->bus->number
drivers/xen/xen-pciback/pci_stub.c:		    && bus == psdev->dev->bus->number
drivers/xen/xen-pciback/pci_stub.c:	for (; dev != NULL; dev = dev->bus->self) {
drivers/xen/xen-pciback/pci_stub.c:		    && dev->bus->number == pdev_id->bus
drivers/xen/xen-pciback/pci_stub.c:		if (dev == dev->bus->self)
drivers/xen/xen-pciback/pci_stub.c:			.bus = dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:		dev->bus->number, dev->devfn);
drivers/xen/xen-pciback/pci_stub.c:				dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:		dev->bus->number, dev->devfn);
drivers/xen/xen-pciback/pci_stub.c:				dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:		dev->bus->number, dev->devfn);
drivers/xen/xen-pciback/pci_stub.c:				dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:		dev->bus->number, dev->devfn);
drivers/xen/xen-pciback/pci_stub.c:				dev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:				   quirk->pdev->bus->number,
drivers/xen/xen-pciback/vpci.c:			if (dev && dev->bus->number == pcidev->bus->number
drivers/xen/xenbus/Makefile:xenbus-objs =
drivers/xen/xenbus/Makefile:xenbus-objs += xenbus_client.o
drivers/xen/xenbus/Makefile:xenbus-objs += xenbus_comms.o
drivers/xen/xenbus/Makefile:xenbus-objs += xenbus_xs.o
drivers/xen/xenbus/Makefile:xenbus-objs += xenbus_probe.o
drivers/xen/xenbus/Makefile:xenbus-be-objs-$(CONFIG_XEN_BACKEND) += xenbus_probe_backend.o
drivers/xen/xenbus/Makefile:xenbus-objs += $(xenbus-be-objs-y)
drivers/xen/xenbus/xenbus_probe.c:				    bus->otherend_changed,
drivers/xen/xenbus/xenbus_probe.c:	drv->driver.bus = &bus->bus;
drivers/xen/xenbus/xenbus_probe.c:	return sprintf(buf, "%s:%s\n", dev->bus->name,
drivers/xen/xenbus/xenbus_probe.c:	xendev->dev.bus = &bus->bus;
drivers/xen/xenbus/xenbus_probe.c:	err = bus->get_bus_id(devname, xendev->nodename);
drivers/xen/xenbus/xenbus_probe.c:	dir = xenbus_directory(XBT_NIL, bus->root, type, &dir_n);
drivers/xen/xenbus/xenbus_probe.c:		err = bus->probe(bus, type, dir[i]);
drivers/xen/xenbus/xenbus_probe.c:	dir = xenbus_directory(XBT_NIL, bus->root, "", &dir_n);
drivers/xen/xenbus/xenbus_probe.c:		xenbus_cleanup_devices(node, &bus->bus);
drivers/xen/xenbus/xenbus_probe.c:	rootlen = strsep_len(node, '/', bus->levels);
drivers/xen/xenbus/xenbus_probe.c:	dev = xenbus_device_find(root, &bus->bus);
drivers/xen/xenbus/xenbus_probe_backend.c:	if (add_uevent_var(env, "XENBUS_BASE_PATH=%s", bus->root))
drivers/xen/xenbus/xenbus_probe_backend.c:	nodename = kasprintf(GFP_KERNEL, "%s/%s/%s", bus->root, type, domid);
drivers/xen/xenbus/xenbus_probe_frontend.c:	nodename = kasprintf(GFP_KERNEL, "%s/%s/%s", bus->root, type, name);
drivers/zorro/zorro.c:	bus->dev.parent = &pdev->dev;
drivers/zorro/zorro.c:	dev_set_name(&bus->dev, "zorro");
drivers/zorro/zorro.c:	error = device_register(&bus->dev);
drivers/zorro/zorro.c:		put_device(&bus->dev);
drivers/zorro/zorro.c:			dev_err(&bus->dev,
drivers/zorro/zorro.c:		z->dev.parent = &bus->dev;
drivers/zorro/zorro.c:			dev_err(&bus->dev, "Error registering device %s\n",
include/drm/drmP.h:	return dev->driver->bus->get_irq(dev);
include/linux/bcma/bcma.h:	return core->bus->ops->read8(core, offset);
include/linux/bcma/bcma.h:	return core->bus->ops->read16(core, offset);
include/linux/bcma/bcma.h:	return core->bus->ops->read32(core, offset);
include/linux/bcma/bcma.h:	core->bus->ops->write8(core, offset, value);
include/linux/bcma/bcma.h:	core->bus->ops->write16(core, offset, value);
include/linux/bcma/bcma.h:	core->bus->ops->write32(core, offset, value);
include/linux/bcma/bcma.h:	core->bus->ops->block_read(core, buffer, count, offset, reg_width);
include/linux/bcma/bcma.h:	core->bus->ops->block_write(core, buffer, count, offset, reg_width);
include/linux/bcma/bcma.h:	return core->bus->ops->aread32(core, offset);
include/linux/bcma/bcma.h:	core->bus->ops->awrite32(core, offset, value);
include/linux/device.h: *              bus-specific setup
include/linux/device.h:	return dev->bus && dev->bus->offline && dev->bus->online;
include/linux/i2c.h: * @command: Callback for bus-wide signaling (optional)
include/linux/ipack.h: * by the carrier board throught bus->ops.
include/linux/pci-acpi.h:		pbus = pbus->parent;
include/linux/pci-acpi.h:	return ACPI_HANDLE(pbus->bridge);
include/linux/pci-acpi.h:		dev = pbus->bridge;
include/linux/pci-acpi.h:		dev = &pbus->self->dev;
include/linux/pci.h: * Some code assumes that "bus->self == NULL" means that bus is a root bus.
include/linux/pci.h: * virtfn_add_bus()) have "bus->self == NULL" but are not root buses.
include/linux/pci.h:	return !(pbus->parent);
include/linux/pci.h:	return dev->bus->self;
include/linux/pci.h:	return bus ? bus->dev.of_node : NULL;
include/linux/platform_data/i2c-cbus-gpio.h: * i2c-cbus-gpio.h - CBUS I2C platform_data definition
include/linux/sdb.h: * bus-specific bits are defined by each bus (see below)
include/linux/sdb.h:/* The type of bus, for bus-specific flags */
include/linux/ssb/ssb.h:	       "unsupported bustype %d\n", dev->bus->bustype);
include/linux/ssb/ssb.h:	if (sdev->bus->bustype == SSB_BUSTYPE_PCI)
include/linux/ssb/ssb.h:		pci_set_power_state(sdev->bus->host_pci, state);
include/linux/ssb/ssb_driver_gige.h:	return container_of(pdev->bus->ops, struct ssb_gige, pci_ops);
include/linux/ssb/ssb_driver_gige.h:		return !!(dev->dev->bus->sprom.boardflags_lo &
include/linux/ssb/ssb_driver_gige.h:		return ((dev->dev->bus->chip_id == 0x4785) &&
include/linux/ssb/ssb_driver_gige.h:			(dev->dev->bus->chip_rev < 2));
include/linux/ssb/ssb_driver_gige.h:		return (dev->dev->bus->chip_id == 0x4785);
include/linux/ssb/ssb_driver_gige.h:	memcpy(macaddr, dev->dev->bus->sprom.et0mac, 6);
include/linux/ssb/ssb_driver_gige.h:	return dev->dev->bus->sprom.et0phyaddr;
include/linux/superhyway.h:	return dev->bus->ops->read_vcr(base, vcr);
include/linux/superhyway.h:	return dev->bus->ops->write_vcr(base, vcr);
include/linux/tc.h:	return 100000 * (10000 / (unsigned long)tbus->info.clk_period);
include/linux/ucb1400.h:	return ac97->bus->ops->read(ac97, reg);
include/linux/ucb1400.h:	ac97->bus->ops->write(ac97, reg, val);
include/linux/usb.h:	return udev && udev->bus && udev->bus->no_sg_constraint;
include/linux/usb.h:	actual = snprintf(buf, size, "usb-%s-%s", dev->bus->bus_name,
include/linux/usb/gadget.h: * @gadget:the device being declared as bus-powered
include/linux/usb/gadget.h: * some hardware may not support bus-powered operation, in which
include/linux/usb/hcd.h:	if (bus->monitored)
include/linux/usb/hcd.h:	if (bus->monitored)
include/linux/usb/hcd.h:	if (bus->monitored)
include/net/wimax.h: *     DRIVERNAME-BUSNAME:BUSID (dev->bus->name, dev->bus_id).
include/sound/i2c.h:	if (bus->master)
include/sound/i2c.h:		mutex_lock(&bus->master->lock_mutex);
include/sound/i2c.h:		mutex_lock(&bus->lock_mutex);
include/sound/i2c.h:	if (bus->master)
include/sound/i2c.h:		mutex_unlock(&bus->master->lock_mutex);
include/sound/i2c.h:		mutex_unlock(&bus->lock_mutex);
include/uapi/linux/usb/ch9.h: * more than 100mA from USB must report itself as bus-powered in
kernel/trace/trace_mmiotrace.c:				dev->bus->number, dev->devfn,
net/dsa/dsa.c:		cd->mii_bus = &mdio_bus->dev;
net/dsa/slave.c:	struct dsa_switch *ds = bus->priv;
net/dsa/slave.c:	struct dsa_switch *ds = bus->priv;
net/dsa/slave.c:	ds->slave_mii_bus->priv = (void *)ds;
net/dsa/slave.c:	ds->slave_mii_bus->name = "dsa slave smi";
net/dsa/slave.c:	ds->slave_mii_bus->read = dsa_slave_phy_read;
net/dsa/slave.c:	ds->slave_mii_bus->write = dsa_slave_phy_write;
net/dsa/slave.c:	snprintf(ds->slave_mii_bus->id, MII_BUS_ID_SIZE, "dsa-%d:%.2x",
net/dsa/slave.c:	ds->slave_mii_bus->parent = &ds->master_mii_bus->dev;
net/dsa/slave.c:	p->phy = ds->slave_mii_bus->phy_map[port];
net/sunrpc/xprtrdma/verbs.c:if (strnicmp(ia->ri_id->device->dma_device->bus->name, "pci", 3) == 0) {
sound/aoa/soundbus/Makefile:snd-aoa-soundbus-objs := core.o sysfs.o
sound/aoa/soundbus/i2sbus/Makefile:snd-aoa-i2sbus-objs := core.o pcm.o control.o
sound/aoa/soundbus/i2sbus/control.c:	(*c)->macio = dev->bus->chip;
sound/aoa/soundbus/i2sbus/core.c:		.name = "soundbus-i2s",
sound/arm/aaci.c:	slots = aaci->ac97_bus->pcms[0].r[0].slots;
sound/arm/aaci.c:	ac97_bus->clock = 48000;
sound/arm/aaci.c:	aaci->playback.pcm = &ac97_bus->pcms[0];
sound/arm/aaci.c:	aaci->capture.pcm  = &ac97_bus->pcms[1];
sound/arm/pxa2xx-ac97.c:		snd_ac97_dev_add_pdata(ac97_bus->codec[0], pdata->codec_pdata[0]);
sound/i2c/cs8427.c:		err = snd_ctl_add(cs8427->bus->card, kctl);
sound/i2c/cs8427.c:	snd_ctl_notify(cs8427->bus->card,
sound/i2c/cs8427.c:		snd_ctl_notify(cs8427->bus->card,
sound/i2c/i2c.c:	while (!list_empty(&bus->devices)) {
sound/i2c/i2c.c:		device = snd_i2c_device(bus->devices.next);
sound/i2c/i2c.c:	if (bus->master)
sound/i2c/i2c.c:		list_del(&bus->buses);
sound/i2c/i2c.c:		while (!list_empty(&bus->buses)) {
sound/i2c/i2c.c:			slave = snd_i2c_slave_bus(bus->buses.next);
sound/i2c/i2c.c:			snd_device_free(bus->card, slave);
sound/i2c/i2c.c:	if (bus->private_free)
sound/i2c/i2c.c:		bus->private_free(bus);
sound/i2c/i2c.c:	mutex_init(&bus->lock_mutex);
sound/i2c/i2c.c:	INIT_LIST_HEAD(&bus->devices);
sound/i2c/i2c.c:	INIT_LIST_HEAD(&bus->buses);
sound/i2c/i2c.c:	bus->card = card;
sound/i2c/i2c.c:	bus->ops = &snd_i2c_bit_ops;
sound/i2c/i2c.c:		list_add_tail(&bus->buses, &master->buses);
sound/i2c/i2c.c:		bus->master = master;
sound/i2c/i2c.c:	strlcpy(bus->name, name, sizeof(bus->name));
sound/i2c/i2c.c:	list_add_tail(&device->list, &bus->devices);
sound/i2c/i2c.c:	return device->bus->ops->sendbytes(device, bytes, count);
sound/i2c/i2c.c:	return device->bus->ops->readbytes(device, bytes, count);
sound/i2c/i2c.c:	return bus->ops->probeaddr(bus, addr);
sound/i2c/i2c.c:	if (bus->hw_ops.bit->start)
sound/i2c/i2c.c:		bus->hw_ops.bit->start(bus);
sound/i2c/i2c.c:	if (bus->hw_ops.bit->stop)
sound/i2c/i2c.c:		bus->hw_ops.bit->stop(bus);
sound/i2c/i2c.c:	if (bus->hw_ops.bit->direction)
sound/i2c/i2c.c:		bus->hw_ops.bit->direction(bus, clock, data);
sound/i2c/i2c.c:	bus->hw_ops.bit->setlines(bus, clock, data);
sound/i2c/i2c.c:	if (bus->hw_ops.bit->getclock)
sound/i2c/i2c.c:		return bus->hw_ops.bit->getclock(bus);
sound/i2c/i2c.c:	return bus->hw_ops.bit->getdata(bus, ack);
sound/isa/gus/interwave.c:	unsigned long port = bus->private_value;
sound/isa/gus/interwave.c:	unsigned long port = bus->private_value;
sound/isa/gus/interwave.c:	unsigned long port = bus->private_value;
sound/isa/gus/interwave.c:	bus->private_value = port;
sound/isa/gus/interwave.c:	bus->hw_ops.bit = &snd_interwave_i2c_bit_ops;
sound/mips/hal2.c:	unsigned int ctrl;		/* Current state of pbus->pbdma_ctrl */
sound/mips/hal2.c:	if (hal2->dac.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {
sound/mips/hal2.c:	if (hal2->adc.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {
sound/mips/hal2.c:	pbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_LD |
sound/mips/hal2.c:	pbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
sound/mips/hal2.c:	hal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));
sound/mips/hal2.c:	hal2_i_write16(hal2, H2I_DAC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)
sound/mips/hal2.c:	pbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_RCV | HPC3_PDMACTRL_LD |
sound/mips/hal2.c:	pbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
sound/mips/hal2.c:	hal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));
sound/mips/hal2.c:	hal2_i_write16(hal2, H2I_ADC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)
sound/mips/hal2.c:	pbus->pbus->pbdma_dptr = hal2->dac.desc_dma;
sound/mips/hal2.c:	pbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;
sound/mips/hal2.c:	pbus->pbus->pbdma_dptr = hal2->adc.desc_dma;
sound/mips/hal2.c:	pbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;
sound/mips/hal2.c:	hal2->dac.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
sound/mips/hal2.c:	hal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
sound/mips/hal2.c:						 dac->pbus.pbus->pbdma_bptr);
sound/mips/hal2.c:						adc->pbus.pbus->pbdma_bptr);
sound/oss/ad1848.c:	char *busname = bus->name[0] ? bus->name : ad1848_isapnp_list[slot].name;
sound/pci/ac97/ac97_codec.c:			ac97->bus->ops->write(ac97, AC97_RESET, 0);	/* reset audio codec */
sound/pci/ac97/ac97_codec.c:	ac97->bus->ops->write(ac97, reg, value);
sound/pci/ac97/ac97_codec.c:	return ac97->bus->ops->read(ac97, reg);
sound/pci/ac97/ac97_codec.c:		ac97->regs[reg] = ac97->bus->ops->read(ac97, reg);
sound/pci/ac97/ac97_codec.c:	ac97->bus->ops->write(ac97, reg, value);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, reg, value);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, reg, new);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, AC97_PCM, new);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,
sound/pci/ac97/ac97_codec.c:		kfree(bus->pcms);
sound/pci/ac97/ac97_codec.c:		if (bus->private_free)
sound/pci/ac97/ac97_codec.c:			bus->private_free(bus);
sound/pci/ac97/ac97_codec.c:			ac97->bus->codec[ac97->num] = NULL;
sound/pci/ac97/ac97_codec.c:	struct snd_card *card = ac97->bus->card;
sound/pci/ac97/ac97_codec.c:	tmp = ((unsigned int)rate * ac97->bus->clock) / 48000;
sound/pci/ac97/ac97_codec.c:	if (ac97->bus->no_vra) {
sound/pci/ac97/ac97_codec.c:	bus->card = card;
sound/pci/ac97/ac97_codec.c:	bus->num = num;
sound/pci/ac97/ac97_codec.c:	bus->ops = ops;
sound/pci/ac97/ac97_codec.c:	bus->private_data = private_data;
sound/pci/ac97/ac97_codec.c:	bus->clock = 48000;
sound/pci/ac97/ac97_codec.c:	spin_lock_init(&bus->bus_lock);
sound/pci/ac97/ac97_codec.c:	ac97->dev.parent = ac97->bus->card->dev;
sound/pci/ac97/ac97_codec.c:		     ac97->bus->card->number, ac97->num,
sound/pci/ac97/ac97_codec.c:	if (bus->codec[template->num])
sound/pci/ac97/ac97_codec.c:	card = bus->card;
sound/pci/ac97/ac97_codec.c:	bus->codec[ac97->num] = ac97;
sound/pci/ac97/ac97_codec.c:	if (bus->ops->reset) {
sound/pci/ac97/ac97_codec.c:		bus->ops->reset(ac97);
sound/pci/ac97/ac97_codec.c:	if (bus->ops->wait)
sound/pci/ac97/ac97_codec.c:		bus->ops->wait(ac97);
sound/pci/ac97/ac97_codec.c:	if (bus->ops->reset) // FIXME: always skipping?
sound/pci/ac97/ac97_codec.c:		if (! bus->no_vra)
sound/pci/ac97/ac97_codec.c:	if ((ac97->ext_id & AC97_EI_DRA) && bus->dra) {
sound/pci/ac97/ac97_codec.c:	if (bus->ops->init)
sound/pci/ac97/ac97_codec.c:		bus->ops->init(ac97);
sound/pci/ac97/ac97_codec.c:	if (ac97->bus->ops->reset) {
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->reset(ac97);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, AC97_MASTER, 0x8101);
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->write(ac97, AC97_MASTER, AC97_MUTE_MASK_MONO);
sound/pci/ac97/ac97_codec.c:	if (ac97->bus->ops->init)
sound/pci/ac97/ac97_codec.c:		ac97->bus->ops->init(ac97);
sound/pci/ac97/ac97_codec.c:	return snd_ctl_remove_id(ac97->bus->card, &id);
sound/pci/ac97/ac97_codec.c:	return snd_ctl_find_id(ac97->bus->card, &sid);
sound/pci/ac97/ac97_codec.c:	return snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&snd_ac97_alc_jack_detect, ac97));
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&controls[idx], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:	kctl = snd_ctl_find_id(ac97->bus->card, &sid);
sound/pci/ac97/ac97_patch.c:	err = snd_ctl_add(ac97->bus->card, kctl);
sound/pci/ac97/ac97_patch.c:	err = snd_ctl_add(ac97->bus->card,
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&wm97xx_snd_ac97_controls[i], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&wm9704_snd_ac97_controls[i], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&wm9711_snd_ac97_controls[i], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&wm13_snd_ac97_controls_3d[i], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&wm13_snd_ac97_controls[i], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:	if ((err = snd_ctl_add(ac97->bus->card, kctl = snd_ac97_cnew(&snd_ac97_controls_3d[0], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:	if ((err = snd_ctl_add(ac97->bus->card, kctl = snd_ac97_cnew(&snd_ac97_controls_3d[0], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:	if ((err = snd_ctl_add(ac97->bus->card, kctl = snd_ac97_cnew(&snd_ac97_controls_3d[0], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:			ac97->bus->ops->write(ac97, AC97_AD_CODEC_CFG, ac97->spec.ad18xx.codec_cfg[codec]);
sound/pci/ac97/ac97_patch.c:						ac97->bus->ops->write(ac97, AC97_PCM, ac97->spec.ad18xx.pcmreg[codec]);
sound/pci/ac97/ac97_patch.c:	return snd_ctl_find_id(ac97->bus->card, &id);
sound/pci/ac97/ac97_patch.c:	err = snd_ctl_add(ac97->bus->card, kctl);
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ctl_new1(&snd_ac97_controls_si3036[idx], ac97))) < 0)
sound/pci/ac97/ac97_patch.c:		if ((err = snd_ctl_add(ac97->bus->card, snd_ctl_new1(&snd_ac97_controls_ucb1400[idx], ac97))) < 0)
sound/pci/ac97/ac97_pcm.c:	tmp = (rate * ac97->bus->clock) / 48000;
sound/pci/ac97/ac97_pcm.c:		codec = bus->codec[i];
sound/pci/ac97/ac97_pcm.c:				if (bus->codec[j])
sound/pci/ac97/ac97_pcm.c:			if (!bus->codec[j])
sound/pci/ac97/ac97_pcm.c:				rpcm->r[0].codec[j] = bus->codec[j];
sound/pci/ac97/ac97_pcm.c:				if (bus->no_vra)
sound/pci/ac97/ac97_pcm.c:		    bus->codec[0] && (bus->codec[0]->flags & AC97_DOUBLE_RATE) &&
sound/pci/ac97/ac97_pcm.c:				rpcm->r[1].codec[0] = bus->codec[0];
sound/pci/ac97/ac97_pcm.c:				if (bus->no_vra)
sound/pci/ac97/ac97_pcm.c:	bus->pcms_count = pcms_count;
sound/pci/ac97/ac97_pcm.c:	bus->pcms = rpcms;
sound/pci/ac97/ac97_pcm.c:			if (bus->codec[cidx] && (bus->codec[cidx]->ext_id & AC97_EI_SPDIF)) {
sound/pci/ac97/ac97_pcm.c:				err = set_spdif_rate(bus->codec[cidx], rate);
sound/pci/ac97/ac97_pcm.c:	spin_lock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_pcm.c:			if (bus->used_slots[pcm->stream][cidx] & (1 << i)) {
sound/pci/ac97/ac97_pcm.c:				spin_unlock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_pcm.c:				bus->used_slots[pcm->stream][cidx] |= (1 << i);
sound/pci/ac97/ac97_pcm.c:			spin_unlock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_pcm.c:	spin_unlock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_pcm.c:	spin_lock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_pcm.c:			bus->used_slots[pcm->stream][cidx] &= ~(1 << i);
sound/pci/ac97/ac97_pcm.c:	spin_unlock_irq(&pcm->bus->bus_lock);
sound/pci/ac97/ac97_proc.c:	if (ac97->bus->proc == NULL)
sound/pci/ac97/ac97_proc.c:	if ((entry = snd_info_create_card_entry(ac97->bus->card, name, ac97->bus->proc)) != NULL) {
sound/pci/ac97/ac97_proc.c:	if ((entry = snd_info_create_card_entry(ac97->bus->card, name, ac97->bus->proc)) != NULL) {
sound/pci/ac97/ac97_proc.c:	sprintf(name, "codec97#%d", bus->num);
sound/pci/ac97/ac97_proc.c:	if ((entry = snd_info_create_card_entry(bus->card, name, bus->card->proc_root)) != NULL) {
sound/pci/ac97/ac97_proc.c:	bus->proc = entry;
sound/pci/ac97/ac97_proc.c:	snd_info_free_entry(bus->proc);
sound/pci/ac97/ac97_proc.c:	bus->proc = NULL;
sound/pci/ad1889.c:	struct snd_ad1889 *chip = bus->private_data;
sound/pci/ad1889.c:	chip->ac97_bus->private_free = snd_ad1889_ac97_bus_free;
sound/pci/atiixp.c:		chip->pcms[i] = &pbus->pcms[i];
sound/pci/atiixp.c:	if (pbus->pcms[ATI_PCM_OUT].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {
sound/pci/atiixp.c:		if (pbus->pcms[ATI_PCM_OUT].r[0].slots & (1 << AC97_SLOT_LFE))
sound/pci/atiixp.c:	pbus->clock = clock;
sound/pci/atiixp_modem.c:	pbus->clock = clock;
sound/pci/azt3328.c: *    Well, not quite: now ac97 layer is much improved (bus-specific ops!),
sound/pci/ca0106/ca0106_main.c:	pbus->no_vra = 1; /* we don't need VRA */
sound/pci/cs4281.c:	struct cs4281 *chip = bus->private_data;
sound/pci/cs4281.c:	chip->ac97_bus->private_free = snd_cs4281_mixer_free_ac97_bus;
sound/pci/cs46xx/cs46xx_lib.c:	struct snd_cs46xx *chip = bus->private_data;
sound/pci/cs46xx/cs46xx_lib.c:	chip->ac97_bus->private_free = snd_cs46xx_mixer_free_ac97_bus;
sound/pci/emu10k1/emu10k1x.c:	pbus->no_vra = 1; /* we don't need VRA */
sound/pci/emu10k1/emumixer.c:		pbus->no_vra = 1; /* we don't need VRA */
sound/pci/es1968.c:	pbus->no_vra = 1; /* ES1968 doesn't need VRA */
sound/pci/fm801.c:	struct fm801 *chip = bus->private_data;
sound/pci/fm801.c:	chip->ac97_bus->private_free = snd_fm801_mixer_free_ac97_bus;
sound/pci/hda/hda_auto_parser.c:		q = snd_pci_quirk_lookup(codec->bus->pci, quirk);
sound/pci/hda/hda_beep.c:	input_dev->dev.parent = &codec->bus->pci->dev;
sound/pci/hda/hda_beep.c:		"card%d/codec#%d/beep0", codec->bus->card->number, codec->addr);
sound/pci/hda/hda_codec.c:	if (bus->ops.pm_notify)
sound/pci/hda/hda_codec.c:		bus->ops.pm_notify(bus, power_up);
sound/pci/hda/hda_codec.c:	mutex_lock(&bus->cmd_mutex);
sound/pci/hda/hda_codec.c:		bus->no_response_fallback = 1;
sound/pci/hda/hda_codec.c:		err = bus->ops.command(bus, cmd);
sound/pci/hda/hda_codec.c:		bus->ops.get_response(bus, codec->addr);
sound/pci/hda/hda_codec.c:		*res = bus->ops.get_response(bus, codec->addr);
sound/pci/hda/hda_codec.c:	bus->no_response_fallback = 0;
sound/pci/hda/hda_codec.c:	mutex_unlock(&bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	if (!codec_in_pm(codec) && res && *res == -1 && bus->rirb_error) {
sound/pci/hda/hda_codec.c:		if (bus->response_reset) {
sound/pci/hda/hda_codec.c:			bus->ops.bus_reset(bus);
sound/pci/hda/hda_codec.c:		bus->response_reset = 0;
sound/pci/hda/hda_codec.c:			       codec->bus->sync_write ? &res : NULL);
sound/pci/hda/hda_codec.c:		if (parm == -1 && codec->bus->rirb_error)
sound/pci/hda/hda_codec.c:			if (parm == -1 && codec->bus->rirb_error)
sound/pci/hda/hda_codec.c:	if (parm == -1 && codec->bus->rirb_error)
sound/pci/hda/hda_codec.c:		if (parm == -1 && codec->bus->rirb_error)
sound/pci/hda/hda_codec.c:	if (!bus || !bus->workq)
sound/pci/hda/hda_codec.c:	unsol = bus->unsol;
sound/pci/hda/hda_codec.c:	queue_work(bus->workq, &unsol->work);
sound/pci/hda/hda_codec.c:		codec = bus->caddr_tbl[caddr & 0x0f];
sound/pci/hda/hda_codec.c:	if (bus->unsol) /* already initialized */
sound/pci/hda/hda_codec.c:	bus->unsol = unsol;
sound/pci/hda/hda_codec.c:	if (bus->workq)
sound/pci/hda/hda_codec.c:		flush_workqueue(bus->workq);
sound/pci/hda/hda_codec.c:	if (bus->unsol)
sound/pci/hda/hda_codec.c:		kfree(bus->unsol);
sound/pci/hda/hda_codec.c:	list_for_each_entry_safe(codec, n, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	if (bus->ops.private_free)
sound/pci/hda/hda_codec.c:		bus->ops.private_free(bus);
sound/pci/hda/hda_codec.c:	if (bus->workq)
sound/pci/hda/hda_codec.c:		destroy_workqueue(bus->workq);
sound/pci/hda/hda_codec.c:	bus->shutdown = 1;
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	bus->card = card;
sound/pci/hda/hda_codec.c:	bus->private_data = temp->private_data;
sound/pci/hda/hda_codec.c:	bus->pci = temp->pci;
sound/pci/hda/hda_codec.c:	bus->modelname = temp->modelname;
sound/pci/hda/hda_codec.c:	bus->power_save = temp->power_save;
sound/pci/hda/hda_codec.c:	bus->ops = temp->ops;
sound/pci/hda/hda_codec.c:	mutex_init(&bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	mutex_init(&bus->prepare_mutex);
sound/pci/hda/hda_codec.c:	INIT_LIST_HEAD(&bus->codec_list);
sound/pci/hda/hda_codec.c:	snprintf(bus->workq_name, sizeof(bus->workq_name),
sound/pci/hda/hda_codec.c:	bus->workq = create_singlethread_workqueue(bus->workq_name);
sound/pci/hda/hda_codec.c:	if (!bus->workq) {
sound/pci/hda/hda_codec.c:			   bus->workq_name);
sound/pci/hda/hda_codec.c:	if (codec->bus->shutdown)
sound/pci/hda/hda_codec.c:	if (codec->bus->shutdown)
sound/pci/hda/hda_codec.c:	queue_delayed_work(codec->bus->workq, &codec->jackpoll_work,
sound/pci/hda/hda_codec.c:	flush_workqueue(codec->bus->workq);
sound/pci/hda/hda_codec.c:	codec->bus->caddr_tbl[codec->addr] = NULL;
sound/pci/hda/hda_codec.c:	if (bus->caddr_tbl[codec_addr]) {
sound/pci/hda/hda_codec.c:	if (codec->bus->modelname) {
sound/pci/hda/hda_codec.c:		codec->modelname = kstrdup(codec->bus->modelname, GFP_KERNEL);
sound/pci/hda/hda_codec.c:	list_add_tail(&codec->list, &bus->codec_list);
sound/pci/hda/hda_codec.c:	bus->caddr_tbl[codec_addr] = codec;
sound/pci/hda/hda_codec.c:		bus->power_keep_link_on = 1;
sound/pci/hda/hda_codec.c:	snd_component_add(codec->bus->card, component);
sound/pci/hda/hda_codec.c:	if (!err && (codec->afg || !*codec->bus->card->mixername))
sound/pci/hda/hda_codec.c:		snprintf(codec->bus->card->mixername,
sound/pci/hda/hda_codec.c:			 sizeof(codec->bus->card->mixername),
sound/pci/hda/hda_codec.c:	list_for_each_entry(c, &codec->bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	list_for_each_entry(c, &codec->bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	return snd_ctl_find_id(codec->bus->card, &id);
sound/pci/hda/hda_codec.c:	err = snd_ctl_add(codec->bus->card, kctl);
sound/pci/hda/hda_codec.c:		snd_ctl_remove(codec->bus->card, items[i].kctl);
sound/pci/hda/hda_codec.c:	struct snd_card *card = bus->card;
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	struct snd_card *card = bus->card;
sound/pci/hda/hda_codec.c:	card = bus->card;
sound/pci/hda/hda_codec.c:	struct snd_card *card = bus->card;
sound/pci/hda/hda_codec.c:	flush_workqueue(bus->workq);
sound/pci/hda/hda_codec.c:				  bus->pcm_dev_bits);
sound/pci/hda/hda_codec.c:	if (hook->codec->bus->shutdown)
sound/pci/hda/hda_codec.c:	if (bus->primary_dig_out_type == HDA_PCM_TYPE_HDMI &&
sound/pci/hda/hda_codec.c:	} else if (bus->primary_dig_out_type == HDA_PCM_TYPE_SPDIF &&
sound/pci/hda/hda_codec.c:		bus->primary_dig_out_type = HDA_PCM_TYPE_HDMI;
sound/pci/hda/hda_codec.c:	if (!bus->primary_dig_out_type)
sound/pci/hda/hda_codec.c:		bus->primary_dig_out_type = type;
sound/pci/hda/hda_codec.c:	mutex_lock(&codec->bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	mutex_unlock(&codec->bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	mutex_lock(&codec->bus->cmd_mutex);
sound/pci/hda/hda_codec.c:		mutex_unlock(&codec->bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	mutex_unlock(&codec->bus->cmd_mutex);
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	mutex_lock(&codec->bus->prepare_mutex);
sound/pci/hda/hda_codec.c:	mutex_unlock(&codec->bus->prepare_mutex);
sound/pci/hda/hda_codec.c:	mutex_lock(&codec->bus->prepare_mutex);
sound/pci/hda/hda_codec.c:	mutex_unlock(&codec->bus->prepare_mutex);
sound/pci/hda/hda_codec.c:		if (!test_and_set_bit(audio_idx[type][i], bus->pcm_dev_bits))
sound/pci/hda/hda_codec.c:		if (!test_and_set_bit(i, bus->pcm_dev_bits))
sound/pci/hda/hda_codec.c:	return bus->ops.attach_pcm(bus, codec, pcm);
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	if (!codec->bus->pci || !tbl)
sound/pci/hda/hda_codec.c:	tbl = snd_pci_quirk_lookup(codec->bus->pci, tbl);
sound/pci/hda/hda_codec.c:	    !bus->power_keep_link_on && (state & AC_PWRST_CLK_STOP_OK)) {
sound/pci/hda/hda_codec.c:	((codec)->bus->power_save ? *(codec)->bus->power_save : 0)
sound/pci/hda/hda_codec.c:		queue_delayed_work(codec->bus->workq, &codec->power_work,
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.c:	list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_codec.h:	return codec->bus->ops.load_dsp_prepare(codec->bus, format, size, bufp);
sound/pci/hda/hda_codec.h:	return codec->bus->ops.load_dsp_trigger(codec->bus, start);
sound/pci/hda/hda_codec.h:	return codec->bus->ops.load_dsp_cleanup(codec->bus, dmab);
sound/pci/hda/hda_generic.c:	if (spec->auto_mute_via_amp && !codec->bus->shutdown)
sound/pci/hda/hda_hwdep.c:	err = snd_hwdep_new(codec->bus->card, hwname, codec->addr, &hwdep);
sound/pci/hda/hda_hwdep.c:	err = snd_card_register(codec->bus->card);
sound/pci/hda/hda_hwdep.c:		list_for_each_entry(codec, &bus->codec_list, list) {
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:			bus->rirb_error = 0;
sound/pci/hda/hda_intel.c:		if (bus->needs_damn_long_delay || loopcounter > 3000)
sound/pci/hda/hda_intel.c:	if (!bus->no_response_fallback)
sound/pci/hda/hda_intel.c:			bus->rirb_error = 1;
sound/pci/hda/hda_intel.c:	bus->rirb_error = 1;
sound/pci/hda/hda_intel.c:	if (bus->allow_bus_reset && !bus->response_reset && !bus->in_reset) {
sound/pci/hda/hda_intel.c:		bus->response_reset = 1;
sound/pci/hda/hda_intel.c:	bus->response_reset = 0;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	bus->rirb_error = 0;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:			} else if (ok == 0 && chip->bus && chip->bus->workq) {
sound/pci/hda/hda_intel.c:				queue_work(chip->bus->workq,
sound/pci/hda/hda_intel.c:	mutex_lock(&chip->bus->cmd_mutex);
sound/pci/hda/hda_intel.c:	mutex_unlock(&chip->bus->cmd_mutex);
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	bus->in_reset = 1;
sound/pci/hda/hda_intel.c:	bus->in_reset = 0;
sound/pci/hda/hda_intel.c:		chip->bus->needs_damn_long_delay = 1;
sound/pci/hda/hda_intel.c:		chip->bus->sync_write = 1;
sound/pci/hda/hda_intel.c:		chip->bus->allow_bus_reset = 1;
sound/pci/hda/hda_intel.c:	list_for_each_entry(codec, &chip->bus->codec_list, list) {
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:	struct azx *chip = bus->private_data;
sound/pci/hda/hda_intel.c:		list_for_each_entry(c, &chip->bus->codec_list, list)
sound/pci/hda/hda_intel.c:		list_for_each_entry(codec, &bus->codec_list, list)
sound/pci/hda/hda_intel.c:				queue_delayed_work(codec->bus->workq,
sound/pci/hda/hda_intel.c:							pci->bus->number, 0);
sound/pci/hda/hda_intel.c:			if (p_smbus->revision < 0x30)
sound/pci/hda/hda_intel.c:	list_for_each_entry(codec, &chip->bus->codec_list, list) {
sound/pci/hda/hda_jack.c:	if (!codec->bus->shutdown && codec->jacktbl.list) {
sound/pci/hda/hda_jack.c:				snd_device_free(codec->bus->card, jack->jack);
sound/pci/hda/hda_jack.c:			snd_kctl_jack_report(codec->bus->card, jack->kctl, state);
sound/pci/hda/hda_jack.c:	snd_kctl_jack_report(codec->bus->card, kctl, state);
sound/pci/hda/hda_jack.c:		err = snd_jack_new(codec->bus->card, name, jack->type,
sound/pci/hda/hda_proc.c:	err = snd_card_proc_new(codec->bus->card, name, &entry);
sound/pci/hda/hda_trace.h:		__entry->card = (codec)->bus->card->number;
sound/pci/hda/hda_trace.h:		__entry->card = (codec)->bus->card->number;
sound/pci/hda/hda_trace.h:		__entry->card = (codec)->bus->card->number;
sound/pci/hda/patch_ca0110.c:	codec->bus->needs_damn_long_delay = 1;
sound/pci/hda/patch_ca0132.c:	if (request_firmware(&fw_entry, EFX_FILE, codec->bus->card->dev) != 0)
sound/pci/hda/patch_ca0132.c:			queue_delayed_work(codec->bus->workq,
sound/pci/hda/patch_conexant.c:	if (!codec->bus->sync_write) {
sound/pci/hda/patch_conexant.c:		codec->bus->sync_write = 1;
sound/pci/hda/patch_conexant.c:		codec->bus->allow_bus_reset = 1;
sound/pci/hda/patch_hdmi.c:	err = snd_card_proc_new(codec->bus->card, name, &entry);
sound/pci/hda/patch_hdmi.c:	if (!per_pin->codec->bus->shutdown && per_pin->proc_entry) {
sound/pci/hda/patch_hdmi.c:		snd_device_free(per_pin->codec->bus->card, per_pin->proc_entry);
sound/pci/hda/patch_hdmi.c:			queue_delayed_work(codec->bus->workq,
sound/pci/hda/patch_hdmi.c:		snd_ctl_notify(codec->bus->card,
sound/pci/hda/patch_hdmi.c:		codec->bus->power_keep_link_on = 1;
sound/pci/hda/patch_hdmi.c:		codec->bus->power_keep_link_on = 1;
sound/pci/hda/patch_hdmi.c:	flush_workqueue(codec->bus->workq);
sound/pci/hda/patch_realtek.c:	if (ass != codec->bus->pci->subsystem_device && (ass & 1))
sound/pci/hda/patch_realtek.c:	if ((ass != codec->bus->pci->subsystem_device) && (ass & 1))
sound/pci/hda/patch_realtek.c:	q = snd_pci_quirk_lookup(codec->bus->pci, beep_white_list);
sound/pci/hda/patch_realtek.c:			if (codec->bus->pci->subsystem_vendor == 0x1025 &&
sound/pci/hda/patch_realtek.c:			if (codec->bus->pci->subsystem_vendor == 0x17aa &&
sound/pci/hda/patch_realtek.c:			    codec->bus->pci->subsystem_device == 0x21f3)
sound/pci/hda/patch_realtek.c:	    codec->bus->pci->subsystem_vendor == 0x1025 &&
sound/pci/hda/patch_sigmatel.c:		codec->bus->power_keep_link_on = 1;
sound/pci/hda/patch_sigmatel.c:	codec->bus->needs_damn_long_delay = 1;
sound/pci/hda/patch_via.c:			queue_delayed_work(codec->bus->workq,
sound/pci/hda/patch_via.c:		snprintf(codec->bus->card->mixername,
sound/pci/hda/patch_via.c:			 sizeof(codec->bus->card->mixername),
sound/pci/hda/patch_via.c:		snprintf(codec->bus->card->mixername,
sound/pci/hda/patch_via.c:			 sizeof(codec->bus->card->mixername),
sound/pci/ice1712/delta.c:	struct snd_ice1712 *ice = device->bus->private_data;
sound/pci/ice1712/delta.c:	struct snd_ice1712 *ice = device->bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/ews.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/revo.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/revo.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/revo.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/revo.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/ice1712/revo.c:	struct snd_ice1712 *ice = bus->private_data;
sound/pci/intel8x0.c:	struct intel8x0 *chip = bus->private_data;
sound/pci/intel8x0.c:	pbus->private_free = snd_intel8x0_mixer_free_ac97_bus;
sound/pci/intel8x0.c:		pbus->clock = ac97_clock;
sound/pci/intel8x0.c:		pbus->no_vra = 1;
sound/pci/intel8x0.c:		pbus->dra = 1;
sound/pci/intel8x0.c:		pbus->isdin = 1;
sound/pci/intel8x0.c:	chip->ichd[ICHD_PCMOUT].pcm = &pbus->pcms[0];
sound/pci/intel8x0.c:	chip->ichd[ICHD_PCMIN].pcm = &pbus->pcms[1];
sound/pci/intel8x0.c:	chip->ichd[ICHD_MIC].pcm = &pbus->pcms[2];
sound/pci/intel8x0.c:		chip->ichd[chip->spdif_idx].pcm = &pbus->pcms[3];
sound/pci/intel8x0.c:		chip->ichd[ICHD_PCM2IN].pcm = &pbus->pcms[4];
sound/pci/intel8x0.c:		chip->ichd[ICHD_MIC2].pcm = &pbus->pcms[5];
sound/pci/intel8x0.c:	if (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {
sound/pci/intel8x0.c:		if (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_LFE)) {
sound/pci/intel8x0.c:	if (pbus->pcms[0].r[1].rslots[0]) {
sound/pci/intel8x0.c:	if (chip->ac97_bus->clock != 48000)
sound/pci/intel8x0.c:		snd_printk(KERN_ERR "cannot set ac97 rate: clock = %d\n", chip->ac97_bus->clock);
sound/pci/intel8x0.c:		chip->ac97_bus->clock = 41000;
sound/pci/intel8x0.c:		chip->ac97_bus->clock = 44100;
sound/pci/intel8x0.c:		chip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;
sound/pci/intel8x0.c:	printk(KERN_INFO "intel8x0: clocking to %d\n", chip->ac97_bus->clock);
sound/pci/intel8x0.c:	chip->ac97_bus->clock = wl->value;
sound/pci/intel8x0m.c:	struct intel8x0m *chip = bus->private_data;
sound/pci/intel8x0m.c:	pbus->private_free = snd_intel8x0m_mixer_free_ac97_bus;
sound/pci/intel8x0m.c:		pbus->clock = ac97_clock;
sound/pci/nm256/nm256.c:	pbus->no_vra = 1;
sound/pci/oxygen/oxygen_lib.c:	if (!pci->bus || !pci->bus->self)
sound/pci/oxygen/oxygen_lib.c:	bridge = pci->bus->self;
sound/pci/rme9652/hdsp.c:	/* Align to bus-space 64K boundary */
sound/pci/rme9652/rme9652.c:	/* Align to bus-space 64K boundary */
sound/pci/via82xx.c:	struct via82xx *chip = bus->private_data;
sound/pci/via82xx.c:	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
sound/pci/via82xx.c:	chip->ac97_bus->clock = chip->ac97_clock;
sound/pci/via82xx_modem.c:	struct via82xx_modem *chip = bus->private_data;
sound/pci/via82xx_modem.c:	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
sound/pci/via82xx_modem.c:	chip->ac97_bus->clock = chip->ac97_clock;
sound/pci/ymfpci/ymfpci_main.c:	struct snd_ymfpci *chip = bus->private_data;
sound/pci/ymfpci/ymfpci_main.c:	chip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;
sound/pci/ymfpci/ymfpci_main.c:	chip->ac97_bus->no_vra = 1; /* YMFPCI doesn't need VRA */
sound/soc/au1x/psc-ac97.c:/* this could theoretically work, but ac97->bus->card->private_data can be NULL
sound/soc/au1x/psc-ac97.c:	struct snd_soc_card *c = x->bus->card->private_data;
sound/soc/codecs/stac9766.c:	codec->ac97->bus->ops->warm_reset(codec->ac97);
sound/soc/fsl/mpc8610_hpcd.c:			dev_err(&pdev->dev, "codec bus-frequency "
sound/soc/fsl/p1022_ds.c:			dev_err(&pdev->dev, "codec bus-frequency "
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "codec bus-frequency property is missing or invalid\n");
sound/soc/soc-core.c:	codec->ac97->bus->ops = ops;
sound/soc/soc-core.c:		/* I2C component devices are named "bus-addr"  */
sound/usb/6fire/chip.c:			device->bus->busnum, device->devnum);
sound/usb/proc.c:		snd_iprintf(buffer, "%03d/%03d\n", chip->dev->bus->busnum, chip->dev->devnum);
sound/usb/usx2y/us122l.c:		dev->bus->busnum, dev->devnum);
sound/usb/usx2y/us122l.c:		US122L(card)->dev->bus->busnum,
sound/usb/usx2y/usX2Yhwdep.c:	sprintf(hw->name, "/proc/bus/usb/%03d/%03d", device->bus->busnum, device->devnum);
sound/usb/usx2y/usbusx2y.c:		usX2Y(card)->dev->bus->busnum, usX2Y(card)->dev->devnum
sound/usb/usx2y/usx2yhwdeppcm.c:	sprintf(hw->name, "/proc/bus/usb/%03d/%03d/hwdeppcm", dev->bus->busnum, dev->devnum);
tools/perf/util/evsel.c:	"bus-cycles",
tools/perf/util/parse-events.c:		.symbol = "bus-cycles",
tools/perf/util/parse-events.l:bus-cycles					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BUS_CYCLES); }
virt/kvm/kvm_main.c:	for (i = 0; i < bus->dev_count; i++) {
virt/kvm/kvm_main.c:		struct kvm_io_device *pos = bus->range[i].dev;
virt/kvm/kvm_main.c:	bus->range[bus->dev_count++] = (struct kvm_io_range) {
virt/kvm/kvm_main.c:	sort(bus->range, bus->dev_count, sizeof(struct kvm_io_range),
virt/kvm/kvm_main.c:	range = bsearch(&key, bus->range, bus->dev_count,
virt/kvm/kvm_main.c:	off = range - bus->range;
virt/kvm/kvm_main.c:	while (off > 0 && kvm_io_bus_cmp(&key, &bus->range[off-1]) == 0)
virt/kvm/kvm_main.c:	while (idx < bus->dev_count &&
virt/kvm/kvm_main.c:		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {
virt/kvm/kvm_main.c:		if (!kvm_iodevice_write(bus->range[idx].dev, range->addr,
virt/kvm/kvm_main.c:	if ((cookie >= 0) && (cookie < bus->dev_count) &&
virt/kvm/kvm_main.c:	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))
virt/kvm/kvm_main.c:		if (!kvm_iodevice_write(bus->range[cookie].dev, addr, len,
virt/kvm/kvm_main.c:	while (idx < bus->dev_count &&
virt/kvm/kvm_main.c:		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {
virt/kvm/kvm_main.c:		if (!kvm_iodevice_read(bus->range[idx].dev, range->addr,
virt/kvm/kvm_main.c:	if ((cookie >= 0) && (cookie < bus->dev_count) &&
virt/kvm/kvm_main.c:	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))
virt/kvm/kvm_main.c:		if (!kvm_iodevice_read(bus->range[cookie].dev, addr, len,
virt/kvm/kvm_main.c:	if (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)
virt/kvm/kvm_main.c:	new_bus = kzalloc(sizeof(*bus) + ((bus->dev_count + 1) *
virt/kvm/kvm_main.c:	memcpy(new_bus, bus, sizeof(*bus) + (bus->dev_count *
virt/kvm/kvm_main.c:	for (i = 0; i < bus->dev_count; i++)
virt/kvm/kvm_main.c:		if (bus->range[i].dev == dev) {
virt/kvm/kvm_main.c:	new_bus = kzalloc(sizeof(*bus) + ((bus->dev_count - 1) *
virt/kvm/kvm_main.c:	new_bus->dev_count--;
virt/kvm/kvm_main.c:	memcpy(new_bus->range + i, bus->range + i + 1,
virt/kvm/kvm_main.c:	       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));
